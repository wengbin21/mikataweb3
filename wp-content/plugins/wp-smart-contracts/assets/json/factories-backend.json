{
    "vanilla":{
        "data": {
            "2.0": {
                "abi_factory":[ { "constant": false, "inputs": [], "name": "buyCoffee", "outputs": [ { "name": "", "type": "bool" } ], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": false, "inputs": [ { "name": "in_wei", "type": "uint256" }, { "name": "from_address", "type": "address" } ], "name": "buyTea", "outputs": [ { "name": "", "type": "bool" } ], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_symbol", "type": "string" }, { "name": "_name", "type": "string" }, { "name": "_totalSupply", "type": "uint256" } ], "name": "createToken", "outputs": [ { "name": "", "type": "address" } ], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_symbol", "type": "string" }, { "name": "_name", "type": "string" }, { "name": "_totalSupply", "type": "uint256" } ], "name": "createTokenWithWPST", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_claimRatio", "type": "uint256" } ], "name": "updateClaimRatio", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_masterFee", "type": "uint256" } ], "name": "updateFee", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_masterAddress", "type": "address" } ], "name": "updateMasterAddress", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_rewardsRatio", "type": "uint256" } ], "name": "updateRewardsRatio", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_token", "type": "address" } ], "name": "updateToken", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "name": "_token", "type": "address" }, { "name": "_rewardsRatio", "type": "uint256" }, { "name": "_claimRatio", "type": "uint256" }, { "name": "_masterFee", "type": "uint256" }, { "name": "_masterAddress", "type": "address" } ], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [ { "indexed": false, "name": "ANewContractAddress", "type": "address" } ], "name": "newAddress", "type": "event" }, { "constant": true, "inputs": [ { "name": "account", "type": "address" }, { "name": "in_wei", "type": "uint256" } ], "name": "canBuyTea", "outputs": [ { "name": "", "type": "bool" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [ { "name": "_manager", "type": "address" } ], "name": "getDeployedTokensByManager", "outputs": [ { "name": "", "type": "address[]" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "getDeployedTokensBySender", "outputs": [ { "name": "", "type": "address[]" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "getManagers", "outputs": [ { "name": "", "type": "address[]" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "getMasterAddress", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [ { "name": "in_wei", "type": "uint256" } ], "name": "getPriceInToken", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [ { "name": "in_wei", "type": "uint256" } ], "name": "getRewards", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "masterAddress", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "masterFee", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "token", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "view", "type": "function" } ],
                "source":"\/**\n\n██╗    ██╗██████╗ ███████╗███╗   ███╗ █████╗ ██████╗ ████████╗ ██████╗ ██████╗ ███╗   ██╗████████╗██████╗  █████╗  ██████╗████████╗███████╗    ██████╗ ██████╗ ███╗   ███╗\n██║    ██║██╔══██╗██╔════╝████╗ ████║██╔══██╗██╔══██╗╚══██╔══╝██╔════╝██╔═══██╗████╗  ██║╚══██╔══╝██╔══██╗██╔══██╗██╔════╝╚══██╔══╝██╔════╝   ██╔════╝██╔═══██╗████╗ ████║\n██║ █╗ ██║██████╔╝███████╗██╔████╔██║███████║██████╔╝   ██║   ██║     ██║   ██║██╔██╗ ██║   ██║   ██████╔╝███████║██║        ██║   ███████╗   ██║     ██║   ██║██╔████╔██║\n██║███╗██║██╔═══╝ ╚════██║██║╚██╔╝██║██╔══██║██╔══██╗   ██║   ██║     ██║   ██║██║╚██╗██║   ██║   ██╔══██╗██╔══██║██║        ██║   ╚════██║   ██║     ██║   ██║██║╚██╔╝██║\n╚███╔███╔╝██║     ███████║██║ ╚═╝ ██║██║  ██║██║  ██║   ██║   ╚██████╗╚██████╔╝██║ ╚████║   ██║   ██║  ██║██║  ██║╚██████╗   ██║   ███████║██╗╚██████╗╚██████╔╝██║ ╚═╝ ██║\n ╚══╝╚══╝ ╚═╝     ╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝    ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝   ╚═╝   ╚══════╝╚═╝ ╚═════╝ ╚═════╝ ╚═╝     ╚═╝\n\nBlockchain Made Easy\n\nhttp:\/\/wpsmartcontracts.com\/\n\n*\/\n\npragma solidity ^0.5.7;\n\ncontract IRC20Vanilla {\n    \/* This is a slight change to the ERC20 base standard.\n    function totalSupply() constant returns (uint256 supply);\n    is replaced with:\n    uint256 public totalSupply;\n    This automatically creates a getter function for the totalSupply.\n    This is moved to the base contract since public getter functions are not\n    currently recognised as an implementation of the matching abstract\n    function by the compiler.\n    *\/\n    \/\/\/ total amount of tokens\n    uint256 public totalSupply;\n\n    \/\/\/ @param _owner The address from which the balance will be retrieved\n    \/\/\/ @return The balance\n    function balanceOf(address _owner) public view returns (uint256 balance);\n\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\n    \/\/\/ @param _to The address of the recipient\n    \/\/\/ @param _value The amount of token to be transferred\n    \/\/\/ @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    \/\/\/ @param _from The address of the sender\n    \/\/\/ @param _to The address of the recipient\n    \/\/\/ @param _value The amount of token to be transferred\n    \/\/\/ @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\n    \/\/\/ @param _value The amount of tokens to be approved for transfer\n    \/\/\/ @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    \/\/\/ @param _owner The address of the account owning tokens\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\n    \/\/\/ @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n\n    \/\/ solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract ERC20Vanilla is IRC20Vanilla {\n\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    \/*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets\/interfaces might not even bother to look at this information.\n    *\/\n    string public name;                   \/\/fancy name: eg Simon Bucks\n    uint8 public decimals;                \/\/How many decimals to show.\n    string public symbol;                 \/\/An identifier: eg SBX\n\n    constructor(address _manager, uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol\n    ) public {\n        balances[_manager] = _initialAmount;               \/\/ Give the creator all initial tokens\n        totalSupply = _initialAmount;                        \/\/ Update total supply\n        name = _tokenName;                                   \/\/ Set the name for display purposes\n        decimals = _decimalUnits;                            \/\/ Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               \/\/ Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n}",
                "tokenContractName":"ERC20Vanilla",
                "version": "2.0",
                "tokenCompilerVersion":"v0.5.7+commit.6da8b019"
            }
        }
    },
    "pistachio": {
        "data": {
            "2.0": {
                "abi_factory":[ { "constant": false, "inputs": [], "name": "buyCoffee", "outputs": [ { "name": "", "type": "bool" } ], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": false, "inputs": [ { "name": "in_wei", "type": "uint256" }, { "name": "from_address", "type": "address" } ], "name": "buyTea", "outputs": [ { "name": "", "type": "bool" } ], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_symbol", "type": "string" }, { "name": "_name", "type": "string" }, { "name": "_totalSupply", "type": "uint256" } ], "name": "createToken", "outputs": [ { "name": "", "type": "address" } ], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_symbol", "type": "string" }, { "name": "_name", "type": "string" }, { "name": "_totalSupply", "type": "uint256" } ], "name": "createTokenWithWPST", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_claimRatio", "type": "uint256" } ], "name": "updateClaimRatio", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_masterFee", "type": "uint256" } ], "name": "updateFee", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_masterAddress", "type": "address" } ], "name": "updateMasterAddress", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_rewardsRatio", "type": "uint256" } ], "name": "updateRewardsRatio", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_token", "type": "address" } ], "name": "updateToken", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "name": "_token", "type": "address" }, { "name": "_rewardsRatio", "type": "uint256" }, { "name": "_claimRatio", "type": "uint256" }, { "name": "_masterFee", "type": "uint256" }, { "name": "_masterAddress", "type": "address" } ], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [ { "indexed": false, "name": "ANewContractAddress", "type": "address" } ], "name": "newAddress", "type": "event" }, { "constant": true, "inputs": [ { "name": "account", "type": "address" }, { "name": "in_wei", "type": "uint256" } ], "name": "canBuyTea", "outputs": [ { "name": "", "type": "bool" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [ { "name": "_manager", "type": "address" } ], "name": "getDeployedTokensByManager", "outputs": [ { "name": "", "type": "address[]" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "getDeployedTokensBySender", "outputs": [ { "name": "", "type": "address[]" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "getManagers", "outputs": [ { "name": "", "type": "address[]" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "getMasterAddress", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [ { "name": "in_wei", "type": "uint256" } ], "name": "getPriceInToken", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [ { "name": "in_wei", "type": "uint256" } ], "name": "getRewards", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "masterAddress", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "masterFee", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "token", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "view", "type": "function" } ],
                "source":"\/**\n\n██╗    ██╗██████╗ ███████╗███╗   ███╗ █████╗ ██████╗ ████████╗ ██████╗ ██████╗ ███╗   ██╗████████╗██████╗  █████╗  ██████╗████████╗███████╗    ██████╗ ██████╗ ███╗   ███╗\n██║    ██║██╔══██╗██╔════╝████╗ ████║██╔══██╗██╔══██╗╚══██╔══╝██╔════╝██╔═══██╗████╗  ██║╚══██╔══╝██╔══██╗██╔══██╗██╔════╝╚══██╔══╝██╔════╝   ██╔════╝██╔═══██╗████╗ ████║\n██║ █╗ ██║██████╔╝███████╗██╔████╔██║███████║██████╔╝   ██║   ██║     ██║   ██║██╔██╗ ██║   ██║   ██████╔╝███████║██║        ██║   ███████╗   ██║     ██║   ██║██╔████╔██║\n██║███╗██║██╔═══╝ ╚════██║██║╚██╔╝██║██╔══██║██╔══██╗   ██║   ██║     ██║   ██║██║╚██╗██║   ██║   ██╔══██╗██╔══██║██║        ██║   ╚════██║   ██║     ██║   ██║██║╚██╔╝██║\n╚███╔███╔╝██║     ███████║██║ ╚═╝ ██║██║  ██║██║  ██║   ██║   ╚██████╗╚██████╔╝██║ ╚████║   ██║   ██║  ██║██║  ██║╚██████╗   ██║   ███████║██╗╚██████╗╚██████╔╝██║ ╚═╝ ██║\n ╚══╝╚══╝ ╚═╝     ╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝    ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝   ╚═╝   ╚══════╝╚═╝ ╚═════╝ ╚═════╝ ╚═╝     ╚═╝\n\nBlockchain Made Easy\n\nhttp:\/\/wpsmartcontracts.com\/\n\n*\/\n\npragma solidity ^0.5.7;\n\n\/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n *\/\nlibrary SafeMath {\n    \n    int256 constant private INT256_MIN = -2**255;\n\n    \/**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    *\/\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \/\/ Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        \/\/ benefit is lost if 'b' is also tested.\n        \/\/ See: https:\/\/github.com\/OpenZeppelin\/openzeppelin-solidity\/pull\/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c \/ a == b);\n\n        return c;\n    }\n\n    \/**\n    * @dev Multiplies two signed integers, reverts on overflow.\n    *\/\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        \/\/ Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        \/\/ benefit is lost if 'b' is also tested.\n        \/\/ See: https:\/\/github.com\/OpenZeppelin\/openzeppelin-solidity\/pull\/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == INT256_MIN)); \/\/ This is the only case of overflow not detected by the check below\n\n        int256 c = a * b;\n        require(c \/ a == b);\n\n        return c;\n    }\n\n    \/**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    *\/\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \/\/ Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a \/ b;\n        \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    \/**\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n    *\/\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0); \/\/ Solidity only automatically asserts when dividing by 0\n        require(!(b == -1 && a == INT256_MIN)); \/\/ This is the only case of overflow\n\n        int256 c = a \/ b;\n\n        return c;\n    }\n\n    \/**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    *\/\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \/**\n    * @dev Subtracts two signed integers, reverts on overflow.\n    *\/\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\n\n        return c;\n    }\n\n    \/**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    *\/\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    \/**\n    * @dev Adds two signed integers, reverts on overflow.\n    *\/\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n\n        return c;\n    }\n\n    \/**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    *\/\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n\/**\n * @title ERC20 interface\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\n *\/\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Pistachio is IERC20 {\n\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    \/**\n    * @dev Public parameters to define the token\n    *\/\n\n    \/\/ Token symbol (short)\n    string public symbol;\n\n    \/\/ Token name (Long)\n    string public  name;\n\n    \/\/ Decimals (18 maximum)\n    uint8 public decimals;\n\n    \/**\n    * @dev Public functions to make the contract accesible\n    *\/\n    constructor (address initialAccount, string memory _tokenSymbol, string memory _tokenName, uint256 initialBalance) public {\n\n        \/\/ Initialize Contract Parameters\n        symbol = _tokenSymbol;\n        name = _tokenName;\n        decimals = 18;  \/\/ default decimals is going to be 18 always\n\n        _mint(initialAccount, initialBalance);\n        \n    }\n\n    \/**\n    * @dev Total number of tokens in existence\n    *\/\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \/**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    *\/\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    \/**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     *\/\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    \/**\n    * @dev Transfer token for a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    *\/\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    \/**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     *\/\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    \/**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     *\/\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    \/**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     *\/\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    \/**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     *\/\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    \/**\n    * @dev Transfer token for a specified addresses\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    *\/\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    \/**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     *\/\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    \/**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     *\/\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    \/**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     *\/\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\n\n}",
                "tokenContractName":"ERC20Pistachio",
                "version": "2.0",
                "tokenCompilerVersion":"v0.5.7+commit.6da8b019"
            },
            "3.0": {
                "abi_factory":[{"inputs":[{"internalType":"contract ERC20Pistachio","name":"_token","type":"address"},{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"},{"internalType":"uint256","name":"_claimRatio","type":"uint256"},{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"inputs":[],"name":"buyCoffee","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"},{"internalType":"address","name":"from_address","type":"address"}],"name":"buyTea","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"canBuyTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint8","name":"_decimals","type":"uint8"},{"internalType":"uint256","name":"_supply","type":"uint256"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint8","name":"_decimals","type":"uint8"},{"internalType":"uint256","name":"_supply","type":"uint256"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"enableTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getPriceInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"master","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"contract ERC20Pistachio","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_claimRatio","type":"uint256"}],"name":"updateClaimRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_enabled","type":"bool"}],"name":"updateEnabled","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"}],"name":"updateRewardsRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract ERC20Pistachio","name":"_token","type":"address"}],"name":"updateToken","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source":"\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  ERC-20 Standard Token\n    |\n    |----------------------------\n    |\n    |  Flavors\n    |\n    |  >  Pistachio 3.0: ERC-20 Standard Token\n    |\n\n*\/\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n *\/\ninterface IERC20 {\n    \/**\n     * @dev Returns the amount of tokens in existence.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns the amount of tokens owned by `account`.\n     *\/\n    function balanceOf(address account) external view returns (uint256);\n\n    \/**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     *\/\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    \/**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \/**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     *\/\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n *\/\ninterface IERC20Metadata is IERC20 {\n    \/**\n     * @dev Returns the name of the token.\n     *\/\n    function name() external view returns (string memory);\n\n    \/**\n     * @dev Returns the symbol of the token.\n     *\/\n    function symbol() external view returns (string memory);\n\n    \/**\n     * @dev Returns the decimals places of the token.\n     *\/\n    function decimals() external view returns (uint8);\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https:\/\/forum.zeppelin.solutions\/t\/how-to-implement-erc20-supply-mechanisms\/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n *\/\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    \/**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     *\/\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    \/**\n     * @dev Returns the name of the token.\n     *\/\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     *\/\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 \/ 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     *\/\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    \/**\n     * @dev See {IERC20-totalSupply}.\n     *\/\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    \/**\n     * @dev See {IERC20-balanceOf}.\n     *\/\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    \/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     *\/\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    \/**\n     * @dev See {IERC20-allowance}.\n     *\/\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    \/**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     *\/\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    \/**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     *\/\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    \/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     *\/\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    \/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     *\/\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    \/**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     *\/\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    \/** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    \/**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     *\/\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\/\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    \/**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    \/**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\ncontract ERC20Pistachio is ERC20 {\n\n    uint8 private immutable _decimals;\n\n    constructor(address owner_, string memory name_, string memory symbol_, uint8 decimals_, uint256 supply_) ERC20(name_, symbol_) {\n        require(decimals_ <= 18, \"ERC20Pistachio: decimals has to be lower or equal than 18\");\n        _decimals = decimals_;\n        _mint(owner_, supply_);\n    }\n\n    \/**\n     * @dev Returns the the token's decimal places.\n     *\/\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n}",
                "tokenContractName":"ERC20Pistachio",
                "version": "3.0",
                "compilerVersion":"v0.8.2"
            }
        }
    },
    "chocolate":{
        "data": {
            "2.0": {
                "abi_factory":[ { "constant": true, "inputs": [ { "name": "in_wei", "type": "uint256" } ], "name": "getPriceInToken", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "getMasterAddress", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [ { "name": "in_wei", "type": "uint256" }, { "name": "from_address", "type": "address" } ], "name": "buyTea", "outputs": [ { "name": "", "type": "bool" } ], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "getDeployedTokensBySender", "outputs": [ { "name": "", "type": "address[]" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "masterFee", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [ { "name": "_symbol", "type": "string" }, { "name": "_name", "type": "string" }, { "name": "_totalSupply", "type": "uint256" }, { "name": "cap", "type": "uint256" }, { "name": "_burnableOption", "type": "bool" }, { "name": "_mintableOption", "type": "bool" }, { "name": "_pausableOption", "type": "bool" } ], "name": "createToken", "outputs": [ { "name": "", "type": "address" } ], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": true, "inputs": [ { "name": "account", "type": "address" }, { "name": "in_wei", "type": "uint256" } ], "name": "canBuyTea", "outputs": [ { "name": "", "type": "bool" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [ { "name": "_claimRatio", "type": "uint256" } ], "name": "updateClaimRatio", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_masterAddress", "type": "address" } ], "name": "updateMasterAddress", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_token", "type": "address" } ], "name": "updateToken", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_masterFee", "type": "uint256" } ], "name": "updateFee", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_symbol", "type": "string" }, { "name": "_name", "type": "string" }, { "name": "_totalSupply", "type": "uint256" }, { "name": "cap", "type": "uint256" }, { "name": "_burnableOption", "type": "bool" }, { "name": "_mintableOption", "type": "bool" }, { "name": "_pausableOption", "type": "bool" } ], "name": "createTokenWithWPST", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "getManagers", "outputs": [ { "name": "", "type": "address[]" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [], "name": "buyCoffee", "outputs": [ { "name": "", "type": "bool" } ], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": true, "inputs": [ { "name": "in_wei", "type": "uint256" } ], "name": "getRewards", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [ { "name": "_rewardsRatio", "type": "uint256" } ], "name": "updateRewardsRatio", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "masterAddress", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [ { "name": "_manager", "type": "address" } ], "name": "getDeployedTokensByManager", "outputs": [ { "name": "", "type": "address[]" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "token", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "inputs": [ { "name": "_token", "type": "address" }, { "name": "_rewardsRatio", "type": "uint256" }, { "name": "_claimRatio", "type": "uint256" }, { "name": "_masterFee", "type": "uint256" }, { "name": "_masterAddress", "type": "address" } ], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [ { "indexed": false, "name": "ANewContractAddress", "type": "address" } ], "name": "newAddress", "type": "event" } ],
                "source":"\/**\n\n██╗    ██╗██████╗ ███████╗███╗   ███╗ █████╗ ██████╗ ████████╗ ██████╗ ██████╗ ███╗   ██╗████████╗██████╗  █████╗  ██████╗████████╗███████╗    ██████╗ ██████╗ ███╗   ███╗\n██║    ██║██╔══██╗██╔════╝████╗ ████║██╔══██╗██╔══██╗╚══██╔══╝██╔════╝██╔═══██╗████╗  ██║╚══██╔══╝██╔══██╗██╔══██╗██╔════╝╚══██╔══╝██╔════╝   ██╔════╝██╔═══██╗████╗ ████║\n██║ █╗ ██║██████╔╝███████╗██╔████╔██║███████║██████╔╝   ██║   ██║     ██║   ██║██╔██╗ ██║   ██║   ██████╔╝███████║██║        ██║   ███████╗   ██║     ██║   ██║██╔████╔██║\n██║███╗██║██╔═══╝ ╚════██║██║╚██╔╝██║██╔══██║██╔══██╗   ██║   ██║     ██║   ██║██║╚██╗██║   ██║   ██╔══██╗██╔══██║██║        ██║   ╚════██║   ██║     ██║   ██║██║╚██╔╝██║\n╚███╔███╔╝██║     ███████║██║ ╚═╝ ██║██║  ██║██║  ██║   ██║   ╚██████╗╚██████╔╝██║ ╚████║   ██║   ██║  ██║██║  ██║╚██████╗   ██║   ███████║██╗╚██████╗╚██████╔╝██║ ╚═╝ ██║\n ╚══╝╚══╝ ╚═╝     ╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝    ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝   ╚═╝   ╚══════╝╚═╝ ╚═════╝ ╚═════╝ ╚═╝     ╚═╝\n\nBlockchain Made Easy\n\nhttp:\/\/wpsmartcontracts.com\/\n\n*\/\n\npragma solidity ^0.5.7;\n\n\/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n *\/\nlibrary SafeMath {\n    \n    int256 constant private INT256_MIN = -2**255;\n\n    \/**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    *\/\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \/\/ Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        \/\/ benefit is lost if 'b' is also tested.\n        \/\/ See: https:\/\/github.com\/OpenZeppelin\/openzeppelin-solidity\/pull\/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c \/ a == b);\n\n        return c;\n    }\n\n    \/**\n    * @dev Multiplies two signed integers, reverts on overflow.\n    *\/\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        \/\/ Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        \/\/ benefit is lost if 'b' is also tested.\n        \/\/ See: https:\/\/github.com\/OpenZeppelin\/openzeppelin-solidity\/pull\/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == INT256_MIN)); \/\/ This is the only case of overflow not detected by the check below\n\n        int256 c = a * b;\n        require(c \/ a == b);\n\n        return c;\n    }\n\n    \/**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    *\/\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \/\/ Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a \/ b;\n        \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    \/**\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n    *\/\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0); \/\/ Solidity only automatically asserts when dividing by 0\n        require(!(b == -1 && a == INT256_MIN)); \/\/ This is the only case of overflow\n\n        int256 c = a \/ b;\n\n        return c;\n    }\n\n    \/**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    *\/\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \/**\n    * @dev Subtracts two signed integers, reverts on overflow.\n    *\/\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\n\n        return c;\n    }\n\n    \/**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    *\/\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    \/**\n    * @dev Adds two signed integers, reverts on overflow.\n    *\/\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n\n        return c;\n    }\n\n    \/**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    *\/\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n\n\/**\n * @title ERC20 interface\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\n *\/\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Pistachio is IERC20 {\n\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    \/**\n    * @dev Public parameters to define the token\n    *\/\n\n    \/\/ Token symbol (short)\n    string public symbol;\n\n    \/\/ Token name (Long)\n    string public  name;\n\n    \/\/ Decimals (18 maximum)\n    uint8 public decimals;\n\n    \/**\n    * @dev Public functions to make the contract accesible\n    *\/\n    constructor (address initialAccount, string memory _tokenSymbol, string memory _tokenName, uint256 initialBalance) public {\n\n        \/\/ Initialize Contract Parameters\n        symbol = _tokenSymbol;\n        name = _tokenName;\n        decimals = 18;  \/\/ default decimals is going to be 18 always\n\n        _mint(initialAccount, initialBalance);\n\n    }\n\n    \/**\n    * @dev Total number of tokens in existence\n    *\/\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \/**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    *\/\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    \/**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     *\/\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    \/**\n    * @dev Transfer token for a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    *\/\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    \/**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     *\/\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    \/**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     *\/\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    \/**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     *\/\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    \/**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     *\/\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    \/**\n    * @dev Transfer token for a specified addresses\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    *\/\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    \/**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     *\/\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    \/**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     *\/\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    \/**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     *\/\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\n\n}\n\n\/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n *\/\ncontract ERC20Burnable is ERC20Pistachio {\n\n    bool private _burnableActive;\n\n    \/**\n     * @dev Burns a specific amount of tokens.\n     * @param value The amount of token to be burned.\n     *\/\n    function burn(uint256 value) public whenBurnableActive {\n        _burn(msg.sender, value);\n    }\n\n    \/**\n     * @dev Burns a specific amount of tokens from the target address and decrements allowance\n     * @param from address The address which you want to send tokens from\n     * @param value uint256 The amount of token to be burned\n     *\/\n    function burnFrom(address from, uint256 value) public whenBurnableActive {\n        _burnFrom(from, value);\n    }\n\n    \/**\n     * @dev Options to activate or deactivate Burn ability\n     *\/\n\n    function _setBurnableActive(bool _active) internal {\n        _burnableActive = _active;\n    }\n\n    modifier whenBurnableActive() {\n        require(_burnableActive);\n        _;\n    }\n\n}\n\n\/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n *\/\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    \/**\n     * @dev give an account access to this role\n     *\/\n    function add(Role storage role, address account) internal {\n        require(account != address(0));\n        require(!has(role, account));\n\n        role.bearer[account] = true;\n    }\n\n    \/**\n     * @dev remove an account's access to this role\n     *\/\n    function remove(Role storage role, address account) internal {\n        require(account != address(0));\n        require(has(role, account));\n\n        role.bearer[account] = false;\n    }\n\n    \/**\n     * @dev check if an account has this role\n     * @return bool\n     *\/\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0));\n        return role.bearer[account];\n    }\n}\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender));\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\n\/**\n * @title ERC20Mintable\n * @dev ERC20 minting logic\n *\/\ncontract ERC20Mintable is ERC20Pistachio, MinterRole {\n\n    bool private _mintableActive;\n    \/**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param value The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     *\/\n    function mint(address to, uint256 value) public onlyMinter whenMintableActive returns (bool) {\n        _mint(to, value);\n        return true;\n    }\n\n    \/**\n     * @dev Options to activate or deactivate Burn ability\n     *\/\n\n    function _setMintableActive(bool _active) internal {\n        _mintableActive = _active;\n    }\n\n    modifier whenMintableActive() {\n        require(_mintableActive);\n        _;\n    }\n\n}\n\ncontract PauserRole {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () internal {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender));\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n\n\/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n *\/\ncontract Pausable is PauserRole {\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool private _pausableActive;\n    bool private _paused;\n\n    constructor () internal {\n        _paused = false;\n    }\n\n    \/**\n     * @return true if the contract is paused, false otherwise.\n     *\/\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    \/**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\/\n    modifier whenNotPaused() {\n        require(!_paused);\n        _;\n    }\n\n    \/**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\/\n    modifier whenPaused() {\n        require(_paused);\n        _;\n    }\n\n    \/**\n     * @dev called by the owner to pause, triggers stopped state\n     *\/\n    function pause() public onlyPauser whenNotPaused whenPausableActive {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    \/**\n     * @dev called by the owner to unpause, returns to normal state\n     *\/\n    function unpause() public onlyPauser whenPaused whenPausableActive {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    \/**\n     * @dev Options to activate or deactivate Pausable ability\n     *\/\n\n    function _setPausableActive(bool _active) internal {\n        _pausableActive = _active;\n    }\n\n    modifier whenPausableActive() {\n        require(_pausableActive);\n        _;\n    }\n\n}\n\n\/**\n * @title Advanced ERC20 token\n *\n * @dev Implementation of the basic standard token plus mint and burn public functions.\n *\n * Version 2. This version delegates the minter and pauser renounce to parent-factory contract\n * that allows ICOs to be minter for token selling\n *\n *\/\ncontract ERC20Chocolate is ERC20Pistachio, ERC20Burnable, ERC20Mintable, Pausable {\n\n    \/\/ maximum capital, if defined > 0\n    uint256 private _cap;\n\n    constructor (\n        address initialAccount, string memory _tokenSymbol, string memory _tokenName, uint256 initialBalance, uint256 cap,\n        bool _burnableOption, bool _mintableOption, bool _pausableOption\n    ) public \n        ERC20Pistachio(initialAccount, _tokenSymbol, _tokenName, initialBalance) {\n\n        \/\/ we must add customer account as the first minter\n        addMinter(initialAccount);\n\n        \/\/ add customer as pauser\n        addPauser(initialAccount);\n\n        if (cap > 0) {\n            _cap = cap; \/\/ maximum capitalization limited\n        } else {\n            _cap = 0; \/\/ unlimited capitalization\n        }\n\n        \/\/ activate or deactivate options\n        _setBurnableActive(_burnableOption);\n        _setMintableActive(_mintableOption);\n        _setPausableActive(_pausableOption);\n\n    }\n\n    \/**\n     * @return the cap for the token minting.\n     *\/\n    function cap() public view returns (uint256) {\n        return _cap;\n    }\n\n    \/**\n     * limit the mint to a maximum cap only if cap is defined\n     *\/\n    function _mint(address account, uint256 value) internal {\n        if (_cap > 0) {\n            require(totalSupply().add(value) <= _cap);\n        }\n        super._mint(account, value);\n    }\n\n    \/**\n     * Pausable options\n     *\/\n    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from,address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n        return super.approve(spender, value);\n    }\n\n    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {\n        return super.increaseAllowance(spender, addedValue);\n    }\n\n    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {\n        return super.decreaseAllowance(spender, subtractedValue);\n    }\n\n}",
                "tokenContractName":"ERC20Chocolate",
                "version": "2.0",
                "tokenCompilerVersion":"v0.5.7+commit.6da8b019"
            },
            "3.0": {
                "abi_factory":[{"inputs":[{"internalType":"contract ERC20Chocolate","name":"_token","type":"address"},{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"},{"internalType":"uint256","name":"_claimRatio","type":"uint256"},{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"inputs":[],"name":"buyCoffee","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"},{"internalType":"address","name":"from_address","type":"address"}],"name":"buyTea","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"canBuyTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_cap","type":"uint256"},{"internalType":"bool","name":"_isBurnable","type":"bool"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint8","name":"_decimals","type":"uint8"},{"internalType":"uint256","name":"_supply","type":"uint256"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_cap","type":"uint256"},{"internalType":"bool","name":"_isBurnable","type":"bool"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint8","name":"_decimals","type":"uint8"},{"internalType":"uint256","name":"_supply","type":"uint256"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"enableTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getPriceInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"master","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"contract ERC20Chocolate","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_claimRatio","type":"uint256"}],"name":"updateClaimRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_enabled","type":"bool"}],"name":"updateEnabled","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"}],"name":"updateRewardsRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract ERC20Chocolate","name":"_token","type":"address"}],"name":"updateToken","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source":"\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  ERC-20 Advanced Token\n    |\n    |----------------------------\n    |\n    |  Flavors\n    |\n    |  >  Chocolate 3.0: Advanced ERC-20 Token\n    |\n    |                    > Burnable\n    |                    > Pausable\n    |                    > Mintable\n    |                    > Ownable\n    |\n\n*\/\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n *\/\ninterface IERC20 {\n    \/**\n     * @dev Returns the amount of tokens in existence.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns the amount of tokens owned by `account`.\n     *\/\n    function balanceOf(address account) external view returns (uint256);\n\n    \/**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     *\/\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    \/**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \/**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     *\/\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n *\/\ninterface IERC20Metadata is IERC20 {\n    \/**\n     * @dev Returns the name of the token.\n     *\/\n    function name() external view returns (string memory);\n\n    \/**\n     * @dev Returns the symbol of the token.\n     *\/\n    function symbol() external view returns (string memory);\n\n    \/**\n     * @dev Returns the decimals places of the token.\n     *\/\n    function decimals() external view returns (uint8);\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https:\/\/forum.zeppelin.solutions\/t\/how-to-implement-erc20-supply-mechanisms\/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n *\/\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    \/**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     *\/\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    \/**\n     * @dev Returns the name of the token.\n     *\/\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     *\/\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 \/ 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     *\/\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    \/**\n     * @dev See {IERC20-totalSupply}.\n     *\/\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    \/**\n     * @dev See {IERC20-balanceOf}.\n     *\/\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    \/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     *\/\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    \/**\n     * @dev See {IERC20-allowance}.\n     *\/\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    \/**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     *\/\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    \/**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     *\/\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    \/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     *\/\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    \/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     *\/\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    \/**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     *\/\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    \/** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    \/**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     *\/\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\/\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    \/**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    \/**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n *\/\nabstract contract ERC20Burnable is Context, ERC20 {\n    \/**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     *\/\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    \/**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     *\/\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n\n\/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n *\/\nabstract contract Pausable is Context {\n    \/**\n     * @dev Emitted when the pause is triggered by `account`.\n     *\/\n    event Paused(address account);\n\n    \/**\n     * @dev Emitted when the pause is lifted by `account`.\n     *\/\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    \/**\n     * @dev Initializes the contract in unpaused state.\n     *\/\n    constructor() {\n        _paused = false;\n    }\n\n    \/**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     *\/\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    \/**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     *\/\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    \/**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     *\/\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    \/**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     *\/\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    \/**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     *\/\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n\/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\/\nabstract contract ERC20Pausable is ERC20, Pausable {\n    \/**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     *\/\n    function toString(uint256 value) internal pure returns (string memory) {\n        \/\/ Inspired by OraclizeAPI's implementation - MIT licence\n        \/\/ https:\/\/github.com\/oraclize\/ethereum-api\/blob\/b42146b063c7d6ee1358846c198246239e9360e8\/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp \/= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value \/= 10;\n        }\n        return string(buffer);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     *\/\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     *\/\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\ncontract ERC20Chocolate is ERC20, ERC20Burnable, Pausable, AccessControl {\n\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    uint8 private immutable _decimals;\n    uint256 private _cap;\n    bool private immutable _isBurnable;\n\n    constructor(address owner_, string memory name_, string memory symbol_, uint8 decimals_, uint256 supply_, uint256 cap_, bool isBurnable_) ERC20(name_, symbol_) {\n        require(decimals_ <= 18, \"ERC20Chocolate: decimals has to be lower or equal than 18\");\n        _decimals = decimals_;\n        _cap = cap_;\n        _isBurnable = isBurnable_;\n        _setupRole(DEFAULT_ADMIN_ROLE, owner_);\n        _setupRole(PAUSER_ROLE, owner_);\n        _setupRole(MINTER_ROLE, owner_);\n        _mint(owner_, supply_);\n    }\n\n    \/**\n     * @dev Returns the the token's decimal places.\n     *\/\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    \/**\n     * @dev Returns the cap on the token's total supply.\n     *\/\n    function cap() public view returns (uint256) {\n        return _cap;\n    }\n\n    \/**\n     * @dev allows the pauser to stop all token's activity\n     *\/\n    function pause() external onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n\n    \/**\n     * @dev allows the pauser to resume all token's activity\n     *\/\n    function unpause() external onlyRole(PAUSER_ROLE) {\n        _unpause();\n    }\n\n    \/**\n     * @dev stops transfers if the token is paused\n     *\/\n    function _beforeTokenTransfer(address from, address to, uint256 amount)\n        internal\n        whenNotPaused\n        override\n    {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    \/**\n     * @dev See {ERC20-_mint}.\n     *\/\n    function _mint(address account, uint256 amount) internal virtual override {\n        require(cap() == 0 || ERC20.totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\");\n        super._mint(account, amount);\n    }\n\n    \/**\n     * @dev Limit the minting ability to minter role\n     *\/\n    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n\n    \/**\n     * @dev allows to burn only if burn is enabled\n     *\/\n    function burn(uint256 amount) public virtual override {\n        require(_isBurnable, \"ERC20Chocolate: burn option is deactivated\");\n        super.burn(amount);\n    }\n\n    \/**\n     * @dev allows to burnFrom only if burn is enabled\n     *\/\n    function burnFrom(address account, uint256 amount) public virtual override {\n        require(_isBurnable, \"ERC20Chocolate: burn option is deactivated\");\n        super.burnFrom(account, amount);\n    }\n\n}",
                "tokenContractName":"ERC20Chocolate",
                "version": "3.0",
                "compilerVersion":"v0.8.2"
            },
            "4.0": {
                "abi_factory":[{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_cap","type":"uint256"},{"internalType":"bool","name":"_isBurnable","type":"bool"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint8","name":"_decimals","type":"uint8"},{"internalType":"uint256","name":"_supply","type":"uint256"},{"internalType":"address","name":"_affiliate","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_cap","type":"uint256"},{"internalType":"bool","name":"_isBurnable","type":"bool"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint8","name":"_decimals","type":"uint8"},{"internalType":"uint256","name":"_supply","type":"uint256"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source":"\/\/ SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n *\/\ninterface IERC20 {\n    \/**\n     * @dev Returns the amount of tokens in existence.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns the amount of tokens owned by `account`.\n     *\/\n    function balanceOf(address account) external view returns (uint256);\n\n    \/**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     *\/\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    \/**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \/**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     *\/\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n *\/\ninterface IERC20Metadata is IERC20 {\n    \/**\n     * @dev Returns the name of the token.\n     *\/\n    function name() external view returns (string memory);\n\n    \/**\n     * @dev Returns the symbol of the token.\n     *\/\n    function symbol() external view returns (string memory);\n\n    \/**\n     * @dev Returns the decimals places of the token.\n     *\/\n    function decimals() external view returns (uint8);\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https:\/\/forum.zeppelin.solutions\/t\/how-to-implement-erc20-supply-mechanisms\/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n *\/\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    \/**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     *\/\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    \/**\n     * @dev Returns the name of the token.\n     *\/\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     *\/\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 \/ 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     *\/\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    \/**\n     * @dev See {IERC20-totalSupply}.\n     *\/\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    \/**\n     * @dev See {IERC20-balanceOf}.\n     *\/\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    \/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     *\/\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    \/**\n     * @dev See {IERC20-allowance}.\n     *\/\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    \/**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     *\/\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    \/**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     *\/\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    \/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     *\/\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    \/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     *\/\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    \/**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     *\/\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    \/** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    \/**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     *\/\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\/\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    \/**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    \/**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n *\/\nabstract contract ERC20Burnable is Context, ERC20 {\n    \/**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     *\/\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    \/**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     *\/\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n\n\/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n *\/\nabstract contract Pausable is Context {\n    \/**\n     * @dev Emitted when the pause is triggered by `account`.\n     *\/\n    event Paused(address account);\n\n    \/**\n     * @dev Emitted when the pause is lifted by `account`.\n     *\/\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    \/**\n     * @dev Initializes the contract in unpaused state.\n     *\/\n    constructor() {\n        _paused = false;\n    }\n\n    \/**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     *\/\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    \/**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     *\/\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    \/**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     *\/\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    \/**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     *\/\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    \/**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     *\/\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     *\/\n    function toString(uint256 value) internal pure returns (string memory) {\n        \/\/ Inspired by OraclizeAPI's implementation - MIT licence\n        \/\/ https:\/\/github.com\/oraclize\/ethereum-api\/blob\/b42146b063c7d6ee1358846c198246239e9360e8\/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp \/= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value \/= 10;\n        }\n        return string(buffer);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     *\/\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     *\/\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\/**\n * Chocolate v.4\n * ERC-20 Advanced Token: with options to be mintable, pausable and \/ or burnable\n *\/\ncontract ERC20Chocolate is ERC20, ERC20Burnable, Pausable, AccessControl {\n\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    uint8 private immutable _decimals;\n    uint256 private _cap;\n    bool private immutable _isBurnable;\n\n    constructor(address owner_, string memory name_, string memory symbol_, uint8 decimals_, uint256 supply_, uint256 cap_, bool isBurnable_) ERC20(name_, symbol_) {\n        require(decimals_ <= 18, \"ERC20Chocolate: decimals has to be lower or equal than 18\");\n        _decimals = decimals_;\n        _cap = cap_;\n        _isBurnable = isBurnable_;\n        _setupRole(DEFAULT_ADMIN_ROLE, owner_);\n        _setupRole(PAUSER_ROLE, owner_);\n        _setupRole(MINTER_ROLE, owner_);\n        _mint(owner_, supply_);\n    }\n\n    \/**\n     * @dev Returns the the token's decimal places.\n     *\/\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    \/**\n     * @dev Returns the cap on the token's total supply.\n     *\/\n    function cap() public view returns (uint256) {\n        return _cap;\n    }\n\n    \/**\n     * @dev allows the pauser to stop all token's activity\n     *\/\n    function pause() external onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n\n    \/**\n     * @dev allows the pauser to resume all token's activity\n     *\/\n    function unpause() external onlyRole(PAUSER_ROLE) {\n        _unpause();\n    }\n\n    \/**\n     * @dev stops transfers if the token is paused\n     *\/\n    function _beforeTokenTransfer(address from, address to, uint256 amount)\n        internal\n        whenNotPaused\n        override\n    {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    \/**\n     * @dev See {ERC20-_mint}.\n     *\/\n    function _mint(address account, uint256 amount) internal virtual override {\n        require(cap() == 0 || ERC20.totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\");\n        super._mint(account, amount);\n    }\n\n    \/**\n     * @dev Limit the minting ability to minter role\n     *\/\n    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n\n    \/**\n     * @dev allows to burn only if burn is enabled\n     *\/\n    function burn(uint256 amount) public virtual override {\n        require(_isBurnable, \"ERC20Chocolate: burn option is deactivated\");\n        super.burn(amount);\n    }\n\n    \/**\n     * @dev allows to burnFrom only if burn is enabled\n     *\/\n    function burnFrom(address account, uint256 amount) public virtual override {\n        require(_isBurnable, \"ERC20Chocolate: burn option is deactivated\");\n        super.burnFrom(account, amount);\n    }\n\n}",
                "tokenContractName":"ERC20Chocolate",
                "version": "4.0",
                "compilerVersion":"v0.8.2"
            }
        }
    },
    "mango":{  
        "data": {
            "2.0": {
                "abi_factory":[ { "constant": false, "inputs": [], "name": "buyCoffee", "outputs": [ { "name": "", "type": "bool" } ], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": false, "inputs": [ { "name": "in_wei", "type": "uint256" }, { "name": "from_address", "type": "address" } ], "name": "buyTea", "outputs": [ { "name": "", "type": "bool" } ], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "minimum", "type": "uint256" }, { "name": "factor", "type": "uint8" } ], "name": "createCampaignMango", "outputs": [ { "name": "", "type": "address" } ], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": false, "inputs": [ { "name": "minimum", "type": "uint256" }, { "name": "factor", "type": "uint8" } ], "name": "createCampaignMangoWithWPST", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_claimRatio", "type": "uint256" } ], "name": "updateClaimRatio", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_masterFee", "type": "uint256" } ], "name": "updateFee", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_masterAddress", "type": "address" } ], "name": "updateMasterAddress", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_rewardsRatio", "type": "uint256" } ], "name": "updateRewardsRatio", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_token", "type": "address" } ], "name": "updateToken", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "name": "_token", "type": "address" }, { "name": "_rewardsRatio", "type": "uint256" }, { "name": "_claimRatio", "type": "uint256" }, { "name": "_masterFee", "type": "uint256" }, { "name": "_masterAddress", "type": "address" } ], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [ { "indexed": false, "name": "ANewContractAddress", "type": "address" } ], "name": "newAddress", "type": "event" }, { "constant": true, "inputs": [ { "name": "account", "type": "address" }, { "name": "in_wei", "type": "uint256" } ], "name": "canBuyTea", "outputs": [ { "name": "", "type": "bool" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [ { "name": "_manager", "type": "address" } ], "name": "getDeployedContractsByManager", "outputs": [ { "name": "", "type": "address[]" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "getDeployedContractsBySender", "outputs": [ { "name": "", "type": "address[]" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "getManagers", "outputs": [ { "name": "", "type": "address[]" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "getMasterAddress", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [ { "name": "in_wei", "type": "uint256" } ], "name": "getPriceInToken", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [ { "name": "in_wei", "type": "uint256" } ], "name": "getRewards", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "masterAddress", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "masterFee", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "token", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "view", "type": "function" } ],
                "source":"\/**\n\nWPSmartContracts.com\n\nBlockhain Made Easy\n\nhttps:\/\/wpsmartcontracts.com\/\n\n*\/\n\npragma solidity ^0.5.7;\n\ncontract IRC20Vanilla {\n    \/* This is a slight change to the ERC20 base standard.\n    function totalSupply() constant returns (uint256 supply);\n    is replaced with:\n    uint256 public totalSupply;\n    This automatically creates a getter function for the totalSupply.\n    This is moved to the base contract since public getter functions are not\n    currently recognised as an implementation of the matching abstract\n    function by the compiler.\n    *\/\n    \/\/\/ total amount of tokens\n    uint256 public totalSupply;\n\n    \/\/\/ @param _owner The address from which the balance will be retrieved\n    \/\/\/ @return The balance\n    function balanceOf(address _owner) public view returns (uint256 balance);\n\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\n    \/\/\/ @param _to The address of the recipient\n    \/\/\/ @param _value The amount of token to be transferred\n    \/\/\/ @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    \/\/\/ @param _from The address of the sender\n    \/\/\/ @param _to The address of the recipient\n    \/\/\/ @param _value The amount of token to be transferred\n    \/\/\/ @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\n    \/\/\/ @param _value The amount of tokens to be approved for transfer\n    \/\/\/ @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    \/\/\/ @param _owner The address of the account owning tokens\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\n    \/\/\/ @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n\n    \/\/ solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract ERC20Vanilla is IRC20Vanilla {\n\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    \/*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets\/interfaces might not even bother to look at this information.\n    *\/\n    string public name;                   \/\/fancy name: eg Simon Bucks\n    uint8 public decimals;                \/\/How many decimals to show.\n    string public symbol;                 \/\/An identifier: eg SBX\n\n    constructor(address _manager, uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol\n    ) public {\n        balances[_manager] = _initialAmount;               \/\/ Give the creator all initial tokens\n        totalSupply = _initialAmount;                        \/\/ Update total supply\n        name = _tokenName;                                   \/\/ Set the name for display purposes\n        decimals = _decimalUnits;                            \/\/ Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               \/\/ Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n}\n\n\/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n *\/\nlibrary SafeMath {\n    \n    int256 constant private INT256_MIN = -2**255;\n\n    \/**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    *\/\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \/\/ Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        \/\/ benefit is lost if 'b' is also tested.\n        \/\/ See: https:\/\/github.com\/OpenZeppelin\/openzeppelin-solidity\/pull\/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c \/ a == b);\n\n        return c;\n    }\n\n    \/**\n    * @dev Multiplies two signed integers, reverts on overflow.\n    *\/\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        \/\/ Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        \/\/ benefit is lost if 'b' is also tested.\n        \/\/ See: https:\/\/github.com\/OpenZeppelin\/openzeppelin-solidity\/pull\/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == INT256_MIN)); \/\/ This is the only case of overflow not detected by the check below\n\n        int256 c = a * b;\n        require(c \/ a == b);\n\n        return c;\n    }\n\n    \/**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    *\/\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \/\/ Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a \/ b;\n        \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    \/**\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n    *\/\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0); \/\/ Solidity only automatically asserts when dividing by 0\n        require(!(b == -1 && a == INT256_MIN)); \/\/ This is the only case of overflow\n\n        int256 c = a \/ b;\n\n        return c;\n    }\n\n    \/**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    *\/\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \/**\n    * @dev Subtracts two signed integers, reverts on overflow.\n    *\/\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\n\n        return c;\n    }\n\n    \/**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    *\/\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    \/**\n    * @dev Adds two signed integers, reverts on overflow.\n    *\/\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n\n        return c;\n    }\n\n    \/**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    *\/\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n\/**\n *\n * WPSmartContracts \/ Campaign Contract\n *\n * Contribution campaigns including the ability to approve the transfer of funds per request\n *\n *\/\n\ncontract CampaignMango {\n\n    using SafeMath for uint256;\n    \n    \/\/ Request definition\n    struct Request {\n        string description;\n        uint256 value;\n        address payable recipient;\n        bool complete;\n        uint256 approvalCount;\n        mapping(address => bool) approvals;\n    }\n    \n    Request[] public requests; \/\/ requests instance\n    address public manager; \/\/ the owner\n    uint256 minimumContribution; \/\/ the... minimum contribution\n\n    \/*\n        a factor to calculate minimum number of approvers by 100\/factor\n        the factor values are 2 and 10, factors that makes sense:\n            2: meaning that the number or approvers required will be 50%\n            3: 33.3%\n            4: 25%\n            5: 20%\n            10: 10%\n    *\/\n    uint8 approversFactor;\n    \n    mapping(address => bool) public approvers;\n    uint256 public approversCount;\n\n    \/\/ function to add validation of the manager to run any function\n    modifier restricted() {\n        require(msg.sender == manager);\n        _;\n    }\n\n    \/\/ Constructor function to create a Campaign\n    constructor(address creator, uint256 minimum, uint8 factor) public {\n        \/\/ validate factor number betweeb 2 and 10\n        require(factor >= 2);\n        require(factor <= 10);\n        manager = creator;\n        approversFactor = factor;\n        minimumContribution = minimum;\n    }\n    \n    \/\/ allows a contributions\n    function contribute() public payable {\n        \/\/ validate minimun contribution\n        require(msg.value >= minimumContribution);\n\n        \/\/ increment the number of approvers\n        if (!approvers[msg.sender]) {\n            approversCount++;\n        }\n\n        approvers[msg.sender] = true; \/\/ this maps this address with true\n\n    }\n\n    \/\/ create a request...\n    function createRequest(string memory description, uint256 value, address payable recipient) public restricted {\n\n        \/\/ create the struct, specifying memory as a holder\n        Request memory newRequest = Request({\n           description: description,\n           value: value,\n           recipient: recipient,\n           complete: false,\n           approvalCount: 0\n        });\n\n        requests.push(newRequest);\n\n    }\n\n    \/\/ contributors has the right to approve request\n    function approveRequest(uint256 index) public {\n        \n        \/\/ this is to store in a local variable \"request\" the request[index] and avoid using it all the time\n        Request storage request = requests[index];\n        \n        \/\/ if will require that the sender address is in the mapping of approvers\n        require(approvers[msg.sender]);\n        \n        \/\/ it will require the contributor not to vote twice for the same request\n        require(!request.approvals[msg.sender]);\n        \n        \/\/ add the voter to the approvals map\n        request.approvals[msg.sender] = true;\n        \n        \/\/ increment the number of YES votes for the request\n        request.approvalCount++;\n        \n    }\n\n    \/\/ check if the sender already approved the request index\n    function approved(uint256 index) public view returns (bool) {\n\n        \/\/ if the msg.sender is an approver and also the msg.sender already approved the request “index” returns true\n        if (approvers[msg.sender] && requests[index].approvals[msg.sender]) {\n            return true;\n        } else {\n            return false;\n        }\n\n    }\n    \n    \/\/ send the money to the vendor if there are enough votes\n    \/\/ only the creator is allowed to run this function\n    function finalizeRequest(uint256 index) public restricted {\n        \n        \/\/ this is to store in a local variable \"request\" the request[index] and avoid using it all the time\n        Request storage request = requests[index];\n\n        \/\/ transfer the money if it has more than X% of approvals\n        require(request.approvalCount >= approversCount.div(approversFactor));\n        \n        \/\/ we will require that the request in process is not completed yet\n        require(!request.complete);\n        \n        \/\/ mark the request as completed\n        request.complete = true;\n        \n        \/\/ transfer the money requested (value) from the contract to the vendor that created the request\n        request.recipient.transfer(request.value);\n        \n    }\n\n    \/\/ helper function to show basic info of a contract in the interface\n    function getSummary() public view returns (\n      uint256, uint256, uint256, uint256, address\n      ) {\n        return (\n          minimumContribution,\n          address(this).balance,\n          requests.length,\n          approversCount,\n          manager\n        );\n    }\n\n    function getRequestsCount() public view returns (uint256) {\n        return requests.length;\n    }\n\n}",
                "contractName":"CampaignMango",
                "version": "2.0",
                "compilerVersion":"v0.5.7+commit.6da8b019"
            }
        }
    },
    "matcha":{
        "data": {
            "1.1": {
                "abi_factory":[{"inputs":[{"internalType":"contract ERC20","name":"_token","type":"address"},{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"},{"internalType":"uint256","name":"_claimRatio","type":"uint256"},{"internalType":"uint256[]","name":"_masterFee","type":"uint256[]"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"constant":false,"inputs":[{"internalType":"uint8","name":"index","type":"uint8"}],"name":"buyCoffee","outputs":[],"payable":true,"stateMutability":"payable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"},{"internalType":"address","name":"from_address","type":"address"}],"name":"buyTea","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"canBuyTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getMasterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getPriceInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"uint8","name":"","type":"uint8"}],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"token","outputs":[{"internalType":"contract ERC20","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"_claimRatio","type":"uint256"}],"name":"updateClaimRatio","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"uint8","name":"index","type":"uint8"}],"name":"updateFee","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"}],"name":"updateRewardsRatio","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"contract ERC20","name":"_token","type":"address"}],"name":"updateToken","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint8","name":"_type","type":"uint8"},{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContract","outputs":[],"payable":true,"stateMutability":"payable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint8","name":"_type","type":"uint8"},{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContractWithWPST","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}],
                "source":"\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  ERC-721 NFT Marketplace\n    |\n    |----------------------------\n    |\n    |  Flavors\n    |\n    |  >  Matcha: Fully featured ERC-721 Token, with Buy, \n    |     Sell and Auction NFT Marketplace\n    |\n\n\n*\/\n\npragma solidity ^0.5.7;\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Required interface of an ERC721 compliant contract.\n *\/\ncontract IERC721 is IERC165 {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    \/**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     *\/\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    \/**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     *\/\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    \/**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApproveForAll}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public;\n\n    \/**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApproveForAll}.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public;\n\n    function approve(address to, uint256 tokenId) public;\n\n    function getApproved(uint256 tokenId)\n        public\n        view\n        returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public;\n}\n\n\/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n *\/\ncontract IERC721Receiver {\n    \/**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransfer}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     *\/\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes memory data\n    ) public returns (bytes4);\n}\n\n\/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\/\nlibrary SafeMath {\n    \/**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     *\/\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \/**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\/\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \/**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     *\/\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \/\/ Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        \/\/ benefit is lost if 'b' is also tested.\n        \/\/ See: https:\/\/github.com\/OpenZeppelin\/openzeppelin-solidity\/pull\/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c \/ a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \/**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `\/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\/\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \/\/ Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a \/ b;\n        \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    \/**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\/\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies in extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        \/\/ According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        \/\/ and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        \/\/ for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash =\n            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        \/\/ solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    \/**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\/\n    function toPayable(address account)\n        internal\n        pure\n        returns (address payable)\n    {\n        return address(uint160(account));\n    }\n}\n\n\/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n *\/\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        \/\/ This variable should never be directly accessed by users of the library: interactions must be restricted to\n        \/\/ the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        \/\/ this feature: see https:\/\/github.com\/ethereum\/solidity\/issues\/4637\n        uint256 _value; \/\/ default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n *\/\ncontract ERC165 is IERC165 {\n    \/*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     *\/\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    \/**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     *\/\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor() internal {\n        \/\/ Derived contracts need only register support for their own interfaces,\n        \/\/ we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId)\n        external\n        view\n        returns (bool)\n    {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    \/**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     *\/\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n\/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ncontract ERC721 is ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    \/\/ Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    \/\/ which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    \/\/ Mapping from token ID to owner\n    mapping(uint256 => address) private _tokenOwner;\n\n    \/\/ Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    \/\/ Mapping from owner to number of owned token\n    mapping(address => Counters.Counter) private _ownedTokensCount;\n\n    \/\/ Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     *\/\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor() public {\n        \/\/ register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    \/**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     *\/\n    function balanceOf(address owner) public view returns (uint256) {\n        require(\n            owner != address(0),\n            \"ERC721: balance query for the zero address\"\n        );\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    \/**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     *\/\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(\n            owner != address(0),\n            \"ERC721: owner query for nonexistent token\"\n        );\n\n        return owner;\n    }\n\n    \/**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     *\/\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    \/**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     *\/\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(\n            _exists(tokenId),\n            \"ERC721: approved query for nonexistent token\"\n        );\n\n        return _tokenApprovals[tokenId];\n    }\n\n    \/**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     *\/\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != msg.sender, \"ERC721: approve to caller\");\n\n        _operatorApprovals[msg.sender][to] = approved;\n        emit ApprovalForAll(msg.sender, to, approved);\n    }\n\n    \/**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     *\/\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    \/**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        \/\/solhint-disable-next-line max-line-length\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    \/**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public {\n        transferFrom(from, to, tokenId);\n        require(\n            _checkOnERC721Received(from, to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    \/**\n     * @dev Returns whether the specified token exists.\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     *\/\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    \/**\n     * @dev Returns whether the given spender can transfer a given token ID.\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     *\/\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\n        internal\n        view\n        returns (bool)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721: operator query for nonexistent token\"\n        );\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    \/**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     *\/\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    \/**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     *\/\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        require(\n            ownerOf(tokenId) == from,\n            \"ERC721: transfer of token that is not own\"\n        );\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * This function is deprecated.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     *\/\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval =\n            IERC721Receiver(to).onERC721Received(\n                msg.sender,\n                from,\n                tokenId,\n                _data\n            );\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    \/**\n     * @dev Private function to clear current approval of a given token ID.\n     * @param tokenId uint256 ID of the token to be transferred\n     *\/\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n\n\/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n *\/\nlibrary Roles {\n    struct Role {\n        mapping(address => bool) bearer;\n    }\n\n    \/**\n     * @dev Give an account access to this role.\n     *\/\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    \/**\n     * @dev Remove an account's access to this role.\n     *\/\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    \/**\n     * @dev Check if an account has this role.\n     * @return bool\n     *\/\n    function has(Role storage role, address account)\n        internal\n        view\n        returns (bool)\n    {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor() internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(\n            isMinter(msg.sender),\n            \"MinterRole: caller does not have the Minter role\"\n        );\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\n\/**\n * @title ERC721Mintable\n * @dev ERC721 minting logic.\n *\/\ncontract ERC721Mintable is ERC721, MinterRole {\n\n    bool public anyoneCanMint;\n    \n    \/**\n     * @dev Options to activate or deactivate mint ability\n     *\/\n\n    function _setMintableOption(bool _anyoneCanMint) internal {\n        anyoneCanMint = _anyoneCanMint;\n    }\n\n    \/**\n     * @dev Function to mint tokens.\n     * @param to The address that will receive the minted tokens.\n     * @param tokenId The token id to mint.\n     * @return A boolean that indicates if the operation was successful.\n     *\/\n    function mint(address to, uint256 tokenId)\n        public\n        onlyMinter\n        returns (bool)\n    {\n        _mint(to, tokenId);\n        return true;\n    }\n\n    function canIMint() public view returns (bool) {\n        return anyoneCanMint || isMinter(msg.sender);\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        string memory mensaje;\n        require(\n            canIMint(),\n            \"MinterRole: caller does not have the Minter role\"\n        );\n        _;\n    }\n\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ncontract IERC721Enumerable is IERC721 {\n    function totalSupply() public view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) public view returns (uint256);\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\n    \/\/ Mapping from owner to list of owned token IDs\n    mapping(address => uint256[]) private _ownedTokens;\n\n    \/\/ Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    \/\/ Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    \/\/ Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    \/*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     *\/\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    \/**\n     * @dev Constructor function.\n     *\/\n    constructor () public {\n        \/\/ register the supported interface to conform to ERC721Enumerable via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    \/**\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\n     * @param owner address owning the tokens list to be accessed\n     * @param index uint256 representing the index to be accessed of the requested tokens list\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        require(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    \/**\n     * @dev Gets the total amount of tokens stored by the contract.\n     * @return uint256 representing the total amount of tokens\n     *\/\n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    \/**\n     * @dev Gets the token ID at a given index of all the tokens in this contract\n     * Reverts if the index is greater or equal to the total number of tokens.\n     * @param index uint256 representing the index to be accessed of the tokens list\n     * @return uint256 token ID at the given index of the tokens list\n     *\/\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    \/**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     *\/\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        super._transferFrom(from, to, tokenId);\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    \/**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to address the beneficiary that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     *\/\n    function _mint(address to, uint256 tokenId) internal {\n        super._mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    \/**\n     * @dev Gets the list of token IDs of the requested owner.\n     * @param owner address owning the tokens\n     * @return uint256[] List of token IDs owned by the requested address\n     *\/\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n        return _ownedTokens[owner];\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     *\/\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     *\/\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     *\/\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        \/\/ To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n        }\n\n        \/\/ This also deletes the contents at the last position of the array\n        _ownedTokens[from].length--;\n\n        \/\/ Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n        \/\/ lastTokenId, or just over the end of the array if the token was the last one).\n    }\n\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    \/\/ Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    \/*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     *\/\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    \/**\n     * @dev Constructor function\n     *\/\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        \/\/ register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    \/**\n     * @dev Gets the token name.\n     * @return string representing the token name\n     *\/\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev Gets the token symbol.\n     * @return string representing the token symbol\n     *\/\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev Returns an URI for a given token ID.\n     * Throws if the token ID does not exist. May return an empty string.\n     * @param tokenId uint256 ID of the token to query\n     *\/\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        return _tokenURIs[tokenId];\n    }\n\n    \/**\n     * @dev Internal function to set the token URI for a given token.\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to set its URI\n     * @param uri string URI to assign\n     *\/\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = uri;\n    }\n\n}\n\n\/**\n * @title ERC721MetadataMintable\n * @dev ERC721 minting logic with metadata.\n *\/\ncontract ERC721MetadataMintable is ERC721, ERC721Metadata, MinterRole {\n    \/**\n     * @dev Function to mint tokens.\n     * @param to The address that will receive the minted tokens.\n     * @param tokenId The token id to mint.\n     * @param tokenURI The token URI of the minted token.\n     * @return A boolean that indicates if the operation was successful.\n     *\/\n    function mintWithTokenURI(address to, uint256 tokenId, string memory tokenURI) public onlyMinter returns (bool) {\n        _mint(to, tokenId);\n        _setTokenURI(tokenId, tokenURI);\n        return true;\n    }\n}\n\n\/**\n * @title ERC721\n * Full ERC-721 Token with automint function\n *\/\n\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata, ERC721Mintable, ERC721MetadataMintable {\n\n    uint256 autoTokenId;\n    constructor (string memory name, string memory symbol, bool _anyoneCanMint) public \n        ERC721Mintable() \n        ERC721Metadata(name, symbol) {\n        \/\/ solhint-disable-previous-line no-empty-blocks\n\n        _setMintableOption(_anyoneCanMint);\n\n    }\n\n    function exists(uint256 tokenId) public view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function tokensOfOwner(address owner) public view returns (uint256[] memory) {\n        return _tokensOfOwner(owner);\n    }\n\n    function setTokenURI(uint256 tokenId, string memory uri) public {\n        _setTokenURI(tokenId, uri);\n    }\n\n    \/**\n     * @dev Function to mint tokens with automatic ID\n     * @param to The address that will receive the minted tokens.\n     * @return A boolean that indicates if the operation was successful.\n     *\/\n    function autoMint(string memory tokenURI, address to) public onlyMinter returns (bool) {\n        do {\n            autoTokenId++;\n        } while(_exists(autoTokenId));\n        _mint(to, autoTokenId);\n        _setTokenURI(autoTokenId, tokenURI);\n        return true;\n    }\n\n    \/**\n     * @dev Function to transfer tokens\n     * @param to The address that will receive the minted tokens.\n     * @param tokenId the token ID\n     *\/\n    function transfer(\n        address to,\n        uint256 tokenId\n    ) public {\n        _transferFrom(msg.sender, to, tokenId);\n    }\n\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be aplied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\/\ncontract ReentrancyGuard {\n    \/\/ counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        \/\/ The counter starts at one to prevent changing it from zero to a non-zero\n        \/\/ value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\n\/**\n * @title ERC721Matcha\n * ERC-721 Marketplace\n *\/\n\ncontract ERC721Matcha is ERC721Full, ReentrancyGuard {\n\n    using SafeMath for uint256;\n\n    using Address for address payable;\n\n    \/\/ admin address, the owner of the marketplace\n    address payable admin;\n\n    address public contract_owner;\n\n    \/\/ commission rate is a value from 0 to 100\n    uint256 commissionRate;\n\n    \/\/ last price sold or auctioned\n    mapping(uint256 => uint256) public soldFor;\n    \n    \/\/ Mapping from token ID to sell price in Ether or to bid price, depending if it is an auction or not\n    mapping(uint256 => uint256) public sellBidPrice;\n\n    \/\/ Mapping payment address for tokenId \n    mapping(uint256 => address payable) private _wallets;\n\n    event Sale(uint256 indexed tokenId, address indexed from, address indexed to, uint256 value);\n    event Commission(uint256 indexed tokenId, address indexed to, uint256 value, uint256 rate, uint256 total);\n\n    \/*\n\n    index   _isAuction  _sellBidPrice   Meaning\n    0       true        0               Item 0 is on auction and no bids so far\n    1       true        10              Item 1 is on auction and the last bid is for 10 Ethers\n    2       false       0               Item 2 is not on auction nor for sell\n    3       false       10              Item 3 is on sale for 10 Ethers\n\n    *\/\n\n    \/\/ Auction data\n    struct Auction {\n\n        \/\/ Parameters of the auction. Times are either\n        \/\/ absolute unix timestamps (seconds since 1970-01-01)\n        \/\/ or time periods in seconds.\n        address payable beneficiary;\n        uint auctionEnd;\n\n        \/\/ Current state of the auction.\n        address payable highestBidder;\n        uint highestBid;\n\n        \/\/ Set to true at the end, disallows any change\n        bool open;\n\n        \/\/ minimum reserve price in wei\n        uint256 reserve;\n\n    }\n\n    \/\/ mapping auctions for each tokenId\n    mapping(uint256 => Auction) public auctions;\n\n    \/\/ Events that will be fired on changes.\n    event Refund(address bidder, uint amount);\n    event HighestBidIncreased(address indexed bidder, uint amount, uint256 tokenId);\n    event AuctionEnded(address winner, uint amount);\n\n    event LimitSell(address indexed from, address indexed to, uint256 amount);\n    event LimitBuy(address indexed from, address indexed to, uint256 amount);\n    event MarketSell(address indexed from, address indexed to, uint256 amount);\n    event MarketBuy(address indexed from, address indexed to, uint256 amount);\n\n\n    constructor(address _owner, address payable _admin, uint256 _commissionRate, string memory name, string memory symbol, bool _anyoneCanMint) public \n        ERC721Full(name, symbol, _anyoneCanMint) {\n        admin = _admin;\n        contract_owner = _owner;\n        require(_commissionRate<=100, \"ERC721Matcha: Commission rate has to be between 0 and 100\");\n        commissionRate = _commissionRate;\n    }\n\n    function canSell(uint256 tokenId) public view returns (bool) {\n        return (ownerOf(tokenId)==msg.sender && !auctions[tokenId].open);\n    }\n\n    \/\/ Sell option for a fixed price\n    function sell(uint256 tokenId, uint256 price, address payable wallet) public {\n\n        \/\/ onlyOwner\n        require(ownerOf(tokenId)==msg.sender, \"ERC721Matcha: Only owner can sell this item\");\n\n        \/\/ cannot set a price if auction is activated\n        require(!auctions[tokenId].open, \"ERC721Matcha: Cannot sell an item which has an active auction\");\n\n        \/\/ set sell price for index\n        sellBidPrice[tokenId] = price;\n\n        \/\/ If price is zero, means not for sale\n        if (price>0) {\n\n            \/\/ approve the Index to the current contract\n            approve(address(this), tokenId);\n            \n            \/\/ set wallet payment\n            _wallets[tokenId] = wallet;\n            \n        }\n\n    }\n\n    \/\/ simple function to return the price of a tokenId\n    \/\/ returns: sell price, bid price, sold price, only one can be non zero\n    function getPrice(uint256 tokenId) public view returns (uint256, uint256, uint256) {\n        if (sellBidPrice[tokenId]>0) return (sellBidPrice[tokenId], 0, 0);\n        if (auctions[tokenId].highestBid>0) return (0, auctions[tokenId].highestBid, 0);\n        return (0, 0, soldFor[tokenId]);\n    }\n\n    function canBuy(uint256 tokenId) public view returns (uint256) {\n        if (!auctions[tokenId].open && sellBidPrice[tokenId]>0 && sellBidPrice[tokenId]>0 && getApproved(tokenId) == address(this)) {\n            return sellBidPrice[tokenId];\n        } else {\n            return 0;\n        }\n    }\n\n    \/\/ Buy option\n    function buy(uint256 tokenId) public payable nonReentrant {\n\n        \/\/ is on sale\n        require(!auctions[tokenId].open && sellBidPrice[tokenId]>0, \"ERC721Matcha: The collectible is not for sale\");\n\n        \/\/ transfer funds\n        require(msg.value >= sellBidPrice[tokenId], \"ERC721Matcha: Not enough funds\");\n\n        \/\/ transfer ownership\n        address owner = ownerOf(tokenId);\n\n        require(msg.sender!=owner, \"ERC721Matcha: The seller cannot buy his own collectible\");\n\n        \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n        callOptionalReturn(this, abi.encodeWithSelector(this.transferFrom.selector, owner, msg.sender, tokenId));\n\n        \/\/ calculate amounts\n        uint256 amount4admin = msg.value.mul(commissionRate).div(100);\n        uint256 amount4owner = msg.value.sub(amount4admin);\n\n        \/\/ to owner\n        (bool success, ) = _wallets[tokenId].call.value(amount4owner)(\"\");\n        require(success, \"Transfer failed.\");\n\n        \/\/ to admin\n        (bool success2, ) = admin.call.value(amount4admin)(\"\");\n        require(success2, \"Transfer failed.\");\n\n        \/\/ close the sell\n        sellBidPrice[tokenId] = 0;\n        _wallets[tokenId] = address(0);\n\n        soldFor[tokenId] = msg.value;\n\n        emit Sale(tokenId, owner, msg.sender, msg.value);\n        emit Commission(tokenId, owner, msg.value, commissionRate, amount4admin);\n\n    }\n\n    function canAuction(uint256 tokenId) public view returns (bool) {\n        return (ownerOf(tokenId)==msg.sender && !auctions[tokenId].open && sellBidPrice[tokenId]==0);\n    }\n\n    \/\/ Instantiate an auction contract for a tokenId\n    function createAuction(uint256 tokenId, uint _closingTime, address payable _beneficiary, uint256 _reservePrice) public {\n\n        require(sellBidPrice[tokenId]==0, \"ERC721Matcha: The selected NFT is open for sale, cannot be auctioned\");\n        require(!auctions[tokenId].open, \"ERC721Matcha: The selected NFT already has an auction\");\n        require(ownerOf(tokenId)==msg.sender, \"ERC721Matcha: Only owner can auction this item\");\n\n        auctions[tokenId].beneficiary = _beneficiary;\n        auctions[tokenId].auctionEnd = _closingTime;\n        auctions[tokenId].reserve = _reservePrice;\n        auctions[tokenId].open = true;\n\n        \/\/ approve the Index to the current contract\n        approve(address(this), tokenId);\n\n    }\n\n    function canBid(uint256 tokenId) public view returns (bool) {\n        if (!msg.sender.isContract() &&\n            auctions[tokenId].open &&\n            now <= auctions[tokenId].auctionEnd &&\n            msg.sender != ownerOf(tokenId) &&\n            getApproved(tokenId) == address(this)\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/\/ Bid on the auction with the value sent\n    \/\/\/ together with this transaction.\n    \/\/\/ The value will only be refunded if the\n    \/\/\/ auction is not won.\n    function bid(uint256 tokenId) public payable nonReentrant {\n        \/\/ No arguments are necessary, all\n        \/\/ information is already part of\n        \/\/ the transaction. The keyword payable\n        \/\/ is required for the function to\n        \/\/ be able to receive Ether.\n\n        \/\/ Contracts cannot bid, because they can block the auction with a reentrant attack\n        require(!msg.sender.isContract(), \"No script kiddies\");\n\n        \/\/ auction has to be opened\n        require(auctions[tokenId].open, \"No opened auction found\");\n\n        \/\/ approve was lost\n        require(getApproved(tokenId) == address(this), \"Cannot complete the auction\");\n\n        \/\/ Revert the call if the bidding\n        \/\/ period is over.\n        require(\n            now <= auctions[tokenId].auctionEnd,\n            \"Auction already ended.\"\n        );\n\n        \/\/ If the bid is not higher, send the\n        \/\/ money back.\n        require(\n            msg.value > auctions[tokenId].highestBid,\n            \"There already is a higher bid.\"\n        );\n\n        address owner = ownerOf(tokenId);\n        require(msg.sender!=owner, \"ERC721Matcha: The owner cannot bid his own collectible\");\n\n        \/\/ return the funds to the previous bidder, if there is one\n        if (auctions[tokenId].highestBid>0) {\n            (bool success, ) = auctions[tokenId].highestBidder.call.value(auctions[tokenId].highestBid)(\"\");\n            require(success, \"Transfer failed.\");\n            emit Refund(auctions[tokenId].highestBidder, auctions[tokenId].highestBid);\n        }\n\n        \/\/ now store the bid data\n        auctions[tokenId].highestBidder = msg.sender;\n        auctions[tokenId].highestBid = msg.value;\n        emit HighestBidIncreased(msg.sender, msg.value, tokenId);\n\n    }\n\n    \/\/ anyone can execute withdraw if auction is opened and \n    \/\/ the bid time expired and the reserve was not met\n    \/\/ or\n    \/\/ the auction is openen but the contract is unable to transfer\n    function canWithdraw(uint256 tokenId) public view returns (bool) {\n        if (auctions[tokenId].open && \n            (\n                (\n                    now >= auctions[tokenId].auctionEnd &&\n                    auctions[tokenId].highestBid > 0 &&\n                    auctions[tokenId].highestBid<auctions[tokenId].reserve\n                ) || \n                getApproved(tokenId) != address(this)\n            )\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/\/ Withdraw a bid when the auction is not finalized\n    function withdraw(uint256 tokenId) public nonReentrant returns (bool) {\n\n        require(canWithdraw(tokenId), \"Conditions to withdraw are not met\");\n\n        \/\/ transfer funds to highest bidder always\n        if (auctions[tokenId].highestBid > 0) {\n            (bool success, ) = auctions[tokenId].highestBidder.call.value(auctions[tokenId].highestBid)(\"\");\n            require(success, \"Transfer failed.\");\n        }\n\n        \/\/ finalize the auction\n        delete auctions[tokenId];\n\n    }\n\n    function canFinalize(uint256 tokenId) public view returns (bool) {\n        if (auctions[tokenId].open && \n            now >= auctions[tokenId].auctionEnd &&\n            (\n                auctions[tokenId].highestBid>=auctions[tokenId].reserve || \n                auctions[tokenId].highestBid==0\n            )\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/ implement the auctionFinalize including the NFT transfer logic\n    function auctionFinalize(uint256 tokenId) public nonReentrant {\n\n        require(canFinalize(tokenId), \"Cannot finalize\");\n\n        if (auctions[tokenId].highestBid>0) {\n\n            \/\/ transfer the ownership of token to the highest bidder\n            address payable highestBidder = auctions[tokenId].highestBidder;\n\n            \/\/ calculate payment amounts\n            uint256 amount4admin = auctions[tokenId].highestBid.mul(commissionRate).div(100);\n            uint256 amount4owner = auctions[tokenId].highestBid.sub(amount4admin);\n\n            \/\/ to owner\n            (bool success, ) = auctions[tokenId].beneficiary.call.value(amount4owner)(\"\");\n            require(success, \"Transfer failed.\");\n\n            \/\/ to admin\n            (bool success2, ) = admin.call.value(amount4admin)(\"\");\n            require(success2, \"Transfer failed.\");\n\n            emit Sale(tokenId, auctions[tokenId].beneficiary, highestBidder, auctions[tokenId].highestBid);\n            emit Commission(tokenId, auctions[tokenId].beneficiary, auctions[tokenId].highestBid, commissionRate, amount4admin);\n\n            \/\/ transfer ownership\n            address owner = ownerOf(tokenId);\n\n            \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n            \/\/ transfer the NFT to the auction's highest bidder\n            callOptionalReturn(this, abi.encodeWithSelector(this.transferFrom.selector, owner, highestBidder, tokenId));\n\n            soldFor[tokenId] = auctions[tokenId].highestBid;\n\n        }\n\n        emit AuctionEnded(auctions[tokenId].highestBidder, auctions[tokenId].highestBid);\n\n        \/\/ finalize the auction\n        delete auctions[tokenId];\n\n    }\n\n    \/\/ Bid query functions\n    function highestBidder(uint256 tokenId) public view returns (address payable) {\n        return auctions[tokenId].highestBidder;\n    }\n\n    function highestBid(uint256 tokenId) public view returns (uint256) {\n        return auctions[tokenId].highestBid;\n    }\n\n    \/**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\/\n    function callOptionalReturn(IERC721 token, bytes memory data) private {\n        \/\/ We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        \/\/ we're implementing it ourselves.\n\n        \/\/ A Solidity high level call has three parts:\n        \/\/  1. The target address is checked to verify it contains contract code\n        \/\/  2. The call itself is made, and success asserted\n        \/\/  3. The return value is decoded, which in turn checks the size of the returned data.\n        \/\/ solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC721: call to non-contract\");\n\n        \/\/ solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC721: low-level call failed\");\n\n        if (returndata.length > 0) { \/\/ Return data is optional\n            \/\/ solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC721: ERC20 operation did not succeed\");\n        }\n    }\n\n    \/\/ update contract fields\n    function updateAdmin(address payable _admin, uint256 _commissionRate, bool _anyoneCanMint) public {\n        require(msg.sender==contract_owner, \"Only contract owner can do this\");\n        admin=_admin;\n        commissionRate=_commissionRate;\n        anyoneCanMint=_anyoneCanMint;\n    }\n\n}",
                "contractName":"ERC721Matcha",
                "version": "1.1",
                "compilerVersion":"v0.5.7+commit.6da8b019"
            },
            "2.0": {
                "abi_factory":[{"inputs":[{"internalType":"contract EIP20","name":"_token","type":"address"},{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"},{"internalType":"uint256","name":"_claimRatio","type":"uint256"},{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"inputs":[],"name":"buyCoffee","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"},{"internalType":"address","name":"from_address","type":"address"}],"name":"buyTea","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"canBuyTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"enableTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getPriceInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"master","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"contract EIP20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_claimRatio","type":"uint256"}],"name":"updateClaimRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_enabled","type":"bool"}],"name":"updateEnabled","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"}],"name":"updateRewardsRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract EIP20","name":"_token","type":"address"}],"name":"updateToken","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source":"\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  ERC-721 NFT Marketplace\n    |\n    |----------------------------\n    |\n    |  Flavors\n    |\n    |  >  Matcha v.2: Standard ERC-721 Marketplace\n    |\n\n*\/\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Required interface of an ERC721 compliant contract.\n *\/\ninterface IERC721 is IERC165 {\n    \/**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    \/**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     *\/\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    \/**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     *\/\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    \/**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     *\/\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    \/**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    \/**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    \/**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address to, uint256 tokenId) external;\n\n    \/**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    \/**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     *\/\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    \/**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     *\/\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n\/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n *\/\ninterface IERC721Receiver {\n    \/**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     *\/\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ninterface IERC721Metadata is IERC721 {\n    \/**\n     * @dev Returns the token collection name.\n     *\/\n    function name() external view returns (string memory);\n\n    \/**\n     * @dev Returns the token collection symbol.\n     *\/\n    function symbol() external view returns (string memory);\n\n    \/**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     *\/\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https:\/\/diligence.consensys.net\/posts\/2019\/09\/stop-using-soliditys-transfer-now\/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https:\/\/solidity.readthedocs.io\/en\/v0.5.11\/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\/\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \/**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https:\/\/solidity.readthedocs.io\/en\/latest\/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     *\/\n    function toString(uint256 value) internal pure returns (string memory) {\n        \/\/ Inspired by OraclizeAPI's implementation - MIT licence\n        \/\/ https:\/\/github.com\/oraclize\/ethereum-api\/blob\/b42146b063c7d6ee1358846c198246239e9360e8\/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp \/= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value \/= 10;\n        }\n        return string(buffer);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     *\/\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev Implementation of https:\/\/eips.ethereum.org\/EIPS\/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n *\/\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    \/\/ Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    \/\/ Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    \/\/ Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    \/\/ Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     *\/\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC721-balanceOf}.\n     *\/\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    \/**\n     * @dev See {IERC721-ownerOf}.\n     *\/\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-name}.\n     *\/\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-symbol}.\n     *\/\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-tokenURI}.\n     *\/\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    \/**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     *\/\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    \/**\n     * @dev See {IERC721-approve}.\n     *\/\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    \/**\n     * @dev See {IERC721-getApproved}.\n     *\/\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    \/**\n     * @dev See {IERC721-setApprovalForAll}.\n     *\/\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    \/**\n     * @dev See {IERC721-isApprovedForAll}.\n     *\/\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    \/**\n     * @dev See {IERC721-transferFrom}.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        \/\/solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    \/**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     *\/\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    \/**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    \/**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     *\/\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    \/**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    \/**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        \/\/ Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    \/**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        \/\/ Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     *\/\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    \/**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     *\/\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ninterface IERC721Enumerable is IERC721 {\n    \/**\n     * @dev Returns the total amount of tokens stored by the contract.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    \/**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     *\/\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n\/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n *\/\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    \/\/ Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    \/\/ Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    \/\/ Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    \/\/ Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     *\/\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     *\/\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     *\/\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     *\/\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     *\/\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        \/\/ To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n        }\n\n        \/\/ This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     *\/\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        \/\/ To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        \/\/ rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        \/\/ an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n\n        \/\/ This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\n\/**\n * @dev ERC721 token with storage based token URI management.\n *\/\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    \/\/ Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    \/**\n     * @dev See {IERC721Metadata-tokenURI}.\n     *\/\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        \/\/ If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        \/\/ If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    \/**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    \/**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n\/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n *\/\nabstract contract ERC721Burnable is Context, ERC721 {\n    \/**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     *\/\n    function burn(uint256 tokenId) public virtual {\n        \/\/solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n *\/\ninterface IAccessControlEnumerable is IAccessControl {\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     *\/\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\/**\n * @dev Library for managing\n * https:\/\/en.wikipedia.org\/wiki\/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     \/\/ Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     \/\/ Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\/\nlibrary EnumerableSet {\n    \/\/ To implement this library for multiple types with as little code\n    \/\/ repetition as possible, we write it in terms of a generic Set type with\n    \/\/ bytes32 values.\n    \/\/ The Set implementation uses private functions, and user-facing\n    \/\/ implementations (such as AddressSet) are just wrappers around the\n    \/\/ underlying Set.\n    \/\/ This means that we can only create new EnumerableSets for types that fit\n    \/\/ in bytes32.\n\n    struct Set {\n        \/\/ Storage of set values\n        bytes32[] _values;\n        \/\/ Position of the value in the `values` array, plus 1 because index 0\n        \/\/ means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            \/\/ The value is stored at length-1, but we add 1 to all indexes\n            \/\/ and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        \/\/ We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            \/\/ Equivalent to contains(set, value)\n            \/\/ To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            \/\/ the array, and then remove the last element (sometimes called as 'swap and pop').\n            \/\/ This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                \/\/ Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                \/\/ Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; \/\/ Replace lastvalue's index to valueIndex\n            }\n\n            \/\/ Delete the slot where the moved value was stored\n            set._values.pop();\n\n            \/\/ Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    \/\/ Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    \/\/ AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    \/\/ UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n\/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n *\/\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    \/**\n     * @dev Overload {grantRole} to track enumerable memberships\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    \/**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n}\n\n\/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n *\/\nlibrary Counters {\n    struct Counter {\n        \/\/ This variable should never be directly accessed by users of the library: interactions must be restricted to\n        \/\/ the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        \/\/ this feature: see https:\/\/github.com\/ethereum\/solidity\/issues\/4637\n        uint256 _value; \/\/ default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n \n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\ncontract ERC721Mochi is ERC721, ERC721Enumerable, ERC721URIStorage, AccessControlEnumerable, ERC721Burnable {\n    using Counters for Counters.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    Counters.Counter private _tokenIdCounter;\n    bool public anyoneCanMint;\n\n    constructor(address owner, string memory name, string memory symbol, bool _anyoneCanMint) ERC721(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(MINTER_ROLE, owner);\n        anyoneCanMint = _anyoneCanMint;\n    }\n\n    function autoMint(string memory _tokenURI, address to) public onlyMinter {\n        uint id;\n        do {\n          _tokenIdCounter.increment();\n          id = _tokenIdCounter.current();\n        } while(_exists(id));\n        _mint(to, id);\n        _setTokenURI(id, _tokenURI);\n    }\n\n    function mint(address to, uint256 tokenId) public onlyMinter {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyMinter {\n        _safeMint(to, tokenId);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    function safeMint(address to, uint256 tokenId, bytes memory _data) public onlyMinter {\n        _safeMint(to, tokenId, _data);\n    }\n\n    function _burn(uint256 tokenId) internal virtual override(ERC721, ERC721URIStorage) {\n        ERC721URIStorage._burn(tokenId);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n        internal\n        override(ERC721, ERC721Enumerable)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable, AccessControlEnumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function addMinter(address account) public onlyRole(MINTER_ROLE) {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function canIMint() public view returns (bool) {\n        return anyoneCanMint || isMinter(msg.sender);\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        string memory mensaje;\n        require(\n            canIMint(),\n            \"MinterRole: caller does not have the Minter role\"\n        );\n        _;\n    }\n\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\ncontract EIP20 {\n\n    uint256 public totalSupply;\n\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    \/*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets\/interfaces might not even bother to look at this information.\n    *\/\n    string public name;                   \/\/fancy name: eg Simon Bucks\n    uint8 public decimals;                \/\/How many decimals to show.\n    string public symbol;                 \/\/An identifier: eg SBX\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    constructor(\n        uint256 _initialAmount,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol\n    ) {\n        balances[msg.sender] = _initialAmount;               \/\/ Give the creator all initial tokens\n        totalSupply = _initialAmount;                        \/\/ Update total supply\n        name = _tokenName;                                   \/\/ Set the name for display purposes\n        decimals = _decimalUnits;                            \/\/ Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               \/\/ Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        uint256 _allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && _allowance >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (_allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\/**\n * @title ERC721Matcha\n * ERC-721 Marketplace\n *\/\n\ncontract ERC721Matcha is ERC721Mochi, ReentrancyGuard {\n\n    using Address for address payable;\n    using Address for address;\n\n    \/\/ admin address, the owner of the marketplace\n    address payable admin;\n\n    address public contract_owner;\n\n    \/\/ commission rate is a value from 0 to 100\n    uint256 commissionRate;\n\n    \/\/ last price sold or auctioned\n    mapping(uint256 => uint256) public soldFor;\n    \n    \/\/ Mapping from token ID to sell price in Ether or to bid price, depending if it is an auction or not\n    mapping(uint256 => uint256) public sellBidPrice;\n\n    \/\/ Mapping payment address for tokenId \n    mapping(uint256 => address payable) private _wallets;\n\n    event Sale(uint256 indexed tokenId, address indexed from, address indexed to, uint256 value);\n    event Commission(uint256 indexed tokenId, address indexed to, uint256 value, uint256 rate, uint256 total);\n\n    \/\/ Auction data\n    struct Auction {\n\n        \/\/ Parameters of the auction. Times are either\n        \/\/ absolute unix timestamps (seconds since 1970-01-01)\n        \/\/ or time periods in seconds.\n        address payable beneficiary;\n        uint auctionEnd;\n\n        \/\/ Current state of the auction.\n        address payable highestBidder;\n        uint highestBid;\n\n        \/\/ Set to true at the end, disallows any change\n        bool open;\n\n        \/\/ minimum reserve price in wei\n        uint256 reserve;\n\n    }\n\n    \/\/ mapping auctions for each tokenId\n    mapping(uint256 => Auction) public auctions;\n\n    \/\/ Events that will be fired on changes.\n    event Refund(address bidder, uint amount);\n    event HighestBidIncreased(address indexed bidder, uint amount, uint256 tokenId);\n    event AuctionEnded(address winner, uint amount);\n\n    event LimitSell(address indexed from, address indexed to, uint256 amount);\n    event LimitBuy(address indexed from, address indexed to, uint256 amount);\n    event MarketSell(address indexed from, address indexed to, uint256 amount);\n    event MarketBuy(address indexed from, address indexed to, uint256 amount);\n\n    constructor(\n        address _owner, address payable _admin, \n        uint256 _commissionRate, string memory name, string memory symbol, bool _anyoneCanMint) \n        ERC721Mochi(_owner, name, symbol, _anyoneCanMint) \n    {\n        admin = _admin;\n        contract_owner = _owner;\n        require(_commissionRate<=100, \"ERC721Matcha: Commission rate has to be between 0 and 100\");\n        commissionRate = _commissionRate;\n    }\n\n    function canSell(uint256 tokenId) external view returns (bool) {\n        return (ownerOf(tokenId)==msg.sender && !auctions[tokenId].open);\n    }\n\n    \/\/ Sell option for a fixed price\n    function sell(uint256 tokenId, uint256 price, address payable wallet) external {\n\n        \/\/ onlyOwner\n        require(ownerOf(tokenId)==msg.sender, \"ERC721Matcha: Only owner can sell this item\");\n\n        \/\/ cannot set a price if auction is activated\n        require(!auctions[tokenId].open, \"ERC721Matcha: Cannot sell an item which has an active auction\");\n\n        \/\/ set sell price for index\n        sellBidPrice[tokenId] = price;\n\n        \/\/ If price is zero, means not for sale\n        if (price>0) {\n\n            \/\/ approve the Index to the current contract\n            approve(address(this), tokenId);\n            \n            \/\/ set wallet payment\n            _wallets[tokenId] = wallet;\n            \n        }\n\n    }\n\n    \/\/ simple function to return the price of a tokenId\n    \/\/ returns: sell price, bid price, sold price, only one can be non zero\n    function getPrice(uint256 tokenId) external view returns (uint256, uint256, uint256) {\n        if (sellBidPrice[tokenId]>0) return (sellBidPrice[tokenId], 0, 0);\n        if (auctions[tokenId].highestBid>0) return (0, auctions[tokenId].highestBid, 0);\n        return (0, 0, soldFor[tokenId]);\n    }\n\n    function canBuy(uint256 tokenId) external view returns (uint256) {\n        if (!auctions[tokenId].open && sellBidPrice[tokenId]>0 && sellBidPrice[tokenId]>0 && getApproved(tokenId) == address(this)) {\n            return sellBidPrice[tokenId];\n        } else {\n            return 0;\n        }\n    }\n\n    \/\/ Buy option\n    function buy(uint256 tokenId) external payable nonReentrant {\n\n        \/\/ is on sale\n        require(!auctions[tokenId].open && sellBidPrice[tokenId]>0, \"ERC721Matcha: The collectible is not for sale\");\n\n        \/\/ enough funds\n        require(msg.value >= sellBidPrice[tokenId], \"ERC721Matcha: Not enough funds\");\n\n        \/\/ transfer ownership\n        address owner = ownerOf(tokenId);\n\n        require(msg.sender!=owner, \"ERC721Matcha: The seller cannot buy his own collectible\");\n\n        \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n        callOptionalReturn(this, abi.encodeWithSelector(this.transferFrom.selector, owner, msg.sender, tokenId));\n\n        \/\/ calculate amounts\n        uint256 amount4admin = msg.value * commissionRate \/ 100;\n        uint256 amount4owner = msg.value - amount4admin;\n\n        \/\/ to owner\n        (bool success, ) = _wallets[tokenId].call{value:amount4owner}(\"\");\n        require(success, \"Transfer failed.\");\n\n        \/\/ to admin\n        (bool success2, ) = admin.call{value:amount4admin}(\"\");\n        require(success2, \"Transfer failed.\");\n\n        emit Sale(tokenId, owner, msg.sender, sellBidPrice[tokenId]);\n        emit Commission(tokenId, owner, sellBidPrice[tokenId], commissionRate, amount4admin);\n\n        soldFor[tokenId] = sellBidPrice[tokenId];\n\n        \/\/ close the sell\n        sellBidPrice[tokenId] = 0;\n        delete _wallets[tokenId];\n\n    }\n\n    function canAuction(uint256 tokenId) external view returns (bool) {\n        return (ownerOf(tokenId)==msg.sender && !auctions[tokenId].open && sellBidPrice[tokenId]==0);\n    }\n\n    \/\/ Instantiate an auction contract for a tokenId\n    function createAuction(uint256 tokenId, uint _closingTime, address payable _beneficiary, uint256 _reservePrice) external {\n\n        require(sellBidPrice[tokenId]==0, \"ERC721Matcha: The selected NFT is open for sale, cannot be auctioned\");\n        require(!auctions[tokenId].open, \"ERC721Matcha: The selected NFT already has an auction\");\n        require(ownerOf(tokenId)==msg.sender, \"ERC721Matcha: Only owner can auction this item\");\n\n        auctions[tokenId].beneficiary = _beneficiary;\n        auctions[tokenId].auctionEnd = _closingTime;\n        auctions[tokenId].reserve = _reservePrice;\n        auctions[tokenId].open = true;\n\n        \/\/ approve the Index to the current contract\n        approve(address(this), tokenId);\n\n    }\n\n    function canBid(uint256 tokenId) external view returns (bool) {\n        if (msg.sender == tx.origin &&\n            auctions[tokenId].open &&\n            block.timestamp <= auctions[tokenId].auctionEnd &&\n            msg.sender != ownerOf(tokenId) &&\n            getApproved(tokenId) == address(this)\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/\/ Bid on the auction with the value sent\n    \/\/\/ together with this transaction.\n    \/\/\/ The value will only be refunded if the\n    \/\/\/ auction is not won.\n    function bid(uint256 tokenId) external payable nonReentrant {\n\n        \/\/ Contracts cannot bid, because they can block the auction with a reentrant attack\n        require(msg.sender == tx.origin, \"No script kiddies\");\n\n        \/\/ auction has to be opened\n        require(auctions[tokenId].open, \"No opened auction found\");\n\n        \/\/ approve was lost\n        require(getApproved(tokenId) == address(this), \"Cannot complete the auction\");\n\n        \/\/ Revert the call if the bidding\n        \/\/ period is over.\n        require(\n            block.timestamp <= auctions[tokenId].auctionEnd,\n            \"Auction already ended.\"\n        );\n\n        \/\/ If the bid is not higher, send the\n        \/\/ money back.\n        require(\n            msg.value > auctions[tokenId].highestBid,\n            \"There already is a higher bid.\"\n        );\n\n        address owner = ownerOf(tokenId);\n        require(msg.sender!=owner, \"ERC721Matcha: The owner cannot bid his own collectible\");\n\n        \/\/ return the funds to the previous bidder, if there is one\n        if (auctions[tokenId].highestBid>0) {\n            (bool success, ) = auctions[tokenId].highestBidder.call{value: auctions[tokenId].highestBid}(\"\");\n            require(success, \"Transfer failed.\");\n            emit Refund(auctions[tokenId].highestBidder, auctions[tokenId].highestBid);\n        }\n\n        \/\/ now store the bid data\n        auctions[tokenId].highestBidder = payable(msg.sender);\n\n        \/\/ register the highest bid value\n        auctions[tokenId].highestBid = msg.value;\n\n        emit HighestBidIncreased(msg.sender, msg.value, tokenId);\n\n    }\n\n    \/\/ anyone can execute withdraw if auction is opened and \n    \/\/ the bid time expired and the reserve was not met\n    \/\/ or\n    \/\/ the auction is openen but the contract is unable to transfer\n    function canWithdraw(uint256 tokenId) public view returns (bool) {\n        if (auctions[tokenId].open && \n            (\n                (\n                    block.timestamp >= auctions[tokenId].auctionEnd &&\n                    auctions[tokenId].highestBid > 0 &&\n                    auctions[tokenId].highestBid<auctions[tokenId].reserve\n                ) || \n                getApproved(tokenId) != address(this)\n            )\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/\/ Withdraw a bid when the auction is not finalized\n    function withdraw(uint256 tokenId) external nonReentrant {\n\n        require(canWithdraw(tokenId), \"Conditions to withdraw are not met\");\n\n        \/\/ transfer funds to highest bidder always\n        if (auctions[tokenId].highestBid > 0) {\n            (bool success, ) = auctions[tokenId].highestBidder.call{value: auctions[tokenId].highestBid}(\"\");\n            require(success, \"Transfer failed.\");\n        }\n\n        \/\/ finalize the auction\n        delete auctions[tokenId];\n\n    }\n\n    function canFinalize(uint256 tokenId) public view returns (bool) {\n        if (auctions[tokenId].open && \n            block.timestamp >= auctions[tokenId].auctionEnd &&\n            (\n                auctions[tokenId].highestBid>=auctions[tokenId].reserve || \n                auctions[tokenId].highestBid==0\n            )\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/ implement the auctionFinalize including the NFT transfer logic\n    function auctionFinalize(uint256 tokenId) external nonReentrant {\n\n        require(canFinalize(tokenId), \"Cannot finalize\");\n\n        if (auctions[tokenId].highestBid>0) {\n\n            \/\/ transfer the ownership of token to the highest bidder\n            address payable _highestBidder = auctions[tokenId].highestBidder;\n\n            \/\/ calculate payment amounts\n            uint256 amount4admin = auctions[tokenId].highestBid * commissionRate \/ 100;\n            uint256 amount4owner = auctions[tokenId].highestBid - amount4admin;\n\n            \/\/ to owner\n            (bool success, ) = auctions[tokenId].beneficiary.call{value: amount4owner}(\"\");\n            require(success, \"Transfer failed.\");\n\n            \/\/ to admin\n            (bool success2, ) = admin.call{value:amount4admin}(\"\");\n            require(success2, \"Transfer failed.\");\n\n            emit Sale(tokenId, auctions[tokenId].beneficiary, _highestBidder, auctions[tokenId].highestBid);\n            emit Commission(tokenId, auctions[tokenId].beneficiary, auctions[tokenId].highestBid, commissionRate, amount4admin);\n\n            \/\/ transfer ownership\n            address owner = ownerOf(tokenId);\n\n            \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n            \/\/ transfer the NFT to the auction's highest bidder\n            callOptionalReturn(this, abi.encodeWithSelector(this.transferFrom.selector, owner, _highestBidder, tokenId));\n\n            soldFor[tokenId] = auctions[tokenId].highestBid;\n\n        }\n\n        emit AuctionEnded(auctions[tokenId].highestBidder, auctions[tokenId].highestBid);\n\n        \/\/ finalize the auction\n        delete auctions[tokenId];\n\n    }\n\n    \/\/ Bid query functions\n    function highestBidder(uint256 tokenId) external view returns (address payable) {\n        return auctions[tokenId].highestBidder;\n    }\n\n    function highestBid(uint256 tokenId) external view returns (uint256) {\n        return auctions[tokenId].highestBid;\n    }\n\n    \/**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\/\n    function callOptionalReturn(IERC721 token, bytes memory data) private {\n        \/\/ We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        \/\/ we're implementing it ourselves.\n\n        \/\/ A Solidity high level call has three parts:\n        \/\/  1. The target address is checked to verify it contains contract code\n        \/\/  2. The call itself is made, and success asserted\n        \/\/  3. The return value is decoded, which in turn checks the size of the returned data.\n        \/\/ solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC721: call to non-contract\");\n\n        \/\/ solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC721: low-level call failed\");\n\n        if (returndata.length > 0) { \/\/ Return data is optional\n            \/\/ solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC721: ERC20 operation did not succeed\");\n        }\n    }\n\n    \/\/ update contract fields\n    function updateAdmin(address payable _admin, uint256 _commissionRate, bool _anyoneCanMint) external {\n        require(msg.sender==contract_owner, \"Only contract owner can do this\");\n        require(_commissionRate <= 100, \"Commission rate has to be equal or lower than 100\");\n        admin = _admin;\n        commissionRate = _commissionRate;\n        anyoneCanMint = _anyoneCanMint;\n    }\n    \n    \/\/ update owner\n    function updateOwner(address _contract_owner) external {\n\n        require(msg.sender==contract_owner, \"Only contract owner can do this\");\n\n        \/\/ grant roles to new owner\n        _setupRole(DEFAULT_ADMIN_ROLE, _contract_owner);\n        _setupRole(MINTER_ROLE, _contract_owner);\n\n        \/\/ revoke roles of old owner\n        revokeRole(MINTER_ROLE, contract_owner);\n        revokeRole(DEFAULT_ADMIN_ROLE, contract_owner);\n\n        \/\/ change ownership\n        contract_owner = _contract_owner;\n\n    }\n\n}",
                "contractName":"ERC721Matcha",
                "version": "2.0",
                "compilerVersion":"v0.8.2"
            },
            "3.0": {
                "abi_factory":[{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"},{"internalType":"address","name":"_affiliate","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Required interface of an ERC721 compliant contract.\n *\/\ninterface IERC721 is IERC165 {\n    \/**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    \/**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     *\/\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    \/**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     *\/\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    \/**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     *\/\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    \/**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    \/**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    \/**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address to, uint256 tokenId) external;\n\n    \/**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    \/**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     *\/\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    \/**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     *\/\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n\/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n *\/\ninterface IERC721Receiver {\n    \/**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     *\/\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ninterface IERC721Metadata is IERC721 {\n    \/**\n     * @dev Returns the token collection name.\n     *\/\n    function name() external view returns (string memory);\n\n    \/**\n     * @dev Returns the token collection symbol.\n     *\/\n    function symbol() external view returns (string memory);\n\n    \/**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     *\/\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https:\/\/diligence.consensys.net\/posts\/2019\/09\/stop-using-soliditys-transfer-now\/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https:\/\/solidity.readthedocs.io\/en\/v0.5.11\/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\/\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \/**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https:\/\/solidity.readthedocs.io\/en\/latest\/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     *\/\n    function toString(uint256 value) internal pure returns (string memory) {\n        \/\/ Inspired by OraclizeAPI's implementation - MIT licence\n        \/\/ https:\/\/github.com\/oraclize\/ethereum-api\/blob\/b42146b063c7d6ee1358846c198246239e9360e8\/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp \/= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value \/= 10;\n        }\n        return string(buffer);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     *\/\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev Implementation of https:\/\/eips.ethereum.org\/EIPS\/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n *\/\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    \/\/ Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    \/\/ Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    \/\/ Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    \/\/ Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     *\/\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC721-balanceOf}.\n     *\/\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    \/**\n     * @dev See {IERC721-ownerOf}.\n     *\/\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-name}.\n     *\/\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-symbol}.\n     *\/\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-tokenURI}.\n     *\/\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    \/**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     *\/\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    \/**\n     * @dev See {IERC721-approve}.\n     *\/\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    \/**\n     * @dev See {IERC721-getApproved}.\n     *\/\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    \/**\n     * @dev See {IERC721-setApprovalForAll}.\n     *\/\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    \/**\n     * @dev See {IERC721-isApprovedForAll}.\n     *\/\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    \/**\n     * @dev See {IERC721-transferFrom}.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        \/\/solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    \/**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     *\/\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    \/**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    \/**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     *\/\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    \/**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    \/**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        \/\/ Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    \/**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        \/\/ Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     *\/\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    \/**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     *\/\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ninterface IERC721Enumerable is IERC721 {\n    \/**\n     * @dev Returns the total amount of tokens stored by the contract.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    \/**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     *\/\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n\/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n *\/\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    \/\/ Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    \/\/ Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    \/\/ Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    \/\/ Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     *\/\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     *\/\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     *\/\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     *\/\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     *\/\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        \/\/ To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n        }\n\n        \/\/ This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     *\/\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        \/\/ To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        \/\/ rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        \/\/ an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n\n        \/\/ This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\n\/**\n * @dev ERC721 token with storage based token URI management.\n *\/\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    \/\/ Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    \/**\n     * @dev See {IERC721Metadata-tokenURI}.\n     *\/\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        \/\/ If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        \/\/ If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    \/**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    \/**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n\/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n *\/\nabstract contract ERC721Burnable is Context, ERC721 {\n    \/**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     *\/\n    function burn(uint256 tokenId) public virtual {\n        \/\/solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n *\/\ninterface IAccessControlEnumerable is IAccessControl {\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     *\/\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\/**\n * @dev Library for managing\n * https:\/\/en.wikipedia.org\/wiki\/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     \/\/ Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     \/\/ Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\/\nlibrary EnumerableSet {\n    \/\/ To implement this library for multiple types with as little code\n    \/\/ repetition as possible, we write it in terms of a generic Set type with\n    \/\/ bytes32 values.\n    \/\/ The Set implementation uses private functions, and user-facing\n    \/\/ implementations (such as AddressSet) are just wrappers around the\n    \/\/ underlying Set.\n    \/\/ This means that we can only create new EnumerableSets for types that fit\n    \/\/ in bytes32.\n\n    struct Set {\n        \/\/ Storage of set values\n        bytes32[] _values;\n        \/\/ Position of the value in the `values` array, plus 1 because index 0\n        \/\/ means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            \/\/ The value is stored at length-1, but we add 1 to all indexes\n            \/\/ and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        \/\/ We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            \/\/ Equivalent to contains(set, value)\n            \/\/ To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            \/\/ the array, and then remove the last element (sometimes called as 'swap and pop').\n            \/\/ This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                \/\/ Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                \/\/ Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; \/\/ Replace lastvalue's index to valueIndex\n            }\n\n            \/\/ Delete the slot where the moved value was stored\n            set._values.pop();\n\n            \/\/ Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    \/\/ Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    \/\/ AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    \/\/ UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n\/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n *\/\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    \/**\n     * @dev Overload {grantRole} to track enumerable memberships\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    \/**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n}\n\n\/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n *\/\nlibrary Counters {\n    struct Counter {\n        \/\/ This variable should never be directly accessed by users of the library: interactions must be restricted to\n        \/\/ the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        \/\/ this feature: see https:\/\/github.com\/ethereum\/solidity\/issues\/4637\n        uint256 _value; \/\/ default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n \n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\ncontract ERC721_Mochi is ERC721, ERC721Enumerable, ERC721URIStorage, AccessControlEnumerable, ERC721Burnable {\n    using Counters for Counters.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    Counters.Counter private _tokenIdCounter;\n    bool public anyoneCanMint;\n\n    constructor(address owner, string memory name, string memory symbol, bool _anyoneCanMint) ERC721(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(MINTER_ROLE, owner);\n        anyoneCanMint = _anyoneCanMint;\n    }\n\n    function autoMint(string memory _tokenURI, address to) public onlyMinter {\n        uint id;\n        do {\n          _tokenIdCounter.increment();\n          id = _tokenIdCounter.current();\n        } while(_exists(id));\n        _mint(to, id);\n        _setTokenURI(id, _tokenURI);\n    }\n\n    function mint(address to, uint256 tokenId) public onlyMinter {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyMinter {\n        _safeMint(to, tokenId);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    function safeMint(address to, uint256 tokenId, bytes memory _data) public onlyMinter {\n        _safeMint(to, tokenId, _data);\n    }\n\n    function _burn(uint256 tokenId) internal virtual override(ERC721, ERC721URIStorage) {\n        ERC721URIStorage._burn(tokenId);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n        internal\n        override(ERC721, ERC721Enumerable)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable, AccessControlEnumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function addMinter(address account) public onlyRole(MINTER_ROLE) {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function canIMint() public view returns (bool) {\n        return anyoneCanMint || isMinter(msg.sender);\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        string memory mensaje;\n        require(\n            canIMint(),\n            \"MinterRole: caller does not have the Minter role\"\n        );\n        _;\n    }\n\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\ncontract EIP20 {\n\n    uint256 public totalSupply;\n\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    \/*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets\/interfaces might not even bother to look at this information.\n    *\/\n    string public name;                   \/\/fancy name: eg Simon Bucks\n    uint8 public decimals;                \/\/How many decimals to show.\n    string public symbol;                 \/\/An identifier: eg SBX\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    constructor(\n        uint256 _initialAmount,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol\n    ) {\n        balances[msg.sender] = _initialAmount;               \/\/ Give the creator all initial tokens\n        totalSupply = _initialAmount;                        \/\/ Update total supply\n        name = _tokenName;                                   \/\/ Set the name for display purposes\n        decimals = _decimalUnits;                            \/\/ Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               \/\/ Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        uint256 _allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && _allowance >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (_allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\/**\n * @title ERC721Matcha\n * Matcha ERC-721 Marketplace v.3\n *\/\n\ncontract ERC721Matcha is ERC721_Mochi, ReentrancyGuard {\n\n    using Address for address payable;\n    using Address for address;\n\n    \/\/ admin address, the owner of the marketplace\n    address payable public admin;\n\n    address public contract_owner;\n\n    \/\/ commission rate is a value from 0 to 100\n    uint256 public commissionRate;\n\n    \/\/ last price sold or auctioned\n    mapping(uint256 => uint256) public soldFor;\n    \n    \/\/ Mapping from token ID to sell price in Ether or to bid price, depending if it is an auction or not\n    mapping(uint256 => uint256) public sellBidPrice;\n\n    \/\/ Mapping payment address for tokenId \n    mapping(uint256 => address payable) private _wallets;\n\n    event Sale(uint256 indexed tokenId, address indexed from, address indexed to, uint256 value);\n    event Commission(uint256 indexed tokenId, address indexed to, uint256 value, uint256 rate, uint256 total);\n\n    \/\/ Auction data\n    struct Auction {\n\n        \/\/ Parameters of the auction. Times are either\n        \/\/ absolute unix timestamps (seconds since 1970-01-01)\n        \/\/ or time periods in seconds.\n        address payable beneficiary;\n        uint auctionEnd;\n\n        \/\/ Current state of the auction.\n        address payable highestBidder;\n        uint highestBid;\n\n        \/\/ Set to true at the end, disallows any change\n        bool open;\n\n        \/\/ minimum reserve price in wei\n        uint256 reserve;\n\n    }\n\n    \/\/ mapping auctions for each tokenId\n    mapping(uint256 => Auction) public auctions;\n\n    \/\/ Events that will be fired on changes.\n    event Refund(address bidder, uint amount);\n    event HighestBidIncreased(address indexed bidder, uint amount, uint256 tokenId);\n    event AuctionEnded(address winner, uint amount);\n\n    event LimitSell(address indexed from, address indexed to, uint256 amount);\n    event LimitBuy(address indexed from, address indexed to, uint256 amount);\n    event MarketSell(address indexed from, address indexed to, uint256 amount);\n    event MarketBuy(address indexed from, address indexed to, uint256 amount);\n\n    constructor(\n        address _owner, address payable _admin, \n        uint256 _commissionRate, string memory name, string memory symbol, bool _anyoneCanMint) \n        ERC721_Mochi(_owner, name, symbol, _anyoneCanMint) \n    {\n        admin = _admin;\n        contract_owner = _owner;\n        require(_commissionRate<=100, \"ERC721Matcha: Commission rate has to be between 0 and 100\");\n        commissionRate = _commissionRate;\n    }\n\n    function canSell(uint256 tokenId) external view returns (bool) {\n        return (ownerOf(tokenId)==msg.sender && !auctions[tokenId].open);\n    }\n\n    \/\/ Sell option for a fixed price\n    function sell(uint256 tokenId, uint256 price, address payable wallet) external {\n\n        \/\/ onlyOwner\n        require(ownerOf(tokenId)==msg.sender, \"ERC721Matcha: Only owner can sell this item\");\n\n        \/\/ cannot set a price if auction is activated\n        require(!auctions[tokenId].open, \"ERC721Matcha: Cannot sell an item which has an active auction\");\n\n        \/\/ set sell price for index\n        sellBidPrice[tokenId] = price;\n\n        \/\/ If price is zero, means not for sale\n        if (price>0) {\n\n            \/\/ approve the Index to the current contract\n            approve(address(this), tokenId);\n            \n            \/\/ set wallet payment\n            _wallets[tokenId] = wallet;\n            \n        }\n\n    }\n\n    \/\/ simple function to return the price of a tokenId\n    \/\/ returns: sell price, bid price, sold price, only one can be non zero\n    function getPrice(uint256 tokenId) external view returns (uint256, uint256, uint256) {\n        if (sellBidPrice[tokenId]>0) return (sellBidPrice[tokenId], 0, 0);\n        if (auctions[tokenId].highestBid>0) return (0, auctions[tokenId].highestBid, 0);\n        return (0, 0, soldFor[tokenId]);\n    }\n\n    function canBuy(uint256 tokenId) external view returns (uint256) {\n        if (!auctions[tokenId].open && sellBidPrice[tokenId]>0 && sellBidPrice[tokenId]>0 && getApproved(tokenId) == address(this)) {\n            return sellBidPrice[tokenId];\n        } else {\n            return 0;\n        }\n    }\n\n    \/\/ Buy option\n    function buy(uint256 tokenId) external payable nonReentrant {\n\n        \/\/ is on sale\n        require(!auctions[tokenId].open && sellBidPrice[tokenId]>0, \"ERC721Matcha: The collectible is not for sale\");\n\n        \/\/ enough funds\n        require(msg.value >= sellBidPrice[tokenId], \"ERC721Matcha: Not enough funds\");\n\n        \/\/ transfer ownership\n        address owner = ownerOf(tokenId);\n\n        require(msg.sender!=owner, \"ERC721Matcha: The seller cannot buy his own collectible\");\n\n        \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n        callOptionalReturn(this, abi.encodeWithSelector(this.transferFrom.selector, owner, msg.sender, tokenId));\n\n        \/\/ calculate amounts\n        uint256 amount4admin = msg.value * commissionRate \/ 100;\n        uint256 amount4owner = msg.value - amount4admin;\n\n        \/\/ to owner\n        (bool success, ) = _wallets[tokenId].call{value:amount4owner}(\"\");\n        require(success, \"Transfer failed.\");\n\n        \/\/ to admin\n        (bool success2, ) = admin.call{value:amount4admin}(\"\");\n        require(success2, \"Transfer failed.\");\n\n        emit Sale(tokenId, owner, msg.sender, sellBidPrice[tokenId]);\n        emit Commission(tokenId, owner, sellBidPrice[tokenId], commissionRate, amount4admin);\n\n        soldFor[tokenId] = sellBidPrice[tokenId];\n\n        \/\/ close the sell\n        sellBidPrice[tokenId] = 0;\n        delete _wallets[tokenId];\n\n    }\n\n    function canAuction(uint256 tokenId) external view returns (bool) {\n        return (ownerOf(tokenId)==msg.sender && !auctions[tokenId].open && sellBidPrice[tokenId]==0);\n    }\n\n    \/\/ Instantiate an auction contract for a tokenId\n    function createAuction(uint256 tokenId, uint _closingTime, address payable _beneficiary, uint256 _reservePrice) external {\n\n        require(sellBidPrice[tokenId]==0, \"ERC721Matcha: The selected NFT is open for sale, cannot be auctioned\");\n        require(!auctions[tokenId].open, \"ERC721Matcha: The selected NFT already has an auction\");\n        require(ownerOf(tokenId)==msg.sender, \"ERC721Matcha: Only owner can auction this item\");\n\n        auctions[tokenId].beneficiary = _beneficiary;\n        auctions[tokenId].auctionEnd = _closingTime;\n        auctions[tokenId].reserve = _reservePrice;\n        auctions[tokenId].open = true;\n\n        \/\/ approve the Index to the current contract\n        approve(address(this), tokenId);\n\n    }\n\n    function canBid(uint256 tokenId) external view returns (bool) {\n        if (msg.sender == tx.origin &&\n            auctions[tokenId].open &&\n            block.timestamp <= auctions[tokenId].auctionEnd &&\n            msg.sender != ownerOf(tokenId) &&\n            getApproved(tokenId) == address(this)\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/\/ Bid on the auction with the value sent\n    \/\/\/ together with this transaction.\n    \/\/\/ The value will only be refunded if the\n    \/\/\/ auction is not won.\n    function bid(uint256 tokenId) external payable nonReentrant {\n\n        \/\/ Contracts cannot bid, because they can block the auction with a reentrant attack\n        require(msg.sender == tx.origin, \"No script kiddies\");\n\n        \/\/ auction has to be opened\n        require(auctions[tokenId].open, \"No opened auction found\");\n\n        \/\/ approve was lost\n        require(getApproved(tokenId) == address(this), \"Cannot complete the auction\");\n\n        \/\/ Revert the call if the bidding\n        \/\/ period is over.\n        require(\n            block.timestamp <= auctions[tokenId].auctionEnd,\n            \"Auction already ended.\"\n        );\n\n        \/\/ If the bid is not higher, send the\n        \/\/ money back.\n        require(\n            msg.value > auctions[tokenId].highestBid,\n            \"There already is a higher bid.\"\n        );\n\n        address owner = ownerOf(tokenId);\n        require(msg.sender!=owner, \"ERC721Matcha: The owner cannot bid his own collectible\");\n\n        \/\/ return the funds to the previous bidder, if there is one\n        if (auctions[tokenId].highestBid>0) {\n            (bool success, ) = auctions[tokenId].highestBidder.call{value: auctions[tokenId].highestBid}(\"\");\n            require(success, \"Transfer failed.\");\n            emit Refund(auctions[tokenId].highestBidder, auctions[tokenId].highestBid);\n        }\n\n        \/\/ now store the bid data\n        auctions[tokenId].highestBidder = payable(msg.sender);\n\n        \/\/ register the highest bid value\n        auctions[tokenId].highestBid = msg.value;\n\n        emit HighestBidIncreased(msg.sender, msg.value, tokenId);\n\n    }\n\n    \/\/ anyone can execute withdraw if auction is opened and \n    \/\/ the bid time expired and the reserve was not met\n    \/\/ or\n    \/\/ the auction is openen but the contract is unable to transfer\n    function canWithdraw(uint256 tokenId) public view returns (bool) {\n        if (auctions[tokenId].open && \n            (\n                (\n                    block.timestamp >= auctions[tokenId].auctionEnd &&\n                    auctions[tokenId].highestBid > 0 &&\n                    auctions[tokenId].highestBid<auctions[tokenId].reserve\n                ) || \n                getApproved(tokenId) != address(this)\n            )\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/\/ Withdraw a bid when the auction is not finalized\n    function withdraw(uint256 tokenId) external nonReentrant {\n\n        require(canWithdraw(tokenId), \"Conditions to withdraw are not met\");\n\n        \/\/ transfer funds to highest bidder always\n        if (auctions[tokenId].highestBid > 0) {\n            (bool success, ) = auctions[tokenId].highestBidder.call{value: auctions[tokenId].highestBid}(\"\");\n            require(success, \"Transfer failed.\");\n        }\n\n        \/\/ finalize the auction\n        delete auctions[tokenId];\n\n    }\n\n    function canFinalize(uint256 tokenId) public view returns (bool) {\n        if (auctions[tokenId].open && \n            block.timestamp >= auctions[tokenId].auctionEnd &&\n            (\n                auctions[tokenId].highestBid>=auctions[tokenId].reserve || \n                auctions[tokenId].highestBid==0\n            )\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/ implement the auctionFinalize including the NFT transfer logic\n    function auctionFinalize(uint256 tokenId) external nonReentrant {\n\n        require(canFinalize(tokenId), \"Cannot finalize\");\n\n        if (auctions[tokenId].highestBid>0) {\n\n            \/\/ transfer the ownership of token to the highest bidder\n            address payable _highestBidder = auctions[tokenId].highestBidder;\n\n            \/\/ calculate payment amounts\n            uint256 amount4admin = auctions[tokenId].highestBid * commissionRate \/ 100;\n            uint256 amount4owner = auctions[tokenId].highestBid - amount4admin;\n\n            \/\/ to owner\n            (bool success, ) = auctions[tokenId].beneficiary.call{value: amount4owner}(\"\");\n            require(success, \"Transfer failed.\");\n\n            \/\/ to admin\n            (bool success2, ) = admin.call{value:amount4admin}(\"\");\n            require(success2, \"Transfer failed.\");\n\n            emit Sale(tokenId, auctions[tokenId].beneficiary, _highestBidder, auctions[tokenId].highestBid);\n            emit Commission(tokenId, auctions[tokenId].beneficiary, auctions[tokenId].highestBid, commissionRate, amount4admin);\n\n            \/\/ transfer ownership\n            address owner = ownerOf(tokenId);\n\n            \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n            \/\/ transfer the NFT to the auction's highest bidder\n            callOptionalReturn(this, abi.encodeWithSelector(this.transferFrom.selector, owner, _highestBidder, tokenId));\n\n            soldFor[tokenId] = auctions[tokenId].highestBid;\n\n        }\n\n        emit AuctionEnded(auctions[tokenId].highestBidder, auctions[tokenId].highestBid);\n\n        \/\/ finalize the auction\n        delete auctions[tokenId];\n\n    }\n\n    \/\/ Bid query functions\n    function highestBidder(uint256 tokenId) external view returns (address payable) {\n        return auctions[tokenId].highestBidder;\n    }\n\n    function highestBid(uint256 tokenId) external view returns (uint256) {\n        return auctions[tokenId].highestBid;\n    }\n\n    \/**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\/\n    function callOptionalReturn(IERC721 token, bytes memory data) private {\n        \/\/ We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        \/\/ we're implementing it ourselves.\n\n        \/\/ A Solidity high level call has three parts:\n        \/\/  1. The target address is checked to verify it contains contract code\n        \/\/  2. The call itself is made, and success asserted\n        \/\/  3. The return value is decoded, which in turn checks the size of the returned data.\n        \/\/ solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC721: call to non-contract\");\n\n        \/\/ solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC721: low-level call failed\");\n\n        if (returndata.length > 0) { \/\/ Return data is optional\n            \/\/ solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC721: ERC20 operation did not succeed\");\n        }\n    }\n\n    \/\/ update contract fields\n    function updateAdmin(address payable _admin, uint256 _commissionRate, bool _anyoneCanMint) external {\n        require(msg.sender==contract_owner, \"Only contract owner can do this\");\n        require(_commissionRate <= 100, \"Commission rate has to be equal or lower than 100\");\n        admin = _admin;\n        commissionRate = _commissionRate;\n        anyoneCanMint = _anyoneCanMint;\n    }\n    \n    \/\/ update owner\n    function updateOwner(address _contract_owner) external {\n\n        require(msg.sender==contract_owner, \"Only contract owner can do this\");\n\n        \/\/ grant roles to new owner\n        _setupRole(DEFAULT_ADMIN_ROLE, _contract_owner);\n        _setupRole(MINTER_ROLE, _contract_owner);\n\n        \/\/ revoke roles of old owner\n        revokeRole(MINTER_ROLE, contract_owner);\n        revokeRole(DEFAULT_ADMIN_ROLE, contract_owner);\n\n        \/\/ change ownership\n        contract_owner = _contract_owner;\n\n    }\n\n}",
                "contractName":"ERC721Matcha",
                "version": "3.0",
                "compilerVersion":"v0.8.2"
            }
        }
    },
    "ube":{
        "data": {
            "2.0": {
                "abi_factory":[{"inputs":[{"internalType":"contract ERC20","name":"_token","type":"address"},{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"},{"internalType":"uint256","name":"_claimRatio","type":"uint256"},{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"inputs":[],"name":"buyCoffee","outputs":[],"stateMutability":"payable","type":"function","payable":true},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"},{"internalType":"address","name":"from_address","type":"address"}],"name":"buyTea","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"canBuyTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"enableTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getPriceInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"master","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"token","outputs":[{"internalType":"contract ERC20","name":"","type":"address"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[{"internalType":"uint256","name":"_claimRatio","type":"uint256"}],"name":"updateClaimRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_enabled","type":"bool"}],"name":"updateEnabled","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"}],"name":"updateRewardsRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract ERC20","name":"_token","type":"address"}],"name":"updateToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint8","name":"_rate","type":"uint8"},{"internalType":"uint256","name":"_maturity","type":"uint256"},{"internalType":"uint8","name":"_penalization","type":"uint8"},{"internalType":"uint256","name":"_lower","type":"uint256"},{"internalType":"contract ERC20","name":"_erc20","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function","payable":true},{"inputs":[{"internalType":"uint8","name":"_rate","type":"uint8"},{"internalType":"uint256","name":"_maturity","type":"uint256"},{"internalType":"uint8","name":"_penalization","type":"uint8"},{"internalType":"uint256","name":"_lower","type":"uint256"},{"internalType":"contract ERC20","name":"_erc20","type":"address"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source":"\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  Stakes v.2\n    |\n    |----------------------------\n    |\n    |  Flavor\n    |\n    |  >  Ube: Fully featured ERC-20 Staking contract with maturity time \n    |          and an annual interest \n    |\n\n*\/\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\/\nlibrary SafeMath {\n    \/**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     *\/\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \/**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\/\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \/**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\/\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \/**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     *\/\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \/\/ Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        \/\/ benefit is lost if 'b' is also tested.\n        \/\/ See: https:\/\/github.com\/OpenZeppelin\/openzeppelin-contracts\/pull\/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c \/ a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \/**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `\/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\/\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \/**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `\/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\/\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        \/\/ Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a \/ b;\n        \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    \/**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\/\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \/**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\/\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\/**\n * @title Owner\n * @dev Set & change owner\n *\/\ncontract Owner {\n\n    address private owner;\n    \n    \/\/ event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    \/\/ modifier to check if caller is owner\n    modifier isOwner() {\n        \/\/ If the first argument of 'require' evaluates to 'false', execution terminates and all\n        \/\/ changes to the state and to Ether balances are reverted.\n        \/\/ This used to consume all gas in old EVM versions, but not anymore.\n        \/\/ It is often a good idea to use 'require' to check if functions are called correctly.\n        \/\/ As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    \/**\n     * @dev Set contract deployer as owner\n     *\/\n    constructor(address _owner) {\n        owner = _owner;\n        emit OwnerSet(address(0), owner);\n    }\n\n    \/**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     *\/\n    function changeOwner(address newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    \/**\n     * @dev Return owner address \n     * @return address of owner\n     *\/\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n *\/\ninterface IERC20 {\n    \/**\n     * @dev Returns the amount of tokens in existence.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns the amount of tokens owned by `account`.\n     *\/\n    function balanceOf(address account) external view returns (uint256);\n\n    \/**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     *\/\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    \/**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \/**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     *\/\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n *\/\ninterface IERC20Metadata is IERC20 {\n    \/**\n     * @dev Returns the name of the token.\n     *\/\n    function name() external view returns (string memory);\n\n    \/**\n     * @dev Returns the symbol of the token.\n     *\/\n    function symbol() external view returns (string memory);\n\n    \/**\n     * @dev Returns the decimals places of the token.\n     *\/\n    function decimals() external view returns (uint8);\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https:\/\/forum.zeppelin.solutions\/t\/how-to-implement-erc20-supply-mechanisms\/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n *\/\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    \/**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     *\/\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    \/**\n     * @dev Returns the name of the token.\n     *\/\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     *\/\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 \/ 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     *\/\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    \/**\n     * @dev See {IERC20-totalSupply}.\n     *\/\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    \/**\n     * @dev See {IERC20-balanceOf}.\n     *\/\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    \/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     *\/\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    \/**\n     * @dev See {IERC20-allowance}.\n     *\/\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    \/**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     *\/\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    \/**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     *\/\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    \/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     *\/\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    \/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     *\/\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    \/**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     *\/\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    \/** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    \/**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     *\/\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\/\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    \/**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    \/**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\/**\n * \n * Stakes is an interest gain contract for ERC-20 tokens\n * \n * assets is the ERC20 token\n * interest_rate: percentage rate\n * maturity is the time in seconds after which is safe to end the stake\n * penalization for ending a stake before maturity time\n * lower_amount is the minimum amount for creating a stake\n * \n *\/\ncontract Stakes is Owner, ReentrancyGuard {\n\n    using SafeMath for uint256;\n\n    \/\/ token    \n    ERC20 public asset;\n\n    \/\/ stakes history\n    struct Record {\n        uint256 from;\n        uint256 amount;\n        uint256 gain;\n        uint256 penalization;\n        uint256 to;\n        bool ended;\n    }\n\n    \/\/ contract parameters\n    uint8 public interest_rate;\n    uint256 public maturity;\n    uint8 public penalization;\n    uint256 public lower_amount;\n\n    mapping(address => Record[]) public ledger;\n\n    event StakeStart(address indexed user, uint256 value, uint256 index);\n    event StakeEnd(address indexed user, uint256 value, uint256 penalty, uint256 interest, uint256 index);\n    \n    constructor(ERC20 _erc20, address _owner, uint8 _rate, uint256 _maturity, uint8 _penalization, uint256 _lower) Owner(_owner) {\n        require(_penalization<=100, \"Penalty has to be an integer between 0 and 100\");\n        asset = _erc20;\n        interest_rate = _rate;\n        maturity = _maturity;\n        penalization = _penalization;\n        lower_amount = _lower;\n    }\n    \n    function start(uint256 _value) external {\n        require(_value >= lower_amount, \"Invalid value\");\n        asset.transferFrom(msg.sender, address(this), _value);\n        ledger[msg.sender].push(Record(block.timestamp, _value, 0, 0, 0, false));\n        emit StakeStart(msg.sender, _value, ledger[msg.sender].length-1);\n    }\n\n    function end(uint256 i) external nonReentrant {\n\n        require(i < ledger[msg.sender].length, \"Invalid index\");\n        require(ledger[msg.sender][i].ended==false, \"Invalid stake\");\n        \n        \/\/ penalization\n        if(block.timestamp.sub(ledger[msg.sender][i].from) < maturity) {\n            uint256 _penalization = ledger[msg.sender][i].amount.mul(penalization).div(100);\n            asset.transfer(msg.sender, ledger[msg.sender][i].amount.sub(_penalization));\n            asset.transfer(getOwner(), _penalization);\n            ledger[msg.sender][i].penalization = _penalization;\n            ledger[msg.sender][i].to = block.timestamp;\n            ledger[msg.sender][i].ended = true;\n            emit StakeEnd(msg.sender, ledger[msg.sender][i].amount, _penalization, 0, i);\n        \/\/ interest gained\n        } else {\n            uint256 _interest = get_gains(msg.sender, i);\n            \/\/ check that the owner can pay interest before trying to pay\n            if (asset.allowance(getOwner(), address(this)) >= _interest && asset.balanceOf(getOwner()) >= _interest) {\n                asset.transferFrom(getOwner(), msg.sender, _interest);\n            } else {\n                _interest = 0;\n            }\n            asset.transfer(msg.sender, ledger[msg.sender][i].amount);\n            ledger[msg.sender][i].gain = _interest;\n            ledger[msg.sender][i].to = block.timestamp;\n            ledger[msg.sender][i].ended = true;\n            emit StakeEnd(msg.sender, ledger[msg.sender][i].amount, 0, _interest, i);\n        }\n    }\n\n    function set(uint256 _lower, uint256 _maturity, uint8 _rate, uint8 _penalization) public isOwner {\n        require(_penalization<=100, \"Invalid value\");\n        lower_amount = _lower;\n        maturity = _maturity;\n        interest_rate = _rate;\n        penalization = _penalization;\n    }\n    \n    \/\/ calculate interest to the current date time\n    function get_gains(address _address, uint256 _rec_number) public view returns (uint256) {\n        uint256 _record_seconds = block.timestamp.sub(ledger[_address][_rec_number].from);\n        uint256 _year_seconds = 365*24*60*60;\n        return _record_seconds.mul(\n            ledger[_address][_rec_number].amount.mul(interest_rate).div(100)\n        ).div(_year_seconds);\n    }\n\n    function ledger_length(address _address) public view returns (uint256) {\n        return ledger[_address].length;\n    }\n\n}",
                "contractName":"Stakes",
                "compilerVersion":"v0.8.2"
            },
            "3.0": {
                "abi_factory":[{"inputs":[{"internalType":"contract ERC20","name":"_token","type":"address"},{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"},{"internalType":"uint256","name":"_claimRatio","type":"uint256"},{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"inputs":[],"name":"buyCoffee","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"},{"internalType":"address","name":"from_address","type":"address"}],"name":"buyTea","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"canBuyTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint16","name":"_rate","type":"uint16"},{"internalType":"uint256","name":"_maturity","type":"uint256"},{"internalType":"uint8","name":"_penalization","type":"uint8"},{"internalType":"uint256","name":"_lower","type":"uint256"},{"internalType":"contract ERC20","name":"_erc20","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint16","name":"_rate","type":"uint16"},{"internalType":"uint256","name":"_maturity","type":"uint256"},{"internalType":"uint8","name":"_penalization","type":"uint8"},{"internalType":"uint256","name":"_lower","type":"uint256"},{"internalType":"contract ERC20","name":"_erc20","type":"address"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"enableTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getPriceInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"master","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"contract ERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_claimRatio","type":"uint256"}],"name":"updateClaimRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_enabled","type":"bool"}],"name":"updateEnabled","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"}],"name":"updateRewardsRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract ERC20","name":"_token","type":"address"}],"name":"updateToken","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source":"\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  Stakes v.3\n    |\n    |----------------------------\n    |\n    |  Flavor\n    |\n    |  >  Ube: Fully featured ERC-20 Staking contract with maturity time \n    |          and an annual interest \n    |\n\n*\/\n\npragma solidity ^0.8.2;\n\n\/**\n * @title Owner\n * @dev Set & change owner\n *\/\ncontract Owner {\n\n    address private owner;\n    \n    \/\/ event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    \/\/ modifier to check if caller is owner\n    modifier isOwner() {\n        \/\/ If the first argument of 'require' evaluates to 'false', execution terminates and all\n        \/\/ changes to the state and to Ether balances are reverted.\n        \/\/ This used to consume all gas in old EVM versions, but not anymore.\n        \/\/ It is often a good idea to use 'require' to check if functions are called correctly.\n        \/\/ As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    \/**\n     * @dev Set contract deployer as owner\n     *\/\n    constructor(address _owner) {\n        owner = _owner;\n        emit OwnerSet(address(0), owner);\n    }\n\n    \/**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     *\/\n    function changeOwner(address newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    \/**\n     * @dev Return owner address \n     * @return address of owner\n     *\/\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n *\/\ninterface IERC20 {\n    \/**\n     * @dev Returns the amount of tokens in existence.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns the amount of tokens owned by `account`.\n     *\/\n    function balanceOf(address account) external view returns (uint256);\n\n    \/**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     *\/\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    \/**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \/**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     *\/\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n *\/\ninterface IERC20Metadata is IERC20 {\n    \/**\n     * @dev Returns the name of the token.\n     *\/\n    function name() external view returns (string memory);\n\n    \/**\n     * @dev Returns the symbol of the token.\n     *\/\n    function symbol() external view returns (string memory);\n\n    \/**\n     * @dev Returns the decimals places of the token.\n     *\/\n    function decimals() external view returns (uint8);\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https:\/\/forum.zeppelin.solutions\/t\/how-to-implement-erc20-supply-mechanisms\/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n *\/\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    \/**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     *\/\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    \/**\n     * @dev Returns the name of the token.\n     *\/\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     *\/\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 \/ 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     *\/\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    \/**\n     * @dev See {IERC20-totalSupply}.\n     *\/\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    \/**\n     * @dev See {IERC20-balanceOf}.\n     *\/\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    \/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     *\/\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    \/**\n     * @dev See {IERC20-allowance}.\n     *\/\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    \/**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     *\/\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    \/**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     *\/\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    \/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     *\/\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    \/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     *\/\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    \/**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     *\/\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    \/** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    \/**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     *\/\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\/\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    \/**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    \/**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\/**\n * \n * Stakes is an interest gain contract for ERC-20 tokens\n * \n * assets is the ERC20 token\n * interest_rate: percentage rate\n * maturity is the time in seconds after which is safe to end the stake\n * penalization for ending a stake before maturity time\n * lower_amount is the minimum amount for creating a stake\n * \n *\/\ncontract Stakes is Owner, ReentrancyGuard {\n\n    \/\/ token    \n    ERC20 public asset;\n\n    \/\/ stakes history\n    struct Record {\n        uint256 from;\n        uint256 amount;\n        uint256 gain;\n        uint256 penalization;\n        uint256 to;\n        bool ended;\n    }\n\n    \/\/ contract parameters\n    uint16 public interest_rate;\n    uint256 public maturity;\n    uint8 public penalization;\n    uint256 public lower_amount;\n\n    mapping(address => Record[]) public ledger;\n\n    event StakeStart(address indexed user, uint256 value, uint256 index);\n    event StakeEnd(address indexed user, uint256 value, uint256 penalty, uint256 interest, uint256 index);\n    \n    constructor(ERC20 _erc20, address _owner, uint16 _rate, uint256 _maturity, uint8 _penalization, uint256 _lower) Owner(_owner) {\n        require(_penalization<=100, \"Penalty has to be an integer between 0 and 100\");\n        asset = _erc20;\n        interest_rate = _rate;\n        maturity = _maturity;\n        penalization = _penalization;\n        lower_amount = _lower;\n    }\n    \n    function start(uint256 _value) external nonReentrant {\n        require(_value >= lower_amount, \"Invalid value\");\n        require(asset.transferFrom(msg.sender, address(this), _value));\n        ledger[msg.sender].push(Record(block.timestamp, _value, 0, 0, 0, false));\n        emit StakeStart(msg.sender, _value, ledger[msg.sender].length-1);\n    }\n\n    function end(uint256 i) external nonReentrant {\n\n        require(i < ledger[msg.sender].length, \"Invalid index\");\n        require(ledger[msg.sender][i].ended==false, \"Invalid stake\");\n        \n        \/\/ penalization\n        if(block.timestamp - ledger[msg.sender][i].from < maturity) {\n            uint256 _penalization = ledger[msg.sender][i].amount * penalization \/ 100;\n            require(asset.transfer(msg.sender, ledger[msg.sender][i].amount - _penalization));\n            require(asset.transfer(getOwner(), _penalization));\n            ledger[msg.sender][i].penalization = _penalization;\n            ledger[msg.sender][i].to = block.timestamp;\n            ledger[msg.sender][i].ended = true;\n            emit StakeEnd(msg.sender, ledger[msg.sender][i].amount, _penalization, 0, i);\n        \/\/ interest gained\n        } else {\n            uint256 _interest = get_gains(msg.sender, i);\n            \/\/ check that the owner can pay interest before trying to pay\n            if (asset.allowance(getOwner(), address(this)) >= _interest && asset.balanceOf(getOwner()) >= _interest) {\n                require(asset.transferFrom(getOwner(), msg.sender, _interest));\n            } else {\n                _interest = 0;\n            }\n            require(asset.transfer(msg.sender, ledger[msg.sender][i].amount));\n            ledger[msg.sender][i].gain = _interest;\n            ledger[msg.sender][i].to = block.timestamp;\n            ledger[msg.sender][i].ended = true;\n            emit StakeEnd(msg.sender, ledger[msg.sender][i].amount, 0, _interest, i);\n        }\n    }\n\n    function set(uint256 _lower, uint256 _maturity, uint16 _rate, uint8 _penalization) external isOwner {\n        require(_penalization<=100, \"Invalid value\");\n        lower_amount = _lower;\n        maturity = _maturity;\n        interest_rate = _rate;\n        penalization = _penalization;\n    }\n    \n    \/\/ calculate interest to the current date time\n    function get_gains(address _address, uint256 _rec_number) public view returns (uint256) {\n        uint256 _record_seconds = block.timestamp - ledger[_address][_rec_number].from;\n        uint256 _year_seconds = 365*24*60*60;\n        return _record_seconds * ledger[_address][_rec_number].amount * interest_rate \/ 100 \/ _year_seconds;\n    }\n\n    function ledger_length(address _address) external view returns (uint256) {\n        return ledger[_address].length;\n    }\n\n}",
                "contractName":"Stakes",
                "compilerVersion":"v0.8.2"
            },
            "4.0": {
                "abi_factory":[{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint16","name":"_rate","type":"uint16"},{"internalType":"uint256","name":"_maturity","type":"uint256"},{"internalType":"uint8","name":"_penalization","type":"uint8"},{"internalType":"uint256","name":"_lower","type":"uint256"},{"internalType":"contract IERC20","name":"_erc20","type":"address"},{"internalType":"address","name":"_affiliate","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint16","name":"_rate","type":"uint16"},{"internalType":"uint256","name":"_maturity","type":"uint256"},{"internalType":"uint8","name":"_penalization","type":"uint8"},{"internalType":"uint256","name":"_lower","type":"uint256"},{"internalType":"contract IERC20","name":"_erc20","type":"address"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source":"\/\/ SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ncontract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() external virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n *\/\ninterface IERC20 {\n    \/**\n     * @dev Returns the amount of tokens in existence.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns the amount of tokens owned by `account`.\n     *\/\n    function balanceOf(address account) external view returns (uint256);\n\n    \/**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     *\/\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    \/**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \/**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     *\/\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n *\/\ninterface IERC20Metadata is IERC20 {\n    \/**\n     * @dev Returns the name of the token.\n     *\/\n    function name() external view returns (string memory);\n\n    \/**\n     * @dev Returns the symbol of the token.\n     *\/\n    function symbol() external view returns (string memory);\n\n    \/**\n     * @dev Returns the decimals places of the token.\n     *\/\n    function decimals() external view returns (uint8);\n}\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n\/**\n * \n * Ube Stakes v.4\n *\n * Stakes is an interest gain contract for ERC-20 tokens\n * \n * assets is the ERC20 token\n * interest_rate: percentage rate\n * maturity is the time in seconds after which is safe to end the stake\n * penalization for ending a stake before maturity time\n * lower_amount is the minimum amount for creating a stake\n * \n *\/\ncontract Stakes is Ownable, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n\n    \/\/ token    \n    IERC20 public asset;\n\n    \/\/ stakes history\n    struct Record {\n        uint256 from;\n        uint256 amount;\n        uint256 gain;\n        uint256 penalization;\n        uint256 to;\n        bool ended;\n    }\n\n    \/\/ contract parameters\n    uint16 public interest_rate;\n    uint256 public maturity;\n    uint8 public penalization;\n    uint256 public lower_amount;\n\n    mapping(address => Record[]) public ledger;\n\n    event StakeStart(address indexed user, uint256 value, uint256 index);\n    event StakeEnd(address indexed user, uint256 value, uint256 penalty, uint256 interest, uint256 index);\n    \n    event ChangeLowerAmount(uint256 newAmount);\n    event ChangeInterestRate(uint256 newRate);\n\n    constructor(IERC20 _erc20, address _owner, uint16 _rate, uint256 _maturity, uint8 _penalization, uint256 _lower) Ownable() {\n\n        require(_penalization<=100, \"Penalty has to be an integer between 0 and 100\");\n\n        asset = _erc20;\n        interest_rate = _rate;\n        maturity = _maturity;\n        penalization = _penalization;\n        lower_amount = _lower;\n\n        transferOwnership(_owner);\n\n    }\n    \n    function start(uint256 _value) external nonReentrant {\n        require(_value >= lower_amount, \"Invalid value\");\n        ledger[msg.sender].push(Record(block.timestamp, _value, 0, 0, 0, false));\n        emit StakeStart(msg.sender, _value, ledger[msg.sender].length-1);\n        asset.safeTransferFrom(msg.sender, address(this), _value);\n    }\n\n    function end(uint256 i) external nonReentrant {\n\n        require(i < ledger[msg.sender].length, \"Invalid index\");\n        require(!ledger[msg.sender][i].ended, \"Invalid stake\");\n        \n        \/\/ penalization\n        if(block.timestamp - ledger[msg.sender][i].from < maturity) {\n            uint256 _penalization = ledger[msg.sender][i].amount * penalization \/ 100;\n\n            ledger[msg.sender][i].penalization = _penalization;\n            ledger[msg.sender][i].to = block.timestamp;\n            ledger[msg.sender][i].ended = true;\n            emit StakeEnd(msg.sender, ledger[msg.sender][i].amount, _penalization, 0, i);\n\n            asset.safeTransfer(msg.sender, ledger[msg.sender][i].amount - _penalization);\n            asset.safeTransfer(owner(), _penalization);\n\n        \/\/ interest gained\n        } else {\n\n            uint256 _interest = get_gains(msg.sender, i);\n\n            \/\/ check that the owner can pay interest before trying to pay\n            if (asset.allowance(owner(), address(this)) < _interest || asset.balanceOf(owner()) < _interest) {\n                _interest = 0;\n            }\n\n            ledger[msg.sender][i].gain = _interest;\n            ledger[msg.sender][i].to = block.timestamp;\n            ledger[msg.sender][i].ended = true;\n            emit StakeEnd(msg.sender, ledger[msg.sender][i].amount, 0, _interest, i);\n\n            asset.safeTransfer(msg.sender, ledger[msg.sender][i].amount);\n            if(_interest > 0) {\n                asset.safeTransferFrom(owner(), msg.sender, _interest);\n            }\n\n        }\n    }\n\n    function set(uint256 _lower, uint256 _maturity, uint16 _rate, uint8 _penalization) external onlyOwner {\n        require(_penalization<=100, \"Invalid value\");\n\n        emit ChangeLowerAmount(_lower);\n        emit ChangeInterestRate(_rate);\n        \n        lower_amount = _lower;\n        maturity = _maturity;\n        interest_rate = _rate;\n        penalization = _penalization;\n    }\n    \n    \/\/ calculate interest to the current date time\n    function get_gains(address _address, uint256 _rec_number) public view returns (uint256) {\n        uint256 _record_seconds = block.timestamp - ledger[_address][_rec_number].from;\n        uint256 _year_seconds = 365*24*60*60;\n        return _record_seconds * ledger[_address][_rec_number].amount * interest_rate \/ 100 \/ _year_seconds;\n    }\n\n    function ledger_length(address _address) external view returns (uint256) {\n        return ledger[_address].length;\n    }\n\n}",
                "contractName":"Stakes",
                "compilerVersion":"v0.8.2"
            }
        }
    },
    "mochi":{  
        "data": {
            "1.0": {
                "abi_factory":[{"inputs":[{"internalType":"contract ERC20","name":"_token","type":"address"},{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"},{"internalType":"uint256","name":"_claimRatio","type":"uint256"},{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"inputs":[],"name":"buyCoffee","outputs":[],"stateMutability":"payable","type":"function","payable":true},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"},{"internalType":"address","name":"from_address","type":"address"}],"name":"buyTea","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"canBuyTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"enableTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getPriceInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"master","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"token","outputs":[{"internalType":"contract ERC20","name":"","type":"address"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[{"internalType":"uint256","name":"_claimRatio","type":"uint256"}],"name":"updateClaimRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_enabled","type":"bool"}],"name":"updateEnabled","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"}],"name":"updateRewardsRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract ERC20","name":"_token","type":"address"}],"name":"updateToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function","payable":true},{"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source":"\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  ERC-721 NFT Token\n    |\n    |----------------------------\n    |\n    |  Flavors\n    |\n    |  >  Mochi: Standard ERC-721 Token\n    |\n\n*\/\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Required interface of an ERC721 compliant contract.\n *\/\ninterface IERC721 is IERC165 {\n    \/**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    \/**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     *\/\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    \/**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     *\/\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    \/**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     *\/\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    \/**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    \/**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    \/**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address to, uint256 tokenId) external;\n\n    \/**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    \/**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     *\/\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    \/**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     *\/\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n\/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n *\/\ninterface IERC721Receiver {\n    \/**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     *\/\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ninterface IERC721Metadata is IERC721 {\n    \/**\n     * @dev Returns the token collection name.\n     *\/\n    function name() external view returns (string memory);\n\n    \/**\n     * @dev Returns the token collection symbol.\n     *\/\n    function symbol() external view returns (string memory);\n\n    \/**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     *\/\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https:\/\/diligence.consensys.net\/posts\/2019\/09\/stop-using-soliditys-transfer-now\/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https:\/\/solidity.readthedocs.io\/en\/v0.5.11\/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\/\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \/**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https:\/\/solidity.readthedocs.io\/en\/latest\/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     *\/\n    function toString(uint256 value) internal pure returns (string memory) {\n        \/\/ Inspired by OraclizeAPI's implementation - MIT licence\n        \/\/ https:\/\/github.com\/oraclize\/ethereum-api\/blob\/b42146b063c7d6ee1358846c198246239e9360e8\/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp \/= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value \/= 10;\n        }\n        return string(buffer);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     *\/\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev Implementation of https:\/\/eips.ethereum.org\/EIPS\/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n *\/\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    \/\/ Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    \/\/ Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    \/\/ Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    \/\/ Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     *\/\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC721-balanceOf}.\n     *\/\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    \/**\n     * @dev See {IERC721-ownerOf}.\n     *\/\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-name}.\n     *\/\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-symbol}.\n     *\/\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-tokenURI}.\n     *\/\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    \/**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     *\/\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    \/**\n     * @dev See {IERC721-approve}.\n     *\/\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    \/**\n     * @dev See {IERC721-getApproved}.\n     *\/\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    \/**\n     * @dev See {IERC721-setApprovalForAll}.\n     *\/\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    \/**\n     * @dev See {IERC721-isApprovedForAll}.\n     *\/\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    \/**\n     * @dev See {IERC721-transferFrom}.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        \/\/solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    \/**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     *\/\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    \/**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    \/**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     *\/\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    \/**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    \/**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        \/\/ Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    \/**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        \/\/ Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     *\/\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    \/**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     *\/\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ninterface IERC721Enumerable is IERC721 {\n    \/**\n     * @dev Returns the total amount of tokens stored by the contract.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    \/**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     *\/\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n\/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n *\/\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    \/\/ Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    \/\/ Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    \/\/ Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    \/\/ Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     *\/\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     *\/\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     *\/\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     *\/\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     *\/\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        \/\/ To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n        }\n\n        \/\/ This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     *\/\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        \/\/ To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        \/\/ rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        \/\/ an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n\n        \/\/ This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\n\/**\n * @dev ERC721 token with storage based token URI management.\n *\/\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    \/\/ Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    \/**\n     * @dev See {IERC721Metadata-tokenURI}.\n     *\/\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        \/\/ If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        \/\/ If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    \/**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    \/**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n\/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n *\/\nabstract contract ERC721Burnable is Context, ERC721 {\n    \/**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     *\/\n    function burn(uint256 tokenId) public virtual {\n        \/\/solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n *\/\ninterface IAccessControlEnumerable is IAccessControl {\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     *\/\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\/**\n * @dev Library for managing\n * https:\/\/en.wikipedia.org\/wiki\/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     \/\/ Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     \/\/ Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\/\nlibrary EnumerableSet {\n    \/\/ To implement this library for multiple types with as little code\n    \/\/ repetition as possible, we write it in terms of a generic Set type with\n    \/\/ bytes32 values.\n    \/\/ The Set implementation uses private functions, and user-facing\n    \/\/ implementations (such as AddressSet) are just wrappers around the\n    \/\/ underlying Set.\n    \/\/ This means that we can only create new EnumerableSets for types that fit\n    \/\/ in bytes32.\n\n    struct Set {\n        \/\/ Storage of set values\n        bytes32[] _values;\n        \/\/ Position of the value in the `values` array, plus 1 because index 0\n        \/\/ means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            \/\/ The value is stored at length-1, but we add 1 to all indexes\n            \/\/ and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        \/\/ We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            \/\/ Equivalent to contains(set, value)\n            \/\/ To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            \/\/ the array, and then remove the last element (sometimes called as 'swap and pop').\n            \/\/ This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                \/\/ Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                \/\/ Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; \/\/ Replace lastvalue's index to valueIndex\n            }\n\n            \/\/ Delete the slot where the moved value was stored\n            set._values.pop();\n\n            \/\/ Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    \/\/ Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    \/\/ AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    \/\/ UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n\/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n *\/\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    \/**\n     * @dev Overload {grantRole} to track enumerable memberships\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    \/**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n}\n\n\/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n *\/\nlibrary Counters {\n    struct Counter {\n        \/\/ This variable should never be directly accessed by users of the library: interactions must be restricted to\n        \/\/ the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        \/\/ this feature: see https:\/\/github.com\/ethereum\/solidity\/issues\/4637\n        uint256 _value; \/\/ default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n \n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\ncontract ERC721Mochi is ERC721, ERC721Enumerable, ERC721URIStorage, AccessControlEnumerable, ERC721Burnable {\n    using Counters for Counters.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    Counters.Counter private _tokenIdCounter;\n    bool public anyoneCanMint;\n\n    constructor(address owner, string memory name, string memory symbol, bool _anyoneCanMint) ERC721(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(MINTER_ROLE, owner);\n        anyoneCanMint = _anyoneCanMint;\n    }\n\n    function autoMint(string memory _tokenURI, address to) public onlyMinter {\n        uint id;\n        do {\n          _tokenIdCounter.increment();\n          id = _tokenIdCounter.current();\n        } while(_exists(id));\n        _mint(to, id);\n        _setTokenURI(id, _tokenURI);\n    }\n\n    function mint(address to, uint256 tokenId) public onlyMinter {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyMinter {\n        _safeMint(to, tokenId);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    function safeMint(address to, uint256 tokenId, bytes memory _data) public onlyMinter {\n        _safeMint(to, tokenId, _data);\n    }\n\n    function _burn(uint256 tokenId) internal virtual override(ERC721, ERC721URIStorage) {\n        ERC721URIStorage._burn(tokenId);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n        internal\n        override(ERC721, ERC721Enumerable)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable, AccessControlEnumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function addMinter(address account) public onlyRole(MINTER_ROLE) {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function canIMint() public view returns (bool) {\n        return anyoneCanMint || isMinter(msg.sender);\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        string memory mensaje;\n        require(\n            canIMint(),\n            \"MinterRole: caller does not have the Minter role\"\n        );\n        _;\n    }\n\n}",
                "contractName":"ERC721Mochi",
                "version": "1.0",
                "compilerVersion":"v0.8.2"
            },
            "2.0": {
                "abi_factory":[{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"},{"internalType":"address","name":"_affiliate","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source":"\/\/ SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Required interface of an ERC721 compliant contract.\n *\/\ninterface IERC721 is IERC165 {\n    \/**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    \/**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     *\/\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    \/**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     *\/\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    \/**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     *\/\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    \/**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    \/**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    \/**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address to, uint256 tokenId) external;\n\n    \/**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    \/**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     *\/\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    \/**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     *\/\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n\/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n *\/\ninterface IERC721Receiver {\n    \/**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     *\/\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ninterface IERC721Metadata is IERC721 {\n    \/**\n     * @dev Returns the token collection name.\n     *\/\n    function name() external view returns (string memory);\n\n    \/**\n     * @dev Returns the token collection symbol.\n     *\/\n    function symbol() external view returns (string memory);\n\n    \/**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     *\/\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https:\/\/diligence.consensys.net\/posts\/2019\/09\/stop-using-soliditys-transfer-now\/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https:\/\/solidity.readthedocs.io\/en\/v0.5.11\/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\/\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \/**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https:\/\/solidity.readthedocs.io\/en\/latest\/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     *\/\n    function toString(uint256 value) internal pure returns (string memory) {\n        \/\/ Inspired by OraclizeAPI's implementation - MIT licence\n        \/\/ https:\/\/github.com\/oraclize\/ethereum-api\/blob\/b42146b063c7d6ee1358846c198246239e9360e8\/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp \/= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value \/= 10;\n        }\n        return string(buffer);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     *\/\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev Implementation of https:\/\/eips.ethereum.org\/EIPS\/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n *\/\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    \/\/ Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    \/\/ Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    \/\/ Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    \/\/ Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     *\/\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC721-balanceOf}.\n     *\/\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    \/**\n     * @dev See {IERC721-ownerOf}.\n     *\/\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-name}.\n     *\/\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-symbol}.\n     *\/\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-tokenURI}.\n     *\/\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    \/**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     *\/\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    \/**\n     * @dev See {IERC721-approve}.\n     *\/\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    \/**\n     * @dev See {IERC721-getApproved}.\n     *\/\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    \/**\n     * @dev See {IERC721-setApprovalForAll}.\n     *\/\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    \/**\n     * @dev See {IERC721-isApprovedForAll}.\n     *\/\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    \/**\n     * @dev See {IERC721-transferFrom}.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        \/\/solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    \/**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     *\/\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    \/**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    \/**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     *\/\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    \/**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    \/**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        \/\/ Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    \/**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        \/\/ Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     *\/\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    \/**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     *\/\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ninterface IERC721Enumerable is IERC721 {\n    \/**\n     * @dev Returns the total amount of tokens stored by the contract.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    \/**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     *\/\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n\/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n *\/\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    \/\/ Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    \/\/ Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    \/\/ Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    \/\/ Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     *\/\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     *\/\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     *\/\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     *\/\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     *\/\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        \/\/ To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n        }\n\n        \/\/ This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     *\/\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        \/\/ To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        \/\/ rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        \/\/ an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n\n        \/\/ This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\n\/**\n * @dev ERC721 token with storage based token URI management.\n *\/\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    \/\/ Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    \/**\n     * @dev See {IERC721Metadata-tokenURI}.\n     *\/\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        \/\/ If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        \/\/ If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    \/**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    \/**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n\/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n *\/\nabstract contract ERC721Burnable is Context, ERC721 {\n    \/**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     *\/\n    function burn(uint256 tokenId) public virtual {\n        \/\/solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n *\/\ninterface IAccessControlEnumerable is IAccessControl {\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     *\/\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\/**\n * @dev Library for managing\n * https:\/\/en.wikipedia.org\/wiki\/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     \/\/ Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     \/\/ Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\/\nlibrary EnumerableSet {\n    \/\/ To implement this library for multiple types with as little code\n    \/\/ repetition as possible, we write it in terms of a generic Set type with\n    \/\/ bytes32 values.\n    \/\/ The Set implementation uses private functions, and user-facing\n    \/\/ implementations (such as AddressSet) are just wrappers around the\n    \/\/ underlying Set.\n    \/\/ This means that we can only create new EnumerableSets for types that fit\n    \/\/ in bytes32.\n\n    struct Set {\n        \/\/ Storage of set values\n        bytes32[] _values;\n        \/\/ Position of the value in the `values` array, plus 1 because index 0\n        \/\/ means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            \/\/ The value is stored at length-1, but we add 1 to all indexes\n            \/\/ and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        \/\/ We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            \/\/ Equivalent to contains(set, value)\n            \/\/ To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            \/\/ the array, and then remove the last element (sometimes called as 'swap and pop').\n            \/\/ This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                \/\/ Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                \/\/ Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; \/\/ Replace lastvalue's index to valueIndex\n            }\n\n            \/\/ Delete the slot where the moved value was stored\n            set._values.pop();\n\n            \/\/ Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    \/\/ Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    \/\/ AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    \/\/ UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n\/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n *\/\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    \/**\n     * @dev Overload {grantRole} to track enumerable memberships\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    \/**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n}\n\n\/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n *\/\nlibrary Counters {\n    struct Counter {\n        \/\/ This variable should never be directly accessed by users of the library: interactions must be restricted to\n        \/\/ the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        \/\/ this feature: see https:\/\/github.com\/ethereum\/solidity\/issues\/4637\n        uint256 _value; \/\/ default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n \n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n\/**\n * Mochi v.2\n *\/\ncontract ERC721Mochi is ERC721, ERC721Enumerable, ERC721URIStorage, AccessControlEnumerable, ERC721Burnable {\n    using Counters for Counters.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    Counters.Counter private _tokenIdCounter;\n    bool public anyoneCanMint;\n\n    constructor(address owner, string memory name, string memory symbol, bool _anyoneCanMint) ERC721(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(MINTER_ROLE, owner);\n        anyoneCanMint = _anyoneCanMint;\n    }\n\n    function autoMint(string memory _tokenURI, address to) public onlyMinter {\n        uint id;\n        do {\n          _tokenIdCounter.increment();\n          id = _tokenIdCounter.current();\n        } while(_exists(id));\n        _mint(to, id);\n        _setTokenURI(id, _tokenURI);\n    }\n\n    function mint(address to, uint256 tokenId) public onlyMinter {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyMinter {\n        _safeMint(to, tokenId);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    function safeMint(address to, uint256 tokenId, bytes memory _data) public onlyMinter {\n        _safeMint(to, tokenId, _data);\n    }\n\n    function _burn(uint256 tokenId) internal virtual override(ERC721, ERC721URIStorage) {\n        ERC721URIStorage._burn(tokenId);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n        internal\n        override(ERC721, ERC721Enumerable)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable, AccessControlEnumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function addMinter(address account) public onlyRole(MINTER_ROLE) {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function canIMint() public view returns (bool) {\n        return anyoneCanMint || isMinter(msg.sender);\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        string memory mensaje;\n        require(\n            canIMint(),\n            \"MinterRole: caller does not have the Minter role\"\n        );\n        _;\n    }\n\n}",
                "contractName":"ERC721Mochi",
                "version": "2.0",
                "compilerVersion":"v0.8.2"
            }
        }
    },
    "suika":{  
        "data": {
            "2.0": {
                "abi_factory":[{"inputs":[{"internalType":"contract EIP20","name":"_token","type":"address"},{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"},{"internalType":"uint256","name":"_claimRatio","type":"uint256"},{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"inputs":[],"name":"buyCoffee","outputs":[],"stateMutability":"payable","type":"function","payable":true},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"},{"internalType":"address","name":"from_address","type":"address"}],"name":"buyTea","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"canBuyTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"enableTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getPriceInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"master","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[],"name":"token","outputs":[{"internalType":"contract EIP20","name":"","type":"address"}],"stateMutability":"view","type":"function","constant":true},{"inputs":[{"internalType":"uint256","name":"_claimRatio","type":"uint256"}],"name":"updateClaimRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_enabled","type":"bool"}],"name":"updateEnabled","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"}],"name":"updateRewardsRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract EIP20","name":"_token","type":"address"}],"name":"updateToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract EIP20","name":"_payment_token","type":"address"},{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"uint256","name":"_royaltiesCommissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function","payable":true},{"inputs":[{"internalType":"contract EIP20","name":"_payment_token","type":"address"},{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"uint256","name":"_royaltiesCommissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source":"\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  ERC-721 NFT Token Marketplace\n    |\n    |----------------------------\n    |\n    |  Flavors\n    |\n    |  >  Suika v.2: Standard ERC-721 Token with Marketplace\n    |                Supports Payment with Tokens, and royalties\n    |\n\n*\/\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Required interface of an ERC721 compliant contract.\n *\/\ninterface IERC721 is IERC165 {\n    \/**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    \/**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     *\/\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    \/**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     *\/\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    \/**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     *\/\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    \/**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    \/**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    \/**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address to, uint256 tokenId) external;\n\n    \/**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    \/**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     *\/\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    \/**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     *\/\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n\/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n *\/\ninterface IERC721Receiver {\n    \/**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     *\/\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ninterface IERC721Metadata is IERC721 {\n    \/**\n     * @dev Returns the token collection name.\n     *\/\n    function name() external view returns (string memory);\n\n    \/**\n     * @dev Returns the token collection symbol.\n     *\/\n    function symbol() external view returns (string memory);\n\n    \/**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     *\/\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https:\/\/diligence.consensys.net\/posts\/2019\/09\/stop-using-soliditys-transfer-now\/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https:\/\/solidity.readthedocs.io\/en\/v0.5.11\/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\/\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \/**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https:\/\/solidity.readthedocs.io\/en\/latest\/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     *\/\n    function toString(uint256 value) internal pure returns (string memory) {\n        \/\/ Inspired by OraclizeAPI's implementation - MIT licence\n        \/\/ https:\/\/github.com\/oraclize\/ethereum-api\/blob\/b42146b063c7d6ee1358846c198246239e9360e8\/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp \/= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value \/= 10;\n        }\n        return string(buffer);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     *\/\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev Implementation of https:\/\/eips.ethereum.org\/EIPS\/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n *\/\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    \/\/ Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    \/\/ Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    \/\/ Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    \/\/ Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     *\/\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC721-balanceOf}.\n     *\/\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    \/**\n     * @dev See {IERC721-ownerOf}.\n     *\/\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-name}.\n     *\/\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-symbol}.\n     *\/\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-tokenURI}.\n     *\/\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    \/**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     *\/\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    \/**\n     * @dev See {IERC721-approve}.\n     *\/\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    \/**\n     * @dev See {IERC721-getApproved}.\n     *\/\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    \/**\n     * @dev See {IERC721-setApprovalForAll}.\n     *\/\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    \/**\n     * @dev See {IERC721-isApprovedForAll}.\n     *\/\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    \/**\n     * @dev See {IERC721-transferFrom}.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        \/\/solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    \/**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     *\/\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    \/**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    \/**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     *\/\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    \/**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    \/**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        \/\/ Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    \/**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        \/\/ Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     *\/\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    \/**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     *\/\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ninterface IERC721Enumerable is IERC721 {\n    \/**\n     * @dev Returns the total amount of tokens stored by the contract.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    \/**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     *\/\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n\/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n *\/\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    \/\/ Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    \/\/ Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    \/\/ Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    \/\/ Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     *\/\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     *\/\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     *\/\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     *\/\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     *\/\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        \/\/ To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n        }\n\n        \/\/ This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     *\/\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        \/\/ To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        \/\/ rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        \/\/ an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n\n        \/\/ This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\n\/**\n * @dev ERC721 token with storage based token URI management.\n *\/\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    \/\/ Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    \/**\n     * @dev See {IERC721Metadata-tokenURI}.\n     *\/\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        \/\/ If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        \/\/ If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    \/**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    \/**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n\/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n *\/\nabstract contract ERC721Burnable is Context, ERC721 {\n    \/**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     *\/\n    function burn(uint256 tokenId) public virtual {\n        \/\/solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n *\/\ninterface IAccessControlEnumerable is IAccessControl {\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     *\/\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\/**\n * @dev Library for managing\n * https:\/\/en.wikipedia.org\/wiki\/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     \/\/ Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     \/\/ Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\/\nlibrary EnumerableSet {\n    \/\/ To implement this library for multiple types with as little code\n    \/\/ repetition as possible, we write it in terms of a generic Set type with\n    \/\/ bytes32 values.\n    \/\/ The Set implementation uses private functions, and user-facing\n    \/\/ implementations (such as AddressSet) are just wrappers around the\n    \/\/ underlying Set.\n    \/\/ This means that we can only create new EnumerableSets for types that fit\n    \/\/ in bytes32.\n\n    struct Set {\n        \/\/ Storage of set values\n        bytes32[] _values;\n        \/\/ Position of the value in the `values` array, plus 1 because index 0\n        \/\/ means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            \/\/ The value is stored at length-1, but we add 1 to all indexes\n            \/\/ and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        \/\/ We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            \/\/ Equivalent to contains(set, value)\n            \/\/ To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            \/\/ the array, and then remove the last element (sometimes called as 'swap and pop').\n            \/\/ This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                \/\/ Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                \/\/ Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; \/\/ Replace lastvalue's index to valueIndex\n            }\n\n            \/\/ Delete the slot where the moved value was stored\n            set._values.pop();\n\n            \/\/ Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    \/\/ Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    \/\/ AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    \/\/ UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n\/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n *\/\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    \/**\n     * @dev Overload {grantRole} to track enumerable memberships\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    \/**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n}\n\n\/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n *\/\nlibrary Counters {\n    struct Counter {\n        \/\/ This variable should never be directly accessed by users of the library: interactions must be restricted to\n        \/\/ the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        \/\/ this feature: see https:\/\/github.com\/ethereum\/solidity\/issues\/4637\n        uint256 _value; \/\/ default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n \n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\ncontract ERC721Mochi2 is ERC721, ERC721Enumerable, ERC721URIStorage, AccessControlEnumerable, ERC721Burnable {\n    using Counters for Counters.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    Counters.Counter private _tokenIdCounter;\n    bool public anyoneCanMint;\n\n    constructor(address owner, string memory name, string memory symbol, bool _anyoneCanMint) ERC721(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(MINTER_ROLE, owner);\n        anyoneCanMint = _anyoneCanMint;\n    }\n\n    function autoMint(string memory _tokenURI, address to) public onlyMinter {\n        uint id;\n        do {\n          _tokenIdCounter.increment();\n          id = _tokenIdCounter.current();\n        } while(_exists(id));\n        _mint(to, id);\n        _setTokenURI(id, _tokenURI);\n    }\n\n    function mint(address to, uint256 tokenId) public onlyMinter {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyMinter {\n        _safeMint(to, tokenId);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    function safeMint(address to, uint256 tokenId, bytes memory _data) public onlyMinter {\n        _safeMint(to, tokenId, _data);\n    }\n\n    function _burn(uint256 tokenId) internal virtual override(ERC721, ERC721URIStorage) {\n        ERC721URIStorage._burn(tokenId);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n        internal\n        override(ERC721, ERC721Enumerable)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable, AccessControlEnumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function addMinter(address account) public onlyRole(MINTER_ROLE) {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function canIMint() public view returns (bool) {\n        return anyoneCanMint || isMinter(msg.sender);\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        string memory mensaje;\n        require(\n            canIMint(),\n            \"MinterRole: caller does not have the Minter role\"\n        );\n        _;\n    }\n\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/\/ CAUTION\n\/\/ This version of SafeMath should only be used with Solidity 0.8 or later,\n\/\/ because it relies on the compiler's built in overflow checks.\n\n\/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n *\/\nlibrary SafeMath {\n    \/**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     *\/\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    \/**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     *\/\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    \/**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     *\/\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            \/\/ Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            \/\/ benefit is lost if 'b' is also tested.\n            \/\/ See: https:\/\/github.com\/OpenZeppelin\/openzeppelin-contracts\/pull\/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c \/ a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    \/**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     *\/\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a \/ b);\n        }\n    }\n\n    \/**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     *\/\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    \/**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     *\/\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    \/**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     *\/\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    \/**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     *\/\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    \/**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `\/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     *\/\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \/ b;\n    }\n\n    \/**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     *\/\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    \/**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     *\/\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    \/**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `\/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     *\/\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a \/ b;\n        }\n    }\n\n    \/**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     *\/\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n\ncontract EIP20 {\n\n    uint256 public totalSupply;\n\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    \/*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets\/interfaces might not even bother to look at this information.\n    *\/\n    string public name;                   \/\/fancy name: eg Simon Bucks\n    uint8 public decimals;                \/\/How many decimals to show.\n    string public symbol;                 \/\/An identifier: eg SBX\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    constructor(\n        uint256 _initialAmount,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol\n    ) {\n        balances[msg.sender] = _initialAmount;               \/\/ Give the creator all initial tokens\n        totalSupply = _initialAmount;                        \/\/ Update total supply\n        name = _tokenName;                                   \/\/ Set the name for display purposes\n        decimals = _decimalUnits;                            \/\/ Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               \/\/ Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        uint256 _allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && _allowance >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (_allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\/**\n * @title ERC721Suika\n * ERC-721 Marketplace with tokens and royalties support\n *\/\n\ncontract ERC721Suika is ERC721Mochi2, ReentrancyGuard {\n\n    using SafeMath for uint256;\n\n    using Address for address payable;\n    using Address for address;\n\n    \/\/ admin address, the owner of the marketplace\n    address payable admin;\n\n    address public contract_owner;\n\n    \/\/ ERC20 token to be used for payments\n    EIP20 public payment_token;\n\n    \/\/ commission rate is a value from 0 to 100\n    uint256 commissionRate;\n\n    \/\/ royalties commission rate is a value from 0 to 100\n    uint256 royaltiesCommissionRate;\n\n    \/\/ nft item creators list, used to pay royalties\n    mapping(uint256 => address) public creators;\n    \n    \/\/ last price sold or auctioned\n    mapping(uint256 => uint256) public soldFor;\n    \n    \/\/ Mapping from token ID to sell price in Ether or to bid price, depending if it is an auction or not\n    mapping(uint256 => uint256) public sellBidPrice;\n\n    \/\/ Mapping payment address for tokenId \n    mapping(uint256 => address payable) private _wallets;\n\n    event Sale(uint256 indexed tokenId, address indexed from, address indexed to, uint256 value);\n    event Commission(uint256 indexed tokenId, address indexed to, uint256 value, uint256 rate, uint256 total);\n    event Royalty(uint256 indexed tokenId, address indexed to, uint256 value, uint256 rate, uint256 total);\n\n    \/\/ Auction data\n    struct Auction {\n\n        \/\/ Parameters of the auction. Times are either\n        \/\/ absolute unix timestamps (seconds since 1970-01-01)\n        \/\/ or time periods in seconds.\n        address payable beneficiary;\n        uint auctionEnd;\n\n        \/\/ Current state of the auction.\n        address payable highestBidder;\n        uint highestBid;\n\n        \/\/ Set to true at the end, disallows any change\n        bool open;\n\n        \/\/ minimum reserve price in wei\n        uint256 reserve;\n\n    }\n\n    \/\/ mapping auctions for each tokenId\n    mapping(uint256 => Auction) public auctions;\n\n    \/\/ Events that will be fired on changes.\n    event Refund(address bidder, uint amount);\n    event HighestBidIncreased(address indexed bidder, uint amount, uint256 tokenId);\n    event AuctionEnded(address winner, uint amount);\n\n    event LimitSell(address indexed from, address indexed to, uint256 amount);\n    event LimitBuy(address indexed from, address indexed to, uint256 amount);\n    event MarketSell(address indexed from, address indexed to, uint256 amount);\n    event MarketBuy(address indexed from, address indexed to, uint256 amount);\n\n    constructor(\n        EIP20 _payment_token, address _owner, address payable _admin, \n        uint256 _commissionRate, uint256 _royaltiesCommissionRate, string memory name, string memory symbol, bool _anyoneCanMint) \n        ERC721Mochi2(_owner, name, symbol, _anyoneCanMint) \n    {\n        admin = _admin;\n        contract_owner = _owner;\n        require(_commissionRate<=100, \"ERC721Suika: Commission rate has to be between 0 and 100\");\n        commissionRate = _commissionRate;\n        royaltiesCommissionRate = _royaltiesCommissionRate;\n        payment_token = _payment_token;\n    }\n\n    function canSell(uint256 tokenId) public view returns (bool) {\n        return (ownerOf(tokenId)==msg.sender && !auctions[tokenId].open);\n    }\n\n    \/\/ Sell option for a fixed price\n    function sell(uint256 tokenId, uint256 price, address payable wallet) public {\n\n        \/\/ onlyOwner\n        require(ownerOf(tokenId)==msg.sender, \"ERC721Suika: Only owner can sell this item\");\n\n        \/\/ cannot set a price if auction is activated\n        require(!auctions[tokenId].open, \"ERC721Suika: Cannot sell an item which has an active auction\");\n\n        \/\/ set sell price for index\n        sellBidPrice[tokenId] = price;\n\n        \/\/ If price is zero, means not for sale\n        if (price>0) {\n\n            \/\/ approve the Index to the current contract\n            approve(address(this), tokenId);\n            \n            \/\/ set wallet payment\n            _wallets[tokenId] = wallet;\n            \n        }\n\n    }\n\n    \/\/ simple function to return the price of a tokenId\n    \/\/ returns: sell price, bid price, sold price, only one can be non zero\n    function getPrice(uint256 tokenId) public view returns (uint256, uint256, uint256) {\n        if (sellBidPrice[tokenId]>0) return (sellBidPrice[tokenId], 0, 0);\n        if (auctions[tokenId].highestBid>0) return (0, auctions[tokenId].highestBid, 0);\n        return (0, 0, soldFor[tokenId]);\n    }\n\n    function canBuy(uint256 tokenId) public view returns (uint256) {\n        if (!auctions[tokenId].open && sellBidPrice[tokenId]>0 && sellBidPrice[tokenId]>0 && getApproved(tokenId) == address(this)) {\n            return sellBidPrice[tokenId];\n        } else {\n            return 0;\n        }\n    }\n\n    \/\/ Buy option\n    function buy(uint256 tokenId) public nonReentrant {\n\n        \/\/ is on sale\n        require(!auctions[tokenId].open && sellBidPrice[tokenId]>0, \"ERC721Suika: The collectible is not for sale\");\n\n        \/\/ transfer ownership\n        address owner = ownerOf(tokenId);\n\n        require(msg.sender!=owner, \"ERC721Suika: The seller cannot buy his own collectible\");\n\n        \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n        callOptionalReturn(this, abi.encodeWithSelector(this.transferFrom.selector, owner, msg.sender, tokenId));\n\n        \/\/ calculate amounts\n        uint256 amount4admin = sellBidPrice[tokenId].mul(commissionRate).div(100);\n        uint256 amount4creator = sellBidPrice[tokenId].mul(royaltiesCommissionRate).div(100);\n        uint256 amount4owner = sellBidPrice[tokenId].sub(amount4admin).sub(amount4creator);\n\n        \/\/ to owner\n        require(payment_token.transferFrom(msg.sender, _wallets[tokenId], amount4owner), \"Transfer failed.\");\n\n        \/\/ to creator\n        if (amount4creator>0) {\n            require(payment_token.transferFrom(msg.sender, creators[tokenId], amount4creator), \"Transfer failed.\");\n        }\n\n        \/\/ to admin\n        if (amount4admin>0) {\n            require(payment_token.transferFrom(msg.sender, admin, amount4admin), \"Transfer failed.\");\n        }\n\n        emit Sale(tokenId, owner, msg.sender, sellBidPrice[tokenId]);\n        emit Commission(tokenId, owner, sellBidPrice[tokenId], commissionRate, amount4admin);\n        emit Royalty(tokenId, owner, sellBidPrice[tokenId], royaltiesCommissionRate, amount4creator);\n\n        soldFor[tokenId] = sellBidPrice[tokenId];\n\n        \/\/ close the sell\n        sellBidPrice[tokenId] = 0;\n        delete _wallets[tokenId];\n\n    }\n\n    function canAuction(uint256 tokenId) public view returns (bool) {\n        return (ownerOf(tokenId)==msg.sender && !auctions[tokenId].open && sellBidPrice[tokenId]==0);\n    }\n\n    \/\/ Instantiate an auction contract for a tokenId\n    function createAuction(uint256 tokenId, uint _closingTime, address payable _beneficiary, uint256 _reservePrice) public {\n\n        require(sellBidPrice[tokenId]==0, \"ERC721Suika: The selected NFT is open for sale, cannot be auctioned\");\n        require(!auctions[tokenId].open, \"ERC721Suika: The selected NFT already has an auction\");\n        require(ownerOf(tokenId)==msg.sender, \"ERC721Suika: Only owner can auction this item\");\n\n        auctions[tokenId].beneficiary = _beneficiary;\n        auctions[tokenId].auctionEnd = _closingTime;\n        auctions[tokenId].reserve = _reservePrice;\n        auctions[tokenId].open = true;\n\n        \/\/ approve the Index to the current contract\n        approve(address(this), tokenId);\n\n    }\n\n    function canBid(uint256 tokenId) public view returns (bool) {\n        if (!msg.sender.isContract() &&\n            auctions[tokenId].open &&\n            block.timestamp <= auctions[tokenId].auctionEnd &&\n            msg.sender != ownerOf(tokenId) &&\n            getApproved(tokenId) == address(this)\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/\/ Overrides minting function to keep track of item creators\n    function _mint(address to, uint256 tokenId) override internal {\n        creators[tokenId] = msg.sender;\n        super._mint(to, tokenId);\n    }\n\n    \/\/\/ Bid on the auction with the value sent\n    \/\/\/ together with this transaction.\n    \/\/\/ The value will only be refunded if the\n    \/\/\/ auction is not won.\n    function bid(uint256 tokenId, uint256 bid_value) public nonReentrant {\n\n        \/\/ Contracts cannot bid, because they can block the auction with a reentrant attack\n        require(!msg.sender.isContract(), \"No script kiddies\");\n\n        \/\/ auction has to be opened\n        require(auctions[tokenId].open, \"No opened auction found\");\n\n        \/\/ approve was lost\n        require(getApproved(tokenId) == address(this), \"Cannot complete the auction\");\n\n        \/\/ Revert the call if the bidding\n        \/\/ period is over.\n        require(\n            block.timestamp <= auctions[tokenId].auctionEnd,\n            \"Auction already ended.\"\n        );\n\n        \/\/ If the bid is not higher, send the\n        \/\/ money back.\n        require(\n            bid_value > auctions[tokenId].highestBid,\n            \"There already is a higher bid.\"\n        );\n\n        address owner = ownerOf(tokenId);\n        require(msg.sender!=owner, \"ERC721Suika: The owner cannot bid his own collectible\");\n\n        \/\/ return the funds to the previous bidder, if there is one\n        if (auctions[tokenId].highestBid>0) {\n            require(payment_token.transfer(auctions[tokenId].highestBidder, auctions[tokenId].highestBid), \"Transfer failed.\");\n            emit Refund(auctions[tokenId].highestBidder, auctions[tokenId].highestBid);\n        }\n\n        \/\/ now store the bid data\n        auctions[tokenId].highestBidder = payable(msg.sender);\n\n        \/\/ transfer tokens to contract\n        require(payment_token.transferFrom(msg.sender, address(this), bid_value), \"Transfer failed.\");\n\n        \/\/ register the highest bid value\n        auctions[tokenId].highestBid = bid_value;\n\n        emit HighestBidIncreased(msg.sender, bid_value, tokenId);\n\n    }\n\n    \/\/ anyone can execute withdraw if auction is opened and \n    \/\/ the bid time expired and the reserve was not met\n    \/\/ or\n    \/\/ the auction is openen but the contract is unable to transfer\n    function canWithdraw(uint256 tokenId) public view returns (bool) {\n        if (auctions[tokenId].open && \n            (\n                (\n                    block.timestamp >= auctions[tokenId].auctionEnd &&\n                    auctions[tokenId].highestBid > 0 &&\n                    auctions[tokenId].highestBid<auctions[tokenId].reserve\n                ) || \n                getApproved(tokenId) != address(this)\n            )\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/\/ Withdraw a bid when the auction is not finalized\n    function withdraw(uint256 tokenId) public nonReentrant {\n\n        require(canWithdraw(tokenId), \"Conditions to withdraw are not met\");\n\n        \/\/ transfer funds to highest bidder always\n        if (auctions[tokenId].highestBid > 0) {\n            require(payment_token.transfer(auctions[tokenId].highestBidder, auctions[tokenId].highestBid), \"Transfer failed.\");\n        }\n\n        \/\/ finalize the auction\n        delete auctions[tokenId];\n\n    }\n\n    function canFinalize(uint256 tokenId) public view returns (bool) {\n        if (auctions[tokenId].open && \n            block.timestamp >= auctions[tokenId].auctionEnd &&\n            (\n                auctions[tokenId].highestBid>=auctions[tokenId].reserve || \n                auctions[tokenId].highestBid==0\n            )\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/ implement the auctionFinalize including the NFT transfer logic\n    function auctionFinalize(uint256 tokenId) public nonReentrant {\n\n        require(canFinalize(tokenId), \"Cannot finalize\");\n\n        if (auctions[tokenId].highestBid>0) {\n\n            \/\/ transfer the ownership of token to the highest bidder\n            address payable _highestBidder = auctions[tokenId].highestBidder;\n\n            \/\/ calculate payment amounts\n            uint256 amount4admin = auctions[tokenId].highestBid.mul(commissionRate).div(100);\n            uint256 amount4creator = auctions[tokenId].highestBid.mul(royaltiesCommissionRate).div(100);\n            uint256 amount4owner = auctions[tokenId].highestBid.sub(amount4admin).sub(amount4creator);\n\n            \/\/ to owner\n            require(payment_token.transfer(auctions[tokenId].beneficiary, amount4owner), \"Transfer failed.\");\n\n            \/\/ to creator\n            if (amount4creator>0) {\n                require(payment_token.transfer(creators[tokenId], amount4creator), \"Transfer failed.\");\n            }\n\n            \/\/ to admin\n            if (amount4admin>0) {\n                require(payment_token.transfer(admin, amount4admin), \"Transfer failed.\");\n            }\n\n            emit Sale(tokenId, auctions[tokenId].beneficiary, _highestBidder, auctions[tokenId].highestBid);\n            emit Royalty(tokenId, auctions[tokenId].beneficiary, auctions[tokenId].highestBid, royaltiesCommissionRate, amount4creator);\n            emit Commission(tokenId, auctions[tokenId].beneficiary, auctions[tokenId].highestBid, commissionRate, amount4admin);\n\n            \/\/ transfer ownership\n            address owner = ownerOf(tokenId);\n\n            \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n            \/\/ transfer the NFT to the auction's highest bidder\n            callOptionalReturn(this, abi.encodeWithSelector(this.transferFrom.selector, owner, _highestBidder, tokenId));\n\n            soldFor[tokenId] = auctions[tokenId].highestBid;\n\n        }\n\n        emit AuctionEnded(auctions[tokenId].highestBidder, auctions[tokenId].highestBid);\n\n        \/\/ finalize the auction\n        delete auctions[tokenId];\n\n    }\n\n    \/\/ Bid query functions\n    function highestBidder(uint256 tokenId) public view returns (address payable) {\n        return auctions[tokenId].highestBidder;\n    }\n\n    function highestBid(uint256 tokenId) public view returns (uint256) {\n        return auctions[tokenId].highestBid;\n    }\n\n    \/**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\/\n    function callOptionalReturn(IERC721 token, bytes memory data) private {\n        \/\/ We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        \/\/ we're implementing it ourselves.\n\n        \/\/ A Solidity high level call has three parts:\n        \/\/  1. The target address is checked to verify it contains contract code\n        \/\/  2. The call itself is made, and success asserted\n        \/\/  3. The return value is decoded, which in turn checks the size of the returned data.\n        \/\/ solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC721: call to non-contract\");\n\n        \/\/ solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC721: low-level call failed\");\n\n        if (returndata.length > 0) { \/\/ Return data is optional\n            \/\/ solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC721: ERC20 operation did not succeed\");\n        }\n    }\n\n    \/\/ update contract fields\n    function updateAdmin(address payable _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, bool _anyoneCanMint, EIP20 _payment_token) public {\n        require(msg.sender==contract_owner, \"Only contract owner can do this\");\n        admin = _admin;\n        commissionRate = _commissionRate;\n        royaltiesCommissionRate = _royaltiesCommissionRate;\n        anyoneCanMint = _anyoneCanMint;\n        payment_token = _payment_token;\n    }\n    \n    \/\/ update owner\n    function updateOwner(address _contract_owner) public {\n\n        require(msg.sender==contract_owner, \"Only contract owner can do this\");\n\n        \/\/ grant roles to new owner\n        _setupRole(DEFAULT_ADMIN_ROLE, _contract_owner);\n        _setupRole(MINTER_ROLE, _contract_owner);\n\n        \/\/ revoke roles of old owner\n        revokeRole(MINTER_ROLE, contract_owner);\n        _setupRole(DEFAULT_ADMIN_ROLE, contract_owner);\n\n        \/\/ change ownership\n        contract_owner = _contract_owner;\n\n    }\n\n}\n",
                "contractName":"ERC721Suika",
                "version": "2.0",
                "compilerVersion":"v0.8.2"
            },
            "3.0": {
                "abi_factory":[{"inputs":[{"internalType":"contract EIP20","name":"_token","type":"address"},{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"},{"internalType":"uint256","name":"_claimRatio","type":"uint256"},{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"inputs":[],"name":"buyCoffee","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"},{"internalType":"address","name":"from_address","type":"address"}],"name":"buyTea","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"canBuyTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract EIP20","name":"_payment_token","type":"address"},{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"uint256","name":"_royaltiesCommissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"contract EIP20","name":"_payment_token","type":"address"},{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"uint256","name":"_royaltiesCommissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"enableTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getPriceInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"master","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"contract EIP20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_claimRatio","type":"uint256"}],"name":"updateClaimRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_enabled","type":"bool"}],"name":"updateEnabled","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"}],"name":"updateRewardsRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract EIP20","name":"_token","type":"address"}],"name":"updateToken","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source":"\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  ERC-721 NFT Token Marketplace\n    |\n    |----------------------------\n    |\n    |  Flavors\n    |\n    |  >  Suika v.3: Standard ERC-721 Token with Marketplace\n    |                Supports Payment with Tokens, and royalties\n    |\n\n*\/\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Required interface of an ERC721 compliant contract.\n *\/\ninterface IERC721 is IERC165 {\n    \/**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    \/**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     *\/\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    \/**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     *\/\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    \/**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     *\/\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    \/**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    \/**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    \/**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address to, uint256 tokenId) external;\n\n    \/**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    \/**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     *\/\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    \/**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     *\/\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n\/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n *\/\ninterface IERC721Receiver {\n    \/**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     *\/\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ninterface IERC721Metadata is IERC721 {\n    \/**\n     * @dev Returns the token collection name.\n     *\/\n    function name() external view returns (string memory);\n\n    \/**\n     * @dev Returns the token collection symbol.\n     *\/\n    function symbol() external view returns (string memory);\n\n    \/**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     *\/\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https:\/\/diligence.consensys.net\/posts\/2019\/09\/stop-using-soliditys-transfer-now\/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https:\/\/solidity.readthedocs.io\/en\/v0.5.11\/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\/\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \/**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https:\/\/solidity.readthedocs.io\/en\/latest\/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     *\/\n    function toString(uint256 value) internal pure returns (string memory) {\n        \/\/ Inspired by OraclizeAPI's implementation - MIT licence\n        \/\/ https:\/\/github.com\/oraclize\/ethereum-api\/blob\/b42146b063c7d6ee1358846c198246239e9360e8\/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp \/= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value \/= 10;\n        }\n        return string(buffer);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     *\/\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev Implementation of https:\/\/eips.ethereum.org\/EIPS\/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n *\/\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    \/\/ Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    \/\/ Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    \/\/ Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    \/\/ Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     *\/\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC721-balanceOf}.\n     *\/\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    \/**\n     * @dev See {IERC721-ownerOf}.\n     *\/\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-name}.\n     *\/\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-symbol}.\n     *\/\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-tokenURI}.\n     *\/\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    \/**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     *\/\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    \/**\n     * @dev See {IERC721-approve}.\n     *\/\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    \/**\n     * @dev See {IERC721-getApproved}.\n     *\/\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    \/**\n     * @dev See {IERC721-setApprovalForAll}.\n     *\/\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    \/**\n     * @dev See {IERC721-isApprovedForAll}.\n     *\/\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    \/**\n     * @dev See {IERC721-transferFrom}.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        \/\/solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    \/**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     *\/\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    \/**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    \/**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     *\/\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    \/**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    \/**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        \/\/ Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    \/**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        \/\/ Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     *\/\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    \/**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     *\/\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ninterface IERC721Enumerable is IERC721 {\n    \/**\n     * @dev Returns the total amount of tokens stored by the contract.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    \/**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     *\/\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n\/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n *\/\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    \/\/ Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    \/\/ Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    \/\/ Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    \/\/ Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     *\/\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     *\/\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     *\/\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     *\/\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     *\/\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        \/\/ To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n        }\n\n        \/\/ This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     *\/\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        \/\/ To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        \/\/ rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        \/\/ an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n\n        \/\/ This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\n\/**\n * @dev ERC721 token with storage based token URI management.\n *\/\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    \/\/ Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    \/**\n     * @dev See {IERC721Metadata-tokenURI}.\n     *\/\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        \/\/ If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        \/\/ If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    \/**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    \/**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n\/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n *\/\nabstract contract ERC721Burnable is Context, ERC721 {\n    \/**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     *\/\n    function burn(uint256 tokenId) public virtual {\n        \/\/solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n *\/\ninterface IAccessControlEnumerable is IAccessControl {\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     *\/\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\/**\n * @dev Library for managing\n * https:\/\/en.wikipedia.org\/wiki\/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     \/\/ Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     \/\/ Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\/\nlibrary EnumerableSet {\n    \/\/ To implement this library for multiple types with as little code\n    \/\/ repetition as possible, we write it in terms of a generic Set type with\n    \/\/ bytes32 values.\n    \/\/ The Set implementation uses private functions, and user-facing\n    \/\/ implementations (such as AddressSet) are just wrappers around the\n    \/\/ underlying Set.\n    \/\/ This means that we can only create new EnumerableSets for types that fit\n    \/\/ in bytes32.\n\n    struct Set {\n        \/\/ Storage of set values\n        bytes32[] _values;\n        \/\/ Position of the value in the `values` array, plus 1 because index 0\n        \/\/ means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            \/\/ The value is stored at length-1, but we add 1 to all indexes\n            \/\/ and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        \/\/ We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            \/\/ Equivalent to contains(set, value)\n            \/\/ To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            \/\/ the array, and then remove the last element (sometimes called as 'swap and pop').\n            \/\/ This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                \/\/ Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                \/\/ Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; \/\/ Replace lastvalue's index to valueIndex\n            }\n\n            \/\/ Delete the slot where the moved value was stored\n            set._values.pop();\n\n            \/\/ Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    \/\/ Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    \/\/ AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    \/\/ UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n\/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n *\/\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    \/**\n     * @dev Overload {grantRole} to track enumerable memberships\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    \/**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n}\n\n\/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n *\/\nlibrary Counters {\n    struct Counter {\n        \/\/ This variable should never be directly accessed by users of the library: interactions must be restricted to\n        \/\/ the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        \/\/ this feature: see https:\/\/github.com\/ethereum\/solidity\/issues\/4637\n        uint256 _value; \/\/ default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n \n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\ncontract ERC721Mochi is ERC721, ERC721Enumerable, ERC721URIStorage, AccessControlEnumerable, ERC721Burnable {\n    using Counters for Counters.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    Counters.Counter private _tokenIdCounter;\n    bool public anyoneCanMint;\n\n    constructor(address owner, string memory name, string memory symbol, bool _anyoneCanMint) ERC721(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(MINTER_ROLE, owner);\n        anyoneCanMint = _anyoneCanMint;\n    }\n\n    function autoMint(string memory _tokenURI, address to) public onlyMinter {\n        uint id;\n        do {\n          _tokenIdCounter.increment();\n          id = _tokenIdCounter.current();\n        } while(_exists(id));\n        _mint(to, id);\n        _setTokenURI(id, _tokenURI);\n    }\n\n    function mint(address to, uint256 tokenId) public onlyMinter {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyMinter {\n        _safeMint(to, tokenId);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    function safeMint(address to, uint256 tokenId, bytes memory _data) public onlyMinter {\n        _safeMint(to, tokenId, _data);\n    }\n\n    function _burn(uint256 tokenId) internal virtual override(ERC721, ERC721URIStorage) {\n        ERC721URIStorage._burn(tokenId);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n        internal\n        override(ERC721, ERC721Enumerable)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable, AccessControlEnumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function addMinter(address account) public onlyRole(MINTER_ROLE) {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function canIMint() public view returns (bool) {\n        return anyoneCanMint || isMinter(msg.sender);\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        string memory mensaje;\n        require(\n            canIMint(),\n            \"MinterRole: caller does not have the Minter role\"\n        );\n        _;\n    }\n\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\ncontract EIP20 {\n\n    uint256 public totalSupply;\n\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    \/*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets\/interfaces might not even bother to look at this information.\n    *\/\n    string public name;                   \/\/fancy name: eg Simon Bucks\n    uint8 public decimals;                \/\/How many decimals to show.\n    string public symbol;                 \/\/An identifier: eg SBX\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    constructor(\n        uint256 _initialAmount,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol\n    ) {\n        balances[msg.sender] = _initialAmount;               \/\/ Give the creator all initial tokens\n        totalSupply = _initialAmount;                        \/\/ Update total supply\n        name = _tokenName;                                   \/\/ Set the name for display purposes\n        decimals = _decimalUnits;                            \/\/ Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               \/\/ Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        uint256 _allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && _allowance >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (_allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\/**\n * @title ERC721Suika\n * ERC-721 Marketplace with tokens and royalties support\n *\/\n\ncontract ERC721Suika is ERC721Mochi, ReentrancyGuard {\n\n    using Address for address payable;\n    using Address for address;\n\n    \/\/ admin address, the owner of the marketplace\n    address payable admin;\n\n    address public contract_owner;\n\n    \/\/ ERC20 token to be used for payments\n    EIP20 public payment_token;\n\n    \/\/ commission rate is a value from 0 to 100\n    uint256 commissionRate;\n\n    \/\/ royalties commission rate is a value from 0 to 100\n    uint256 royaltiesCommissionRate;\n\n    \/\/ nft item creators list, used to pay royalties\n    mapping(uint256 => address) public creators;\n    \n    \/\/ last price sold or auctioned\n    mapping(uint256 => uint256) public soldFor;\n    \n    \/\/ Mapping from token ID to sell price in Ether or to bid price, depending if it is an auction or not\n    mapping(uint256 => uint256) public sellBidPrice;\n\n    \/\/ Mapping payment address for tokenId \n    mapping(uint256 => address payable) private _wallets;\n\n    event Sale(uint256 indexed tokenId, address indexed from, address indexed to, uint256 value);\n    event Commission(uint256 indexed tokenId, address indexed to, uint256 value, uint256 rate, uint256 total);\n    event Royalty(uint256 indexed tokenId, address indexed to, uint256 value, uint256 rate, uint256 total);\n\n    \/\/ Auction data\n    struct Auction {\n\n        \/\/ Parameters of the auction. Times are either\n        \/\/ absolute unix timestamps (seconds since 1970-01-01)\n        \/\/ or time periods in seconds.\n        address payable beneficiary;\n        uint auctionEnd;\n\n        \/\/ Current state of the auction.\n        address payable highestBidder;\n        uint highestBid;\n\n        \/\/ Set to true at the end, disallows any change\n        bool open;\n\n        \/\/ minimum reserve price in wei\n        uint256 reserve;\n\n    }\n\n    \/\/ mapping auctions for each tokenId\n    mapping(uint256 => Auction) public auctions;\n\n    \/\/ Events that will be fired on changes.\n    event Refund(address bidder, uint amount);\n    event HighestBidIncreased(address indexed bidder, uint amount, uint256 tokenId);\n    event AuctionEnded(address winner, uint amount);\n\n    event LimitSell(address indexed from, address indexed to, uint256 amount);\n    event LimitBuy(address indexed from, address indexed to, uint256 amount);\n    event MarketSell(address indexed from, address indexed to, uint256 amount);\n    event MarketBuy(address indexed from, address indexed to, uint256 amount);\n\n    constructor(\n        EIP20 _payment_token, address _owner, address payable _admin, \n        uint256 _commissionRate, uint256 _royaltiesCommissionRate, string memory name, string memory symbol, bool _anyoneCanMint) \n        ERC721Mochi(_owner, name, symbol, _anyoneCanMint) \n    {\n        admin = _admin;\n        contract_owner = _owner;\n        require(_commissionRate<=100, \"ERC721Suika: Commission rate has to be between 0 and 100\");\n        commissionRate = _commissionRate;\n        royaltiesCommissionRate = _royaltiesCommissionRate;\n        payment_token = _payment_token;\n    }\n\n    function canSell(uint256 tokenId) external view returns (bool) {\n        return (ownerOf(tokenId)==msg.sender && !auctions[tokenId].open);\n    }\n\n    \/\/ Sell option for a fixed price\n    function sell(uint256 tokenId, uint256 price, address payable wallet) external {\n\n        \/\/ onlyOwner\n        require(ownerOf(tokenId)==msg.sender, \"ERC721Suika: Only owner can sell this item\");\n\n        \/\/ cannot set a price if auction is activated\n        require(!auctions[tokenId].open, \"ERC721Suika: Cannot sell an item which has an active auction\");\n\n        \/\/ set sell price for index\n        sellBidPrice[tokenId] = price;\n\n        \/\/ If price is zero, means not for sale\n        if (price>0) {\n\n            \/\/ approve the Index to the current contract\n            approve(address(this), tokenId);\n            \n            \/\/ set wallet payment\n            _wallets[tokenId] = wallet;\n            \n        }\n\n    }\n\n    \/\/ simple function to return the price of a tokenId\n    \/\/ returns: sell price, bid price, sold price, only one can be non zero\n    function getPrice(uint256 tokenId) external view returns (uint256, uint256, uint256) {\n        if (sellBidPrice[tokenId]>0) return (sellBidPrice[tokenId], 0, 0);\n        if (auctions[tokenId].highestBid>0) return (0, auctions[tokenId].highestBid, 0);\n        return (0, 0, soldFor[tokenId]);\n    }\n\n    function canBuy(uint256 tokenId) external view returns (uint256) {\n        if (!auctions[tokenId].open && sellBidPrice[tokenId]>0 && sellBidPrice[tokenId]>0 && getApproved(tokenId) == address(this)) {\n            return sellBidPrice[tokenId];\n        } else {\n            return 0;\n        }\n    }\n\n    \/\/ Buy option\n    function buy(uint256 tokenId) external nonReentrant {\n\n        \/\/ is on sale\n        require(!auctions[tokenId].open && sellBidPrice[tokenId]>0, \"ERC721Suika: The collectible is not for sale\");\n\n        \/\/ transfer ownership\n        address owner = ownerOf(tokenId);\n\n        require(msg.sender!=owner, \"ERC721Suika: The seller cannot buy his own collectible\");\n\n        \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n        callOptionalReturn(this, abi.encodeWithSelector(this.transferFrom.selector, owner, msg.sender, tokenId));\n\n        \/\/ calculate amounts\n        uint256 amount4admin = sellBidPrice[tokenId] * commissionRate \/ 100;\n        uint256 amount4creator = sellBidPrice[tokenId] * royaltiesCommissionRate \/ 100;\n        uint256 amount4owner = sellBidPrice[tokenId] - amount4admin - amount4creator;\n\n        \/\/ to owner\n        require(payment_token.transferFrom(msg.sender, _wallets[tokenId], amount4owner), \"Transfer failed.\");\n\n        \/\/ to creator\n        if (amount4creator>0) {\n            require(payment_token.transferFrom(msg.sender, creators[tokenId], amount4creator), \"Transfer failed.\");\n        }\n\n        \/\/ to admin\n        if (amount4admin>0) {\n            require(payment_token.transferFrom(msg.sender, admin, amount4admin), \"Transfer failed.\");\n        }\n\n        emit Sale(tokenId, owner, msg.sender, sellBidPrice[tokenId]);\n        emit Commission(tokenId, owner, sellBidPrice[tokenId], commissionRate, amount4admin);\n        emit Royalty(tokenId, owner, sellBidPrice[tokenId], royaltiesCommissionRate, amount4creator);\n\n        soldFor[tokenId] = sellBidPrice[tokenId];\n\n        \/\/ close the sell\n        sellBidPrice[tokenId] = 0;\n        delete _wallets[tokenId];\n\n    }\n\n    function canAuction(uint256 tokenId) external view returns (bool) {\n        return (ownerOf(tokenId)==msg.sender && !auctions[tokenId].open && sellBidPrice[tokenId]==0);\n    }\n\n    \/\/ Instantiate an auction contract for a tokenId\n    function createAuction(uint256 tokenId, uint _closingTime, address payable _beneficiary, uint256 _reservePrice) external {\n\n        require(sellBidPrice[tokenId]==0, \"ERC721Suika: The selected NFT is open for sale, cannot be auctioned\");\n        require(!auctions[tokenId].open, \"ERC721Suika: The selected NFT already has an auction\");\n        require(ownerOf(tokenId)==msg.sender, \"ERC721Suika: Only owner can auction this item\");\n\n        auctions[tokenId].beneficiary = _beneficiary;\n        auctions[tokenId].auctionEnd = _closingTime;\n        auctions[tokenId].reserve = _reservePrice;\n        auctions[tokenId].open = true;\n\n        \/\/ approve the Index to the current contract\n        approve(address(this), tokenId);\n\n    }\n\n    function canBid(uint256 tokenId) external view returns (bool) {\n        if (msg.sender == tx.origin &&\n            auctions[tokenId].open &&\n            block.timestamp <= auctions[tokenId].auctionEnd &&\n            msg.sender != ownerOf(tokenId) &&\n            getApproved(tokenId) == address(this)\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/\/ Overrides minting function to keep track of item creators\n    function _mint(address to, uint256 tokenId) override internal {\n        creators[tokenId] = msg.sender;\n        super._mint(to, tokenId);\n    }\n\n    \/\/\/ Bid on the auction with the value sent\n    \/\/\/ together with this transaction.\n    \/\/\/ The value will only be refunded if the\n    \/\/\/ auction is not won.\n    function bid(uint256 tokenId, uint256 bid_value) external nonReentrant {\n\n        \/\/ Contracts cannot bid, because they can block the auction with a reentrant attack\n        require(msg.sender == tx.origin, \"No script kiddies\");\n\n        \/\/ auction has to be opened\n        require(auctions[tokenId].open, \"No opened auction found\");\n\n        \/\/ approve was lost\n        require(getApproved(tokenId) == address(this), \"Cannot complete the auction\");\n\n        \/\/ Revert the call if the bidding\n        \/\/ period is over.\n        require(\n            block.timestamp <= auctions[tokenId].auctionEnd,\n            \"Auction already ended.\"\n        );\n\n        \/\/ If the bid is not higher, send the\n        \/\/ money back.\n        require(\n            bid_value > auctions[tokenId].highestBid,\n            \"There already is a higher bid.\"\n        );\n\n        address owner = ownerOf(tokenId);\n        require(msg.sender!=owner, \"ERC721Suika: The owner cannot bid his own collectible\");\n\n        \/\/ return the funds to the previous bidder, if there is one\n        if (auctions[tokenId].highestBid>0) {\n            require(payment_token.transfer(auctions[tokenId].highestBidder, auctions[tokenId].highestBid), \"Transfer failed.\");\n            emit Refund(auctions[tokenId].highestBidder, auctions[tokenId].highestBid);\n        }\n\n        \/\/ now store the bid data\n        auctions[tokenId].highestBidder = payable(msg.sender);\n\n        \/\/ transfer tokens to contract\n        require(payment_token.transferFrom(msg.sender, address(this), bid_value), \"Transfer failed.\");\n\n        \/\/ register the highest bid value\n        auctions[tokenId].highestBid = bid_value;\n\n        emit HighestBidIncreased(msg.sender, bid_value, tokenId);\n\n    }\n\n    \/\/ anyone can execute withdraw if auction is opened and \n    \/\/ the bid time expired and the reserve was not met\n    \/\/ or\n    \/\/ the auction is openen but the contract is unable to transfer\n    function canWithdraw(uint256 tokenId) public view returns (bool) {\n        if (auctions[tokenId].open && \n            (\n                (\n                    block.timestamp >= auctions[tokenId].auctionEnd &&\n                    auctions[tokenId].highestBid > 0 &&\n                    auctions[tokenId].highestBid<auctions[tokenId].reserve\n                ) || \n                getApproved(tokenId) != address(this)\n            )\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/\/ Withdraw a bid when the auction is not finalized\n    function withdraw(uint256 tokenId) external nonReentrant {\n\n        require(canWithdraw(tokenId), \"Conditions to withdraw are not met\");\n\n        \/\/ transfer funds to highest bidder always\n        if (auctions[tokenId].highestBid > 0) {\n            require(payment_token.transfer(auctions[tokenId].highestBidder, auctions[tokenId].highestBid), \"Transfer failed.\");\n        }\n\n        \/\/ finalize the auction\n        delete auctions[tokenId];\n\n    }\n\n    function canFinalize(uint256 tokenId) public view returns (bool) {\n        if (auctions[tokenId].open && \n            block.timestamp >= auctions[tokenId].auctionEnd &&\n            (\n                auctions[tokenId].highestBid>=auctions[tokenId].reserve || \n                auctions[tokenId].highestBid==0\n            )\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/ implement the auctionFinalize including the NFT transfer logic\n    function auctionFinalize(uint256 tokenId) external nonReentrant {\n\n        require(canFinalize(tokenId), \"Cannot finalize\");\n\n        if (auctions[tokenId].highestBid>0) {\n\n            \/\/ transfer the ownership of token to the highest bidder\n            address payable _highestBidder = auctions[tokenId].highestBidder;\n\n            \/\/ calculate payment amounts\n            uint256 amount4admin = auctions[tokenId].highestBid * commissionRate \/ 100;\n            uint256 amount4creator = auctions[tokenId].highestBid * royaltiesCommissionRate \/ 100;\n            uint256 amount4owner = auctions[tokenId].highestBid- amount4admin - amount4creator;\n\n            \/\/ to owner\n            require(payment_token.transfer(auctions[tokenId].beneficiary, amount4owner), \"Transfer failed.\");\n\n            \/\/ to creator\n            if (amount4creator>0) {\n                require(payment_token.transfer(creators[tokenId], amount4creator), \"Transfer failed.\");\n            }\n\n            \/\/ to admin\n            if (amount4admin>0) {\n                require(payment_token.transfer(admin, amount4admin), \"Transfer failed.\");\n            }\n\n            emit Sale(tokenId, auctions[tokenId].beneficiary, _highestBidder, auctions[tokenId].highestBid);\n            emit Royalty(tokenId, auctions[tokenId].beneficiary, auctions[tokenId].highestBid, royaltiesCommissionRate, amount4creator);\n            emit Commission(tokenId, auctions[tokenId].beneficiary, auctions[tokenId].highestBid, commissionRate, amount4admin);\n\n            \/\/ transfer ownership\n            address owner = ownerOf(tokenId);\n\n            \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n            \/\/ transfer the NFT to the auction's highest bidder\n            callOptionalReturn(this, abi.encodeWithSelector(this.transferFrom.selector, owner, _highestBidder, tokenId));\n\n            soldFor[tokenId] = auctions[tokenId].highestBid;\n\n        }\n\n        emit AuctionEnded(auctions[tokenId].highestBidder, auctions[tokenId].highestBid);\n\n        \/\/ finalize the auction\n        delete auctions[tokenId];\n\n    }\n\n    \/\/ Bid query functions\n    function highestBidder(uint256 tokenId) external view returns (address payable) {\n        return auctions[tokenId].highestBidder;\n    }\n\n    function highestBid(uint256 tokenId) external view returns (uint256) {\n        return auctions[tokenId].highestBid;\n    }\n\n    \/**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\/\n    function callOptionalReturn(IERC721 token, bytes memory data) private {\n        \/\/ We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        \/\/ we're implementing it ourselves.\n\n        \/\/ A Solidity high level call has three parts:\n        \/\/  1. The target address is checked to verify it contains contract code\n        \/\/  2. The call itself is made, and success asserted\n        \/\/  3. The return value is decoded, which in turn checks the size of the returned data.\n        \/\/ solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC721: call to non-contract\");\n\n        \/\/ solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC721: low-level call failed\");\n\n        if (returndata.length > 0) { \/\/ Return data is optional\n            \/\/ solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC721: ERC20 operation did not succeed\");\n        }\n    }\n\n    \/\/ update contract fields\n    function updateAdmin(address payable _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, bool _anyoneCanMint, EIP20 _payment_token) external {\n        require(msg.sender==contract_owner, \"Only contract owner can do this\");\n        require(_commissionRate <= 100, \"Commission rate has to be equal or lower than 100\");\n        require(_royaltiesCommissionRate <= 100, \"Royalties commission rate has to be equal or lower than 100\");\n        require(_commissionRate + _royaltiesCommissionRate <= 100, \"Commision plus royalties has to be equal or lower than 100\");\n        admin = _admin;\n        commissionRate = _commissionRate;\n        royaltiesCommissionRate = _royaltiesCommissionRate;\n        anyoneCanMint = _anyoneCanMint;\n        payment_token = _payment_token;\n    }\n    \n    \/\/ update owner\n    function updateOwner(address _contract_owner) external {\n\n        require(msg.sender==contract_owner, \"Only contract owner can do this\");\n\n        \/\/ grant roles to new owner\n        _setupRole(DEFAULT_ADMIN_ROLE, _contract_owner);\n        _setupRole(MINTER_ROLE, _contract_owner);\n\n        \/\/ revoke roles of old owner\n        revokeRole(MINTER_ROLE, contract_owner);\n        revokeRole(DEFAULT_ADMIN_ROLE, contract_owner);\n\n        \/\/ change ownership\n        contract_owner = _contract_owner;\n\n    }\n\n}",
                "contractName":"ERC721Suika",
                "version": "3.0",
                "compilerVersion":"v0.8.2"
            },
            "4.0": {
                "abi_factory":[{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract EIP20","name":"_paymentToken","type":"address"},{"internalType":"address","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"uint256","name":"_royaltiesCommissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"},{"internalType":"address","name":"_affiliate","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"contract EIP20","name":"_paymentToken","type":"address"},{"internalType":"address","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"uint256","name":"_royaltiesCommissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source":"\/\/ SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Required interface of an ERC721 compliant contract.\n *\/\ninterface IERC721 is IERC165 {\n    \/**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    \/**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     *\/\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    \/**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     *\/\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    \/**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     *\/\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    \/**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    \/**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    \/**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address to, uint256 tokenId) external;\n\n    \/**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    \/**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     *\/\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    \/**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     *\/\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n\/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n *\/\ninterface IERC721Receiver {\n    \/**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     *\/\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ninterface IERC721Metadata is IERC721 {\n    \/**\n     * @dev Returns the token collec(tion name.\n     *\/\n    function name() external view returns (string memory);\n\n    \/**\n     * @dev Returns the token collection symbol.\n     *\/\n    function symbol() external view returns (string memory);\n\n    \/**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     *\/\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https:\/\/solidity.readthedocs.io\/en\/latest\/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     *\/\n    function toString(uint256 value) internal pure returns (string memory) {\n        \/\/ Inspired by OraclizeAPI's implementation - MIT licence\n        \/\/ https:\/\/github.com\/oraclize\/ethereum-api\/blob\/b42146b063c7d6ee1358846c198246239e9360e8\/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp \/= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value \/= 10;\n        }\n        return string(buffer);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev Implementation of https:\/\/eips.ethereum.org\/EIPS\/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n *\/\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    \/\/ Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    \/\/ Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    \/\/ Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    \/\/ Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     *\/\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC721-balanceOf}.\n     *\/\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    \/**\n     * @dev See {IERC721-ownerOf}.\n     *\/\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-name}.\n     *\/\n    function name() external view virtual override returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-symbol}.\n     *\/\n    function symbol() external view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-tokenURI}.\n     *\/\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    \/**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     *\/\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    \/**\n     * @dev See {IERC721-approve}.\n     *\/\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    \/**\n     * @dev See {IERC721-getApproved}.\n     *\/\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    \/**\n     * @dev See {IERC721-setApprovalForAll}.\n     *\/\n    function setApprovalForAll(address operator, bool approved) external virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    \/**\n     * @dev See {IERC721-isApprovedForAll}.\n     *\/\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    \/**\n     * @dev See {IERC721-transferFrom}.\n     *\/\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external virtual override {\n        \/\/solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    \/**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     *\/\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    \/**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    \/**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    \/**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     *\/\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    \/**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    \/**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        \/\/ Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    \/**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        \/\/ Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    \/**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     *\/\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    \/**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     *\/\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n\/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https:\/\/eips.ethereum.org\/EIPS\/eip-721\n *\/\ninterface IERC721Enumerable is IERC721 {\n    \/**\n     * @dev Returns the total amount of tokens stored by the contract.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    \/**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     *\/\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n\/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n *\/\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    \/\/ Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    \/\/ Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    \/\/ Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    \/\/ Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     *\/\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     *\/\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    \/**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     *\/\n    function tokenByIndex(uint256 index) external view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     *\/\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    \/**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     *\/\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     *\/\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        \/\/ To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n        }\n\n        \/\/ This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    \/**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     *\/\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        \/\/ To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        \/\/ then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        \/\/ When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        \/\/ rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        \/\/ an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; \/\/ Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; \/\/ Update the moved token's index\n\n        \/\/ This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\n\/**\n * @dev ERC721 token with storage based token URI management.\n *\/\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    \/\/ Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    \/**\n     * @dev See {IERC721Metadata-tokenURI}.\n     *\/\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        \/\/ If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        \/\/ If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    \/**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    \/**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n\/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n *\/\nabstract contract ERC721Burnable is Context, ERC721 {\n    \/**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     *\/\n    function burn(uint256 tokenId) external virtual {\n        \/\/solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n *\/\ninterface IAccessControlEnumerable is IAccessControl {\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\/**\n * @dev Library for managing\n * https:\/\/en.wikipedia.org\/wiki\/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     \/\/ Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     \/\/ Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\/\nlibrary EnumerableSet {\n    \/\/ To implement this library for multiple types with as little code\n    \/\/ repetition as possible, we write it in terms of a generic Set type with\n    \/\/ bytes32 values.\n    \/\/ The Set implementation uses private functions, and user-facing\n    \/\/ implementations (such as AddressSet) are just wrappers around the\n    \/\/ underlying Set.\n    \/\/ This means that we can only create new EnumerableSets for types that fit\n    \/\/ in bytes32.\n\n    struct Set {\n        \/\/ Storage of set values\n        bytes32[] _values;\n        \/\/ Position of the value in the `values` array, plus 1 because index 0\n        \/\/ means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            \/\/ The value is stored at length-1, but we add 1 to all indexes\n            \/\/ and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        \/\/ We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            \/\/ Equivalent to contains(set, value)\n            \/\/ To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            \/\/ the array, and then remove the last element (sometimes called as 'swap and pop').\n            \/\/ This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                \/\/ Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                \/\/ Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; \/\/ Replace lastvalue's index to valueIndex\n            }\n\n            \/\/ Delete the slot where the moved value was stored\n            set._values.pop();\n\n            \/\/ Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    \/\/ Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    \/\/ AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    \/\/ UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n}\n\n\/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n *\/\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) external view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) external view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    \/**\n     * @dev Overload {grantRole} to track enumerable memberships\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    \/**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n}\n\n\/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n *\/\nlibrary Counters {\n    struct Counter {\n        \/\/ This variable should never be directly accessed by users of the library: interactions must be restricted to\n        \/\/ the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        \/\/ this feature: see https:\/\/github.com\/ethereum\/solidity\/issues\/4637\n        uint256 _value; \/\/ default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n}\n\ncontract ERC721_Mochi is ERC721, ERC721Enumerable, ERC721URIStorage, AccessControlEnumerable, ERC721Burnable {\n    using Counters for Counters.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    Counters.Counter private _tokenIdCounter;\n    bool public anyoneCanMint;\n\n    constructor(address owner, string memory name_, string memory symbol_, bool _anyoneCanMint) ERC721(name_, symbol_) {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(MINTER_ROLE, owner);\n        anyoneCanMint = _anyoneCanMint;\n    }\n\n    function autoMint(string memory _tokenURI, address to) external onlyMinter {\n        uint id;\n        do {\n          _tokenIdCounter.increment();\n          id = _tokenIdCounter.current();\n        } while(_exists(id));\n        _mint(to, id);\n        _setTokenURI(id, _tokenURI);\n    }\n\n    function mint(address to, uint256 tokenId) external onlyMinter {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) external onlyMinter {\n        _safeMint(to, tokenId);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    function safeMint(address to, uint256 tokenId, bytes memory _data) external onlyMinter {\n        _safeMint(to, tokenId, _data);\n    }\n\n    function _burn(uint256 tokenId) internal virtual override(ERC721, ERC721URIStorage) {\n        ERC721URIStorage._burn(tokenId);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n        internal\n        override(ERC721, ERC721Enumerable)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable, AccessControlEnumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function addMinter(address account) external onlyRole(MINTER_ROLE) {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function canIMint() public view returns (bool) {\n        return anyoneCanMint || isMinter(msg.sender);\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        string memory mensaje;\n        require(\n            canIMint(),\n            \"MinterRole: caller does not have the Minter role\"\n        );\n        _;\n    }\n\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\nabstract contract EIP20 {\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {}\n    function transfer(address _to, uint256 _value) external returns (bool success) {}\n}\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        EIP20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        EIP20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function _callOptionalReturn(EIP20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n\/**\n * @title ERC721Suika\n * Suika v4\n * ERC-721 Marketplace with tokens and royalties support\n *\/\ncontract ERC721Suika is ERC721_Mochi, ReentrancyGuard {\n\n    using Address for address;\n    using SafeERC20 for EIP20;\n\n    \/\/ admin address, the owner of the marketplace\n    address public admin;\n\n    address public contract_owner;\n\n    \/\/ ERC20 token to be used for payments\n    EIP20 public payment_token;\n\n    \/\/ commission rate is a value from 0 to 100\n    uint256 public commissionRate;\n\n    \/\/ royalties commission rate is a value from 0 to 100\n    uint256 public royaltiesCommissionRate;\n\n    \/\/ nft item creators list, used to pay royalties\n    mapping(uint256 => address) public creators;\n    \n    \/\/ last price sold or auctioned\n    mapping(uint256 => uint256) public soldFor;\n    \n    \/\/ Mapping from token ID to sell price in Ether or to bid price, depending if it is an auction or not\n    mapping(uint256 => uint256) public sellBidPrice;\n\n    \/\/ Mapping payment address for tokenId \n    mapping(uint256 => address) private _wallets;\n\n    event Sale(uint256 indexed tokenId, address indexed from, address indexed to, uint256 value);\n    event Commission(uint256 indexed tokenId, address indexed to, uint256 value, uint256 rate, uint256 total);\n    event Royalty(uint256 indexed tokenId, address indexed to, uint256 value, uint256 rate, uint256 total);\n\n    \/\/ Auction data\n    struct Auction {\n\n        \/\/ Parameters of the auction. Times are either\n        \/\/ absolute unix timestamps (seconds since 1970-01-01)\n        \/\/ or time periods in seconds.\n        address beneficiary;\n        uint auctionEnd;\n\n        \/\/ Current state of the auction.\n        address highestBidder;\n        uint highestBid;\n\n        \/\/ Set to true at the end, disallows any change\n        bool open;\n\n        \/\/ minimum reserve price in wei\n        uint256 reserve;\n\n    }\n\n    \/\/ mapping auctions for each tokenId\n    mapping(uint256 => Auction) public auctions;\n\n    \/\/ Events that will be fired on changes.\n    event Refund(address bidder, uint amount);\n    event HighestBidIncreased(address indexed bidder, uint amount, uint256 tokenId);\n    event AuctionEnded(address winner, uint amount);\n\n    event LimitSell(address indexed from, address indexed to, uint256 amount);\n    event LimitBuy(address indexed from, address indexed to, uint256 amount);\n    event MarketSell(address indexed from, address indexed to, uint256 amount);\n    event MarketBuy(address indexed from, address indexed to, uint256 amount);\n\n    event ChangeCommissionRate(uint256 newCommission);\n    event ChangeRoyaltiesCommissionRate(uint256 newCommission);\n    \n    constructor(\n        EIP20 paymentToken_, address owner_, address admin_, \n        uint256 commissionRate_, uint256 royaltiesCommissionRate_, string memory name_, string memory symbol_, bool anyoneCanMint_) \n        ERC721_Mochi(owner_, name_, symbol_, anyoneCanMint_) \n    {\n        require(commissionRate_ <= 100, \"ERC721Suika: Commission rate has to be between 0 and 100\");\n        admin = admin_;\n        contract_owner = owner_;\n        commissionRate = commissionRate_;\n        royaltiesCommissionRate = royaltiesCommissionRate_;\n        payment_token = paymentToken_;\n    }\n\n    function canSell(uint256 tokenId) external view returns (bool) {\n        return (ownerOf(tokenId)==msg.sender && !auctions[tokenId].open);\n    }\n\n    \/\/ Sell option for a fixed price\n    function sell(uint256 tokenId, uint256 price, address wallet) external {\n\n        \/\/ onlyOwner\n        require(ownerOf(tokenId)==msg.sender, \"ERC721Suika: Only owner can sell this item\");\n\n        \/\/ cannot set a price if auction is activated\n        require(!auctions[tokenId].open, \"ERC721Suika: Cannot sell an item which has an active auction\");\n\n        \/\/ set sell price for index\n        sellBidPrice[tokenId] = price;\n\n        \/\/ If price is zero, means not for sale\n        if (price>0) {\n\n            \/\/ approve the Index to the current contract\n            approve(address(this), tokenId);\n            \n            \/\/ set wallet payment\n            _wallets[tokenId] = wallet;\n            \n        }\n\n    }\n\n    \/\/ simple function to return the price of a tokenId\n    \/\/ returns: sell price, bid price, sold price, only one can be non zero\n    function getPrice(uint256 tokenId) external view returns (uint256, uint256, uint256) {\n        if (sellBidPrice[tokenId]>0) return (sellBidPrice[tokenId], 0, 0);\n        if (auctions[tokenId].highestBid>0) return (0, auctions[tokenId].highestBid, 0);\n        return (0, 0, soldFor[tokenId]);\n    }\n\n    function canBuy(uint256 tokenId) external view returns (uint256) {\n        if (!auctions[tokenId].open && sellBidPrice[tokenId]>0 && sellBidPrice[tokenId]>0 && getApproved(tokenId) == address(this)) {\n            return sellBidPrice[tokenId];\n        } else {\n            return 0;\n        }\n    }\n\n    \/\/ Buy option\n    function buy(uint256 tokenId) external nonReentrant {\n\n        \/\/ is on sale\n        require(!auctions[tokenId].open && sellBidPrice[tokenId]>0, \"ERC721Suika: The collectible is not for sale\");\n\n        \/\/ transfer ownership\n        address owner = ownerOf(tokenId);\n\n        require(msg.sender!=owner, \"ERC721Suika: The seller cannot buy his own collectible\");\n\n        \/\/ close the sell in anticipation, but keep track of neccesary data\n        uint256 theSellBidPrice = sellBidPrice[tokenId];\n        address theWallet = _wallets[tokenId];\n\n        sellBidPrice[tokenId] = 0;\n        delete _wallets[tokenId];\n\n\n        \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n        callOptionalReturn(this, abi.encodeWithSelector(this.transferFrom.selector, owner, msg.sender, tokenId));\n\n        \/\/ calculate amounts\n        uint256 amount4admin = theSellBidPrice * commissionRate \/ 100;\n        uint256 amount4creator = theSellBidPrice * royaltiesCommissionRate \/ 100;\n        uint256 amount4owner = theSellBidPrice - amount4admin - amount4creator;\n\n        \/\/ to owner\n        payment_token.safeTransferFrom(msg.sender, theWallet, amount4owner);\n\n        \/\/ to creator\n        if (amount4creator>0) {\n            payment_token.safeTransferFrom(msg.sender, creators[tokenId], amount4creator);\n        }\n\n        \/\/ to admin\n        if (amount4admin>0) {\n            payment_token.safeTransferFrom(msg.sender, admin, amount4admin);\n        }\n\n        emit Sale(tokenId, owner, msg.sender, theSellBidPrice);\n        emit Commission(tokenId, owner, theSellBidPrice, commissionRate, amount4admin);\n        emit Royalty(tokenId, owner, theSellBidPrice, royaltiesCommissionRate, amount4creator);\n\n        soldFor[tokenId] = theSellBidPrice;\n\n    }\n\n    function canAuction(uint256 tokenId) external view returns (bool) {\n        return (ownerOf(tokenId)==msg.sender && !auctions[tokenId].open && sellBidPrice[tokenId]==0);\n    }\n\n    \/\/ Instantiate an auction contract for a tokenId\n    function createAuction(uint256 tokenId, uint _closingTime, address _beneficiary, uint256 _reservePrice) external {\n\n        require(sellBidPrice[tokenId]==0, \"ERC721Suika: The selected NFT is open for sale, cannot be auctioned\");\n        require(!auctions[tokenId].open, \"ERC721Suika: The selected NFT already has an auction\");\n        require(ownerOf(tokenId)==msg.sender, \"ERC721Suika: Only owner can auction this item\");\n\n        auctions[tokenId].beneficiary = _beneficiary;\n        auctions[tokenId].auctionEnd = _closingTime;\n        auctions[tokenId].reserve = _reservePrice;\n        auctions[tokenId].open = true;\n\n        \/\/ approve the Index to the current contract\n        approve(address(this), tokenId);\n\n    }\n\n    function canBid(uint256 tokenId) external view returns (bool) {\n        if (msg.sender == tx.origin &&\n            auctions[tokenId].open &&\n            block.timestamp <= auctions[tokenId].auctionEnd &&\n            msg.sender != ownerOf(tokenId) &&\n            getApproved(tokenId) == address(this)\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/\/ Overrides minting function to keep track of item creators\n    function _mint(address to, uint256 tokenId) override internal {\n        creators[tokenId] = msg.sender;\n        super._mint(to, tokenId);\n    }\n\n    \/\/\/ Bid on the auction with the value sent\n    \/\/\/ together with this transaction.\n    \/\/\/ The value will only be refunded if the\n    \/\/\/ auction is not won.\n    function bid(uint256 tokenId, uint256 bid_value) external nonReentrant {\n\n        \/\/ Contracts cannot bid, because they can block the auction with a reentrant attack\n        require(msg.sender == tx.origin, \"No script kiddies\");\n\n        \/\/ auction has to be opened\n        require(auctions[tokenId].open, \"No opened auction found\");\n\n        \/\/ approve was lost\n        require(getApproved(tokenId) == address(this), \"Cannot complete the auction\");\n\n        \/\/ Revert the call if the bidding\n        \/\/ period is over.\n        require(\n            block.timestamp <= auctions[tokenId].auctionEnd,\n            \"Auction already ended.\"\n        );\n\n        \/\/ If the bid is not higher, send the\n        \/\/ money back.\n        require(\n            bid_value > auctions[tokenId].highestBid,\n            \"There already is a higher bid.\"\n        );\n\n        address owner = ownerOf(tokenId);\n        require(msg.sender!=owner, \"ERC721Suika: The owner cannot bid his own collectible\");\n\n        \/\/ keep last bid data\n        address previousBidder = auctions[tokenId].highestBidder;\n        uint256 previousBid = auctions[tokenId].highestBid;\n\n        \/\/ now store the bid data\n        auctions[tokenId].highestBidder = msg.sender;\n        auctions[tokenId].highestBid = bid_value;\n\n        \/\/ return the funds to the previous bidder, if there is one\n        if (previousBid > 0) {\n            payment_token.safeTransfer(previousBidder, previousBid);\n            emit Refund(previousBidder, previousBid);\n        }\n\n        \/\/ transfer tokens to contract\n        payment_token.safeTransferFrom(msg.sender, address(this), bid_value);\n\n        emit HighestBidIncreased(msg.sender, bid_value, tokenId);\n\n    }\n\n    \/\/ anyone can execute withdraw if auction is opened and \n    \/\/ the bid time expired and the reserve was not met\n    \/\/ or\n    \/\/ the auction is openen but the contract is unable to transfer\n    function canWithdraw(uint256 tokenId) public view returns (bool) {\n        if (auctions[tokenId].open && \n            (\n                (\n                    block.timestamp >= auctions[tokenId].auctionEnd &&\n                    auctions[tokenId].highestBid > 0 &&\n                    auctions[tokenId].highestBid<auctions[tokenId].reserve\n                ) || \n                getApproved(tokenId) != address(this)\n            )\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/\/ Withdraw a bid when the auction is not finalized\n    function withdraw(uint256 tokenId) external nonReentrant {\n\n        require(canWithdraw(tokenId), \"Conditions to withdraw are not met\");\n\n        \/\/ finalize the auction, but keep track of the auction\n        Auction memory theAuction = auctions[tokenId];\n        delete auctions[tokenId];\n\n        \/\/ transfer funds to highest bidder always\n        if (theAuction.highestBid > 0) {\n            payment_token.safeTransfer(theAuction.highestBidder, theAuction.highestBid);\n        }\n\n    }\n\n    function canFinalize(uint256 tokenId) public view returns (bool) {\n        if (auctions[tokenId].open && \n            block.timestamp >= auctions[tokenId].auctionEnd &&\n            (\n                auctions[tokenId].highestBid>=auctions[tokenId].reserve || \n                auctions[tokenId].highestBid==0\n            )\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/\/ implement the auctionFinalize including the NFT transfer logic\n    function auctionFinalize(uint256 tokenId) external nonReentrant {\n\n        require(canFinalize(tokenId), \"Cannot finalize\");\n\n        \/\/ store the auction\n        Auction memory theAuction = auctions[tokenId];\n\n        \/\/ finalize the auction\n        delete auctions[tokenId];\n\n        if (theAuction.highestBid>0) {\n\n            \/\/ transfer the ownership of token to the highest bidder\n            address _highestBidder = theAuction.highestBidder;\n\n            \/\/ calculate payment amounts\n            uint256 amount4admin = theAuction.highestBid * commissionRate \/ 100;\n            uint256 amount4creator = theAuction.highestBid * royaltiesCommissionRate \/ 100;\n            uint256 amount4owner = theAuction.highestBid- amount4admin - amount4creator;\n\n            \/\/ to owner\n            payment_token.safeTransfer(theAuction.beneficiary, amount4owner);\n\n            \/\/ to creator\n            if (amount4creator>0) {\n                payment_token.safeTransfer(creators[tokenId], amount4creator);\n            }\n\n            \/\/ to admin\n            if (amount4admin>0) {\n                payment_token.safeTransfer(admin, amount4admin);\n            }\n\n            emit Sale(tokenId, theAuction.beneficiary, _highestBidder, theAuction.highestBid);\n            emit Royalty(tokenId, theAuction.beneficiary, theAuction.highestBid, royaltiesCommissionRate, amount4creator);\n            emit Commission(tokenId, theAuction.beneficiary, theAuction.highestBid, commissionRate, amount4admin);\n\n            \/\/ transfer ownership\n            address owner = ownerOf(tokenId);\n\n            \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n            \/\/ transfer the NFT to the auction's highest bidder\n            callOptionalReturn(this, abi.encodeWithSelector(this.transferFrom.selector, owner, _highestBidder, tokenId));\n\n            soldFor[tokenId] = theAuction.highestBid;\n\n        }\n\n        emit AuctionEnded(theAuction.highestBidder, theAuction.highestBid);\n\n    }\n\n    \/\/ Bid query functions\n    function highestBidder(uint256 tokenId) external view returns (address) {\n        return auctions[tokenId].highestBidder;\n    }\n\n    function highestBid(uint256 tokenId) external view returns (uint256) {\n        return auctions[tokenId].highestBid;\n    }\n\n    \/**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\/\n    function callOptionalReturn(IERC721 token, bytes memory data) private {\n        \/\/ We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        \/\/ we're implementing it ourselves.\n\n        \/\/ A Solidity high level call has three parts:\n        \/\/  1. The target address is checked to verify it contains contract code\n        \/\/  2. The call itself is made, and success asserted\n        \/\/  3. The return value is decoded, which in turn checks the size of the returned data.\n        \/\/ solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC721: call to non-contract\");\n\n        \/\/ solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC721: low-level call failed\");\n\n        if (returndata.length > 0) { \/\/ Return data is optional\n            \/\/ solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC721: ERC20 operation did not succeed\");\n        }\n    }\n\n    \/\/ update contract fields\n    function updateAdmin(address _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, bool _anyoneCanMint, EIP20 _payment_token) external {\n        require(msg.sender==contract_owner, \"Only contract owner can do this\");\n        require(_commissionRate <= 100, \"Commission rate has to be equal or lower than 100\");\n        require(_royaltiesCommissionRate <= 100, \"Royalties commission rate has to be equal or lower than 100\");\n        require(_commissionRate + _royaltiesCommissionRate <= 100, \"Commision plus royalties has to be equal or lower than 100\");\n        admin = _admin;\n        commissionRate = _commissionRate;\n        royaltiesCommissionRate = _royaltiesCommissionRate;\n        anyoneCanMint = _anyoneCanMint;\n        payment_token = _payment_token;\n        emit ChangeCommissionRate(commissionRate);\n        emit ChangeRoyaltiesCommissionRate(royaltiesCommissionRate);\n    }\n    \n    \/\/ update owner\n    function updateOwner(address _contract_owner) external {\n\n        require(msg.sender==contract_owner, \"Only contract owner can do this\");\n\n        \/\/ grant roles to new owner\n        _setupRole(DEFAULT_ADMIN_ROLE, _contract_owner);\n        _setupRole(MINTER_ROLE, _contract_owner);\n\n        \/\/ revoke roles of old owner\n        revokeRole(MINTER_ROLE, contract_owner);\n        revokeRole(DEFAULT_ADMIN_ROLE, contract_owner);\n\n        \/\/ change ownership\n        contract_owner = _contract_owner;\n\n    }\n\n}",
                "contractName":"ERC721Suika",
                "version": "4.0",
                "compilerVersion":"v0.8.2"
            }
        }
    },
    "almond": {
        "data": {
            "1.0": {
                "abi_factory": [{"inputs":[{"internalType":"contract EIP20","name":"_token","type":"address"},{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"},{"internalType":"uint256","name":"_claimRatio","type":"uint256"},{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"inputs":[],"name":"buyCoffee","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"},{"internalType":"address","name":"from_address","type":"address"}],"name":"buyTea","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"canBuyTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint8","name":"_rate","type":"uint8"},{"internalType":"uint8","name":"_rate_2","type":"uint8"},{"internalType":"uint256","name":"_maturity","type":"uint256"},{"internalType":"uint8","name":"_penalization","type":"uint8"},{"internalType":"uint256","name":"_lower","type":"uint256"},{"internalType":"contract EIP20","name":"_erc20","type":"address"},{"internalType":"contract EIP20","name":"_erc20_2","type":"address"},{"internalType":"uint256","name":"_ratio1","type":"uint256"},{"internalType":"uint256","name":"_ratio2","type":"uint256"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint8","name":"_rate","type":"uint8"},{"internalType":"uint8","name":"_rate_2","type":"uint8"},{"internalType":"uint256","name":"_maturity","type":"uint256"},{"internalType":"uint8","name":"_penalization","type":"uint8"},{"internalType":"uint256","name":"_lower","type":"uint256"},{"internalType":"contract EIP20","name":"_erc20","type":"address"},{"internalType":"contract EIP20","name":"_erc20_2","type":"address"},{"internalType":"uint256","name":"_ratio1","type":"uint256"},{"internalType":"uint256","name":"_ratio2","type":"uint256"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"enableTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getPriceInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"master","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"contract EIP20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_claimRatio","type":"uint256"}],"name":"updateClaimRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_enabled","type":"bool"}],"name":"updateEnabled","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"}],"name":"updateRewardsRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract EIP20","name":"_token","type":"address"}],"name":"updateToken","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  Advanced Stakes v.1\n    |\n    |----------------------------\n    |\n    |  Flavor\n    |\n    |  >  Almond: Fully featured ERC-20 Staking contract with maturity \n    |             time an annual interest in a dual token system\n    |\n\n*\/\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\/\n\nlibrary SafeMath {\n    \/**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     *\/\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \/**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\/\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \/**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\/\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \/**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     *\/\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \/\/ Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        \/\/ benefit is lost if 'b' is also tested.\n        \/\/ See: https:\/\/github.com\/OpenZeppelin\/openzeppelin-contracts\/pull\/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c \/ a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \/**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `\/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\/\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \/**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `\/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\/\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        \/\/ Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a \/ b;\n        \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    \/**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\/\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \/**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\/\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\/**\n * @title Owner\n * @dev Set & change owner\n *\/\ncontract Owner {\n\n    address private owner;\n    \n    \/\/ event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    \/\/ modifier to check if caller is owner\n    modifier isOwner() {\n        \/\/ If the first argument of 'require' evaluates to 'false', execution terminates and all\n        \/\/ changes to the state and to Ether balances are reverted.\n        \/\/ This used to consume all gas in old EVM versions, but not anymore.\n        \/\/ It is often a good idea to use 'require' to check if functions are called correctly.\n        \/\/ As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    \/**\n     * @dev Set contract deployer as owner\n     *\/\n    constructor(address _owner) {\n        owner = _owner;\n        emit OwnerSet(address(0), owner);\n    }\n\n    \/**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     *\/\n    function changeOwner(address newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    \/**\n     * @dev Return owner address \n     * @return address of owner\n     *\/\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/\/ Using consensys implementation of ERC-20, because of decimals\n\n\/\/ Abstract contract for the full ERC 20 Token standard\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/blob\/master\/EIPS\/eip-20.md\n\nabstract contract EIP20Interface {\n    \/* This is a slight change to the EIP20 base standard.\n    function totalSupply() constant returns (uint256 supply);\n    is replaced with:\n    uint256 public totalSupply;\n    This automatically creates a getter function for the totalSupply.\n    This is moved to the base contract since public getter functions are not\n    currently recognised as an implementation of the matching abstract\n    function by the compiler.\n    *\/\n    \/\/\/ total amount of tokens\n    uint256 public totalSupply;\n\n    \/\/\/ @param _owner The address from which the balance will be retrieved\n    \/\/\/ @return balance The balance\n    function balanceOf(address _owner) virtual public view returns (uint256 balance);\n\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\n    \/\/\/ @param _to The address of the recipient\n    \/\/\/ @param _value The amount of token to be transferred\n    \/\/\/ @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) virtual public returns (bool success);\n\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    \/\/\/ @param _from The address of the sender\n    \/\/\/ @param _to The address of the recipient\n    \/\/\/ @param _value The amount of token to be transferred\n    \/\/\/ @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool success);\n\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\n    \/\/\/ @param _value The amount of tokens to be approved for transfer\n    \/\/\/ @return success Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) virtual public returns (bool success);\n\n    \/\/\/ @param _owner The address of the account owning tokens\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\n    \/\/\/ @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) virtual public view returns (uint256 remaining);\n\n    \/\/ solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\/*\nImplements EIP20 token standard: https:\/\/github.com\/ethereum\/EIPs\/blob\/master\/EIPS\/eip-20.md\n*\/\n\ncontract EIP20 is EIP20Interface {\n\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    \/*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets\/interfaces might not even bother to look at this information.\n    *\/\n    string public name;                   \/\/fancy name: eg Simon Bucks\n    uint8 public decimals;                \/\/How many decimals to show.\n    string public symbol;                 \/\/An identifier: eg SBX\n\n    constructor(\n        uint256 _initialAmount,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol\n    ) {\n        balances[msg.sender] = _initialAmount;               \/\/ Give the creator all initial tokens\n        totalSupply = _initialAmount;                        \/\/ Update total supply\n        name = _tokenName;                                   \/\/ Set the name for display purposes\n        decimals = _decimalUnits;                            \/\/ Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               \/\/ Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) override public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) override public returns (bool success) {\n        uint256 the_allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && the_allowance >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (the_allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) override public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) override public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) override public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\/**\n * \n * Stakes is an interest gain contract for ERC-20 tokens\n * \n * asset is the EIP20 token to deposit\n * asset2 is the EIP20 token to get interest\n * interest_rate: percentage rate of token1\n * interest_rate2: percentage rate of token2\n * maturity is the time in seconds after which is safe to end the stake\n * penalization for ending a stake before maturity time\n * lower_amount is the minimum amount for creating a stake\n * \n *\/\ncontract StakesAlmond is Owner, ReentrancyGuard {\n\n    using SafeMath for uint256;\n\n    \/\/ token to deposit\n    EIP20 public asset;\n\n    \/\/ token to pay interest\n    EIP20 public asset2;\n\n    \/\/ stakes history\n    struct Record {\n        uint256 from;\n        uint256 amount;\n        uint256 gain;\n        uint256 gain2;\n        uint256 penalization;\n        uint256 to;\n        bool ended;\n    }\n\n    \/\/ contract parameters\n    uint8 public interest_rate;\n    uint8 public interest_rate2;\n    uint256 public maturity;\n    uint8 public penalization;\n    uint256 public lower_amount;\n\n    \/\/ conversion ratio for token1 and token2\n    \/\/ 1:10 ratio will be: \n    \/\/ ratio1 = 1 \n    \/\/ ratio2 = 10\n    uint256 public ratio1;\n    uint256 public ratio2;\n\n    mapping(address => Record[]) public ledger;\n\n    event StakeStart(address indexed user, uint256 value, uint256 index);\n    event StakeEnd(address indexed user, uint256 value, uint256 penalty, uint256 interest, uint256 index);\n    \n    constructor(\n        EIP20 _erc20, EIP20 _erc20_2, address _owner, uint8 _rate, uint8 _rate2, uint256 _maturity, \n        uint8 _penalization, uint256 _lower, uint256 _ratio1, uint256 _ratio2) Owner(_owner) {\n        require(_penalization<=100, \"Penalty has to be an integer between 0 and 100\");\n        asset = _erc20;\n        asset2 = _erc20_2;\n        ratio1 = _ratio1;\n        ratio2 = _ratio2;\n        interest_rate = _rate;\n        interest_rate2 = _rate2;\n        maturity = _maturity;\n        penalization = _penalization;\n        lower_amount = _lower;\n    }\n    \n    function start(uint256 _value) external {\n        require(_value >= lower_amount, \"Invalid value\");\n        asset.transferFrom(msg.sender, address(this), _value);\n        ledger[msg.sender].push(Record(block.timestamp, _value, 0, 0, 0, 0, false));\n        emit StakeStart(msg.sender, _value, ledger[msg.sender].length-1);\n    }\n\n    function end(uint256 i) external nonReentrant {\n\n        require(i < ledger[msg.sender].length, \"Invalid index\");\n        require(ledger[msg.sender][i].ended==false, \"Invalid stake\");\n        \n        \/\/ penalization\n        if(block.timestamp.sub(ledger[msg.sender][i].from) < maturity) {\n\n            uint256 _penalization = ledger[msg.sender][i].amount.mul(penalization).div(100);\n            asset.transfer(msg.sender, ledger[msg.sender][i].amount.sub(_penalization));\n            asset.transfer(getOwner(), _penalization);\n            ledger[msg.sender][i].penalization = _penalization;\n            ledger[msg.sender][i].to = block.timestamp;\n            ledger[msg.sender][i].ended = true;\n            emit StakeEnd(msg.sender, ledger[msg.sender][i].amount, _penalization, 0, i);\n\n        \/\/ interest gained\n        } else {\n            \n            \/\/ interest is calculated in asset2\n            uint256 _interest = get_gains(msg.sender, i);\n\n            \/\/ check that the owner can pay interest before trying to pay, token 1\n            if (_interest>0 && asset.allowance(getOwner(), address(this)) >= _interest && asset.balanceOf(getOwner()) >= _interest) {\n                asset.transferFrom(getOwner(), msg.sender, _interest);\n            } else {\n                _interest = 0;\n            }\n\n            \/\/ interest is calculated in asset2\n            uint256 _interest2 = get_gains2(msg.sender, i);\n\n            \/\/ check that the owner can pay interest before trying to pay, token 1\n            if (_interest2>0 && asset2.allowance(getOwner(), address(this)) >= _interest2 && asset2.balanceOf(getOwner()) >= _interest2) {\n                asset2.transferFrom(getOwner(), msg.sender, _interest2);\n            } else {\n                _interest2 = 0;\n            }\n\n            \/\/ the original asset is returned to the investor\n            asset.transfer(msg.sender, ledger[msg.sender][i].amount);\n            ledger[msg.sender][i].gain = _interest;\n            ledger[msg.sender][i].gain2 = _interest2;\n            ledger[msg.sender][i].to = block.timestamp;\n            ledger[msg.sender][i].ended = true;\n            emit StakeEnd(msg.sender, ledger[msg.sender][i].amount, 0, _interest, i);\n\n        }\n    }\n\n    function set(EIP20 _erc20, EIP20 _erc20_2, uint256 _lower, uint256 _maturity, uint8 _rate, uint8 _rate2, uint8 _penalization, uint256 _ratio1, uint256 _ratio2) public isOwner {\n        require(_penalization<=100, \"Invalid value\");\n        asset = _erc20;\n        asset2 = _erc20_2;\n        ratio1 = _ratio1;\n        ratio2 = _ratio2;\n        lower_amount = _lower;\n        maturity = _maturity;\n        interest_rate = _rate;\n        interest_rate2 = _rate2;\n        penalization = _penalization;\n    }\n\n    \/\/ calculate interest of the token 1 to the current date time\n    function get_gains(address _address, uint256 _rec_number) public view returns (uint256) {\n        uint256 _record_seconds = block.timestamp.sub(ledger[_address][_rec_number].from);\n        uint256 _year_seconds = 365*24*60*60;\n        return _record_seconds.mul(\n            ledger[_address][_rec_number].amount.mul(interest_rate).div(100)\n        ).div(_year_seconds);\n    }\n\n    \/\/ calculate interest to the current date time\n    function get_gains2(address _address, uint256 _rec_number) public view returns (uint256) {\n        uint256 _record_seconds = block.timestamp.sub(ledger[_address][_rec_number].from);\n        uint256 _year_seconds = 365*24*60*60;\n        \/\/ now we calculate the value of the transforming the staked asset (asset) into the asset2\n        \/\/ first we calculate the ratio\n        uint256 value_in_asset2 = ledger[_address][_rec_number].amount.mul(ratio2).div(ratio1);\n        \/\/ now we transform into decimals of the asset2\n        value_in_asset2 = value_in_asset2.mul(10**asset2.decimals()).div(10**asset.decimals());\n        uint256 interest = _record_seconds.mul(\n            value_in_asset2.mul(interest_rate2).div(100)\n        ).div(_year_seconds);\n        \/\/ now lets calculate the interest rate based on the converted value in asset 2\n        return interest;\n    }\n\n    function ledger_length(address _address) public view \n        returns (uint256) {\n        return ledger[_address].length;\n    }\n\n}",
                "contractName": "StakesAlmond",
                "version": "1.0",
                "compilerVersion": "v0.8.2"
            },
            "2.0": {
                "abi_factory": [{"inputs":[{"internalType":"contract EIP20","name":"_token","type":"address"},{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"},{"internalType":"uint256","name":"_claimRatio","type":"uint256"},{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"inputs":[],"name":"buyCoffee","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"},{"internalType":"address","name":"from_address","type":"address"}],"name":"buyTea","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"canBuyTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint16","name":"_rate","type":"uint16"},{"internalType":"uint16","name":"_rate_2","type":"uint16"},{"internalType":"uint256","name":"_maturity","type":"uint256"},{"internalType":"uint8","name":"_penalization","type":"uint8"},{"internalType":"uint256","name":"_lower","type":"uint256"},{"internalType":"contract EIP20","name":"_erc20","type":"address"},{"internalType":"contract EIP20","name":"_erc20_2","type":"address"},{"internalType":"uint256","name":"_ratio1","type":"uint256"},{"internalType":"uint256","name":"_ratio2","type":"uint256"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint16","name":"_rate","type":"uint16"},{"internalType":"uint16","name":"_rate_2","type":"uint16"},{"internalType":"uint256","name":"_maturity","type":"uint256"},{"internalType":"uint8","name":"_penalization","type":"uint8"},{"internalType":"uint256","name":"_lower","type":"uint256"},{"internalType":"contract EIP20","name":"_erc20","type":"address"},{"internalType":"contract EIP20","name":"_erc20_2","type":"address"},{"internalType":"uint256","name":"_ratio1","type":"uint256"},{"internalType":"uint256","name":"_ratio2","type":"uint256"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"enableTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getPriceInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"master","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"contract EIP20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_claimRatio","type":"uint256"}],"name":"updateClaimRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_enabled","type":"bool"}],"name":"updateEnabled","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"}],"name":"updateRewardsRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract EIP20","name":"_token","type":"address"}],"name":"updateToken","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  Advanced Stakes v.2\n    |\n    |----------------------------\n    |\n    |  Flavor\n    |\n    |  >  Almond: Fully featured ERC-20 Staking contract with maturity \n    |             time an annual interest in a dual token system\n    |\n\n*\/\n\npragma solidity ^0.8.2;\n\n\/**\n * @title Owner\n * @dev Set & change owner\n *\/\ncontract Owner {\n\n    address private owner;\n    \n    \/\/ event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    \/\/ modifier to check if caller is owner\n    modifier isOwner() {\n        \/\/ If the first argument of 'require' evaluates to 'false', execution terminates and all\n        \/\/ changes to the state and to Ether balances are reverted.\n        \/\/ This used to consume all gas in old EVM versions, but not anymore.\n        \/\/ It is often a good idea to use 'require' to check if functions are called correctly.\n        \/\/ As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    \/**\n     * @dev Set contract deployer as owner\n     *\/\n    constructor(address _owner) {\n        owner = _owner;\n        emit OwnerSet(address(0), owner);\n    }\n\n    \/**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     *\/\n    function changeOwner(address newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    \/**\n     * @dev Return owner address \n     * @return address of owner\n     *\/\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/\/ Using consensys implementation of ERC-20, because of decimals\n\n\/\/ Abstract contract for the full ERC 20 Token standard\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/blob\/master\/EIPS\/eip-20.md\n\nabstract contract EIP20Interface {\n    \/* This is a slight change to the EIP20 base standard.\n    function totalSupply() constant returns (uint256 supply);\n    is replaced with:\n    uint256 public totalSupply;\n    This automatically creates a getter function for the totalSupply.\n    This is moved to the base contract since public getter functions are not\n    currently recognised as an implementation of the matching abstract\n    function by the compiler.\n    *\/\n    \/\/\/ total amount of tokens\n    uint256 public totalSupply;\n\n    \/\/\/ @param _owner The address from which the balance will be retrieved\n    \/\/\/ @return balance The balance\n    function balanceOf(address _owner) virtual public view returns (uint256 balance);\n\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\n    \/\/\/ @param _to The address of the recipient\n    \/\/\/ @param _value The amount of token to be transferred\n    \/\/\/ @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) virtual public returns (bool success);\n\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    \/\/\/ @param _from The address of the sender\n    \/\/\/ @param _to The address of the recipient\n    \/\/\/ @param _value The amount of token to be transferred\n    \/\/\/ @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool success);\n\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\n    \/\/\/ @param _value The amount of tokens to be approved for transfer\n    \/\/\/ @return success Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) virtual public returns (bool success);\n\n    \/\/\/ @param _owner The address of the account owning tokens\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\n    \/\/\/ @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) virtual public view returns (uint256 remaining);\n\n    \/\/ solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\/*\nImplements EIP20 token standard: https:\/\/github.com\/ethereum\/EIPs\/blob\/master\/EIPS\/eip-20.md\n*\/\n\ncontract EIP20 is EIP20Interface {\n\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    \/*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets\/interfaces might not even bother to look at this information.\n    *\/\n    string public name;                   \/\/fancy name: eg Simon Bucks\n    uint8 public decimals;                \/\/How many decimals to show.\n    string public symbol;                 \/\/An identifier: eg SBX\n\n    constructor(\n        uint256 _initialAmount,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol\n    ) {\n        balances[msg.sender] = _initialAmount;               \/\/ Give the creator all initial tokens\n        totalSupply = _initialAmount;                        \/\/ Update total supply\n        name = _tokenName;                                   \/\/ Set the name for display purposes\n        decimals = _decimalUnits;                            \/\/ Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               \/\/ Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) override public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) override public returns (bool success) {\n        uint256 the_allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && the_allowance >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (the_allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) override public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) override public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); \/\/solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) override public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\/**\n * \n * Stakes is an interest gain contract for ERC-20 tokens\n * \n * asset is the EIP20 token to deposit\n * asset2 is the EIP20 token to get interest\n * interest_rate: percentage rate of token1\n * interest_rate2: percentage rate of token2\n * maturity is the time in seconds after which is safe to end the stake\n * penalization for ending a stake before maturity time\n * lower_amount is the minimum amount for creating a stake\n * \n *\/\ncontract StakesAlmond is Owner, ReentrancyGuard {\n\n    \/\/ token to deposit\n    EIP20 public asset;\n\n    \/\/ token to pay interest\n    EIP20 public asset2;\n\n    \/\/ stakes history\n    struct Record {\n        uint256 from;\n        uint256 amount;\n        uint256 gain;\n        uint256 gain2;\n        uint256 penalization;\n        uint256 to;\n        bool ended;\n    }\n\n    \/\/ contract parameters\n    uint16 public interest_rate;\n    uint16 public interest_rate2;\n    uint256 public maturity;\n    uint8 public penalization;\n    uint256 public lower_amount;\n\n    \/\/ conversion ratio for token1 and token2\n    \/\/ 1:10 ratio will be: \n    \/\/ ratio1 = 1 \n    \/\/ ratio2 = 10\n    uint256 public ratio1;\n    uint256 public ratio2;\n\n    mapping(address => Record[]) public ledger;\n\n    event StakeStart(address indexed user, uint256 value, uint256 index);\n    event StakeEnd(address indexed user, uint256 value, uint256 penalty, uint256 interest, uint256 index);\n    \n    constructor(\n        EIP20 _erc20, EIP20 _erc20_2, address _owner, uint16 _rate, uint16 _rate2, uint256 _maturity, \n        uint8 _penalization, uint256 _lower, uint256 _ratio1, uint256 _ratio2) Owner(_owner) {\n        require(_penalization<=100, \"Penalty has to be an integer between 0 and 100\");\n        asset = _erc20;\n        asset2 = _erc20_2;\n        ratio1 = _ratio1;\n        ratio2 = _ratio2;\n        interest_rate = _rate;\n        interest_rate2 = _rate2;\n        maturity = _maturity;\n        penalization = _penalization;\n        lower_amount = _lower;\n    }\n    \n    function start(uint256 _value) external nonReentrant {\n        require(_value >= lower_amount, \"Invalid value\");\n        require(asset.transferFrom(msg.sender, address(this), _value));\n        ledger[msg.sender].push(Record(block.timestamp, _value, 0, 0, 0, 0, false));\n        emit StakeStart(msg.sender, _value, ledger[msg.sender].length-1);\n    }\n\n    function end(uint256 i) external nonReentrant {\n\n        require(i < ledger[msg.sender].length, \"Invalid index\");\n        require(ledger[msg.sender][i].ended==false, \"Invalid stake\");\n        \n        \/\/ penalization\n        if(block.timestamp - ledger[msg.sender][i].from < maturity) {\n\n            uint256 _penalization = ledger[msg.sender][i].amount * penalization \/ 100;\n            require(asset.transfer(msg.sender, ledger[msg.sender][i].amount - _penalization));\n            require(asset.transfer(getOwner(), _penalization));\n            ledger[msg.sender][i].penalization = _penalization;\n            ledger[msg.sender][i].to = block.timestamp;\n            ledger[msg.sender][i].ended = true;\n            emit StakeEnd(msg.sender, ledger[msg.sender][i].amount, _penalization, 0, i);\n\n        \/\/ interest gained\n        } else {\n            \n            \/\/ interest is calculated in asset2\n            uint256 _interest = get_gains(msg.sender, i);\n\n            \/\/ check that the owner can pay interest before trying to pay, token 1\n            if (_interest>0 && asset.allowance(getOwner(), address(this)) >= _interest && asset.balanceOf(getOwner()) >= _interest) {\n                require(asset.transferFrom(getOwner(), msg.sender, _interest));\n            } else {\n                _interest = 0;\n            }\n\n            \/\/ interest is calculated in asset2\n            uint256 _interest2 = get_gains2(msg.sender, i);\n\n            \/\/ check that the owner can pay interest before trying to pay, token 1\n            if (_interest2>0 && asset2.allowance(getOwner(), address(this)) >= _interest2 && asset2.balanceOf(getOwner()) >= _interest2) {\n                require(asset2.transferFrom(getOwner(), msg.sender, _interest2));\n            } else {\n                _interest2 = 0;\n            }\n\n            \/\/ the original asset is returned to the investor\n            require(asset.transfer(msg.sender, ledger[msg.sender][i].amount));\n            ledger[msg.sender][i].gain = _interest;\n            ledger[msg.sender][i].gain2 = _interest2;\n            ledger[msg.sender][i].to = block.timestamp;\n            ledger[msg.sender][i].ended = true;\n            emit StakeEnd(msg.sender, ledger[msg.sender][i].amount, 0, _interest, i);\n\n        }\n    }\n\n    function set(EIP20 _erc20, EIP20 _erc20_2, uint256 _lower, uint256 _maturity, uint16 _rate, uint16 _rate2, uint8 _penalization, uint256 _ratio1, uint256 _ratio2) external isOwner {\n        require(_penalization<=100, \"Invalid value\");\n        asset = _erc20;\n        asset2 = _erc20_2;\n        ratio1 = _ratio1;\n        ratio2 = _ratio2;\n        lower_amount = _lower;\n        maturity = _maturity;\n        interest_rate = _rate;\n        interest_rate2 = _rate2;\n        penalization = _penalization;\n    }\n\n    \/\/ calculate interest of the token 1 to the current date time\n    function get_gains(address _address, uint256 _rec_number) public view returns (uint256) {\n        uint256 _record_seconds = block.timestamp - ledger[_address][_rec_number].from;\n        uint256 _year_seconds = 365*24*60*60;\n        return _record_seconds * \n            ledger[_address][_rec_number].amount * interest_rate \/ 100\n        \/ _year_seconds;\n    }\n\n    \/\/ calculate interest to the current date time\n    function get_gains2(address _address, uint256 _rec_number) public view returns (uint256) {\n        uint256 _record_seconds = block.timestamp - ledger[_address][_rec_number].from;\n        uint256 _year_seconds = 365*24*60*60;\n        \n        \/**\n         *\n         * Oririginal code:\n         * \n         *   \/\/ now we calculate the value of the transforming the staked asset (asset) into the asset2\n         *   \/\/ first we calculate the ratio\n         *   uint256 value_in_asset2 = ledger[_address][_rec_number].amount * ratio2 \/ ratio1;\n         *   \/\/ now we transform into decimals of the asset2\n         *   value_in_asset2 = value_in_asset2 * 10**asset2.decimals() \/ 10**asset.decimals();\n         *   uint256 interest = _record_seconds * value_in_asset2 * interest_rate2 \/ 100 \/ _year_seconds;\n         *   \/\/ now lets calculate the interest rate based on the converted value in asset 2\n         *\n         * Simplified into:\n         * \n         *\/\n\n        return (_record_seconds * ledger[_address][_rec_number].amount * ratio2 * 10**asset2.decimals() * interest_rate2) \/ \n               (ratio1 * 10**asset.decimals() * 100 * _year_seconds);\n\n    }\n\n    function ledger_length(address _address) external view \n        returns (uint256) {\n        return ledger[_address].length;\n    }\n\n}",
                "contractName": "StakesAlmond",
                "version": "2.0",
                "compilerVersion": "v0.8.2"
            },
            "3.0": {
                "abi_factory": [{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint16","name":"_rate","type":"uint16"},{"internalType":"uint16","name":"_rate_2","type":"uint16"},{"internalType":"uint256","name":"_maturity","type":"uint256"},{"internalType":"uint8","name":"_penalization","type":"uint8"},{"internalType":"uint256","name":"_lower","type":"uint256"},{"internalType":"contract ERC20","name":"_erc20","type":"address"},{"internalType":"contract ERC20","name":"_erc20_2","type":"address"},{"internalType":"uint256","name":"_ratio1","type":"uint256"},{"internalType":"uint256","name":"_ratio2","type":"uint256"},{"internalType":"address","name":"_affiliate","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint16","name":"_rate","type":"uint16"},{"internalType":"uint16","name":"_rate_2","type":"uint16"},{"internalType":"uint256","name":"_maturity","type":"uint256"},{"internalType":"uint8","name":"_penalization","type":"uint8"},{"internalType":"uint256","name":"_lower","type":"uint256"},{"internalType":"contract ERC20","name":"_erc20","type":"address"},{"internalType":"contract ERC20","name":"_erc20_2","type":"address"},{"internalType":"uint256","name":"_ratio1","type":"uint256"},{"internalType":"uint256","name":"_ratio2","type":"uint256"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\n\/**\n * @title Owner\n * @dev Set & change owner\n *\/\ncontract Owner {\n\n    address private owner;\n    \n    \/\/ event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    \/\/ modifier to check if caller is owner\n    modifier isOwner() {\n        \/\/ If the first argument of 'require' evaluates to 'false', execution terminates and all\n        \/\/ changes to the state and to Ether balances are reverted.\n        \/\/ This used to consume all gas in old EVM versions, but not anymore.\n        \/\/ It is often a good idea to use 'require' to check if functions are called correctly.\n        \/\/ As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    \/**\n     * @dev Set contract deployer as owner\n     *\/\n    constructor(address _owner) {\n        owner = _owner;\n        emit OwnerSet(address(0), owner);\n    }\n\n    \/**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     *\/\n    function changeOwner(address newOwner) external isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    \/**\n     * @dev Return owner address \n     * @return address of owner\n     *\/\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\nabstract contract ERC20 {\n    function decimals() external virtual view returns (uint8 decimals_);\n    function transferFrom(address _from, address _to, uint256 _value) external virtual returns (bool success);\n    function transfer(address _to, uint256 _value) external virtual returns (bool success);\n    function allowance(address _owner, address _spender) external virtual view returns (uint256 remaining);\n    function balanceOf(address _owner) external virtual view returns (uint256 balance);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function _callOptionalReturn(ERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n\/**\n * \n * Stakes Almond v.3\n *\n * Stakes is an interest gain contract for ERC-20 tokens\n * \n * asset is the ERC20 token to deposit\n * asset2 is the ERC20 token to get interest\n * interest_rate: percentage rate of token1\n * interest_rate2: percentage rate of token2\n * maturity is the time in seconds after which is safe to end the stake\n * penalization for ending a stake before maturity time\n * lower_amount is the minimum amount for creating a stake\n * \n *\/\ncontract StakesAlmond is Owner, ReentrancyGuard {\n\n    using SafeERC20 for ERC20;\n\n    \/\/ token to deposit\n    ERC20 public asset;\n\n    \/\/ token to pay interest\n    ERC20 public asset2;\n\n    \/\/ stakes history\n    struct Record {\n        uint256 from;\n        uint256 amount;\n        uint256 gain;\n        uint256 gain2;\n        uint256 penalization;\n        uint256 to;\n        bool ended;\n    }\n\n    \/\/ contract parameters\n    uint16 public interest_rate;\n    uint16 public interest_rate2;\n    uint256 public maturity;\n    uint8 public penalization;\n    uint256 public lower_amount;\n\n    \/\/ conversion ratio for token1 and token2\n    \/\/ 1:10 ratio will be: \n    \/\/ ratio1 = 1 \n    \/\/ ratio2 = 10\n    uint256 public ratio1;\n    uint256 public ratio2;\n\n    mapping(address => Record[]) public ledger;\n\n    event StakeStart(address indexed user, uint256 value, uint256 index);\n    event StakeEnd(address indexed user, uint256 value, uint256 penalty, uint256 interest, uint256 index);\n    \n    event ChangeRatio1(uint256 newRatio);\n    event ChangeRatio2(uint256 newRatio);\n\n    constructor(\n        ERC20 _erc20, ERC20 _erc20_2, address _owner, uint16 _rate, uint16 _rate2, uint256 _maturity, \n        uint8 _penalization, uint256 _lower, uint256 _ratio1, uint256 _ratio2) Owner(_owner) {\n        require(_penalization<=100, \"Penalty has to be an integer between 0 and 100\");\n        asset = _erc20;\n        asset2 = _erc20_2;\n        ratio1 = _ratio1;\n        ratio2 = _ratio2;\n        interest_rate = _rate;\n        interest_rate2 = _rate2;\n        maturity = _maturity;\n        penalization = _penalization;\n        lower_amount = _lower;\n    }\n    \n    function start(uint256 _value) external nonReentrant {\n        require(_value >= lower_amount, \"Invalid value\");\n        asset.safeTransferFrom(msg.sender, address(this), _value);\n        ledger[msg.sender].push(Record(block.timestamp, _value, 0, 0, 0, 0, false));\n        emit StakeStart(msg.sender, _value, ledger[msg.sender].length-1);\n    }\n\n    function end(uint256 i) external nonReentrant {\n\n        require(i < ledger[msg.sender].length, \"Invalid index\");\n        require(!ledger[msg.sender][i].ended, \"Invalid stake\");\n        \n        \/\/ penalization\n        if(block.timestamp - ledger[msg.sender][i].from < maturity) {\n\n            uint256 _penalization = ledger[msg.sender][i].amount * penalization \/ 100;\n            ledger[msg.sender][i].penalization = _penalization;\n            ledger[msg.sender][i].to = block.timestamp;\n            ledger[msg.sender][i].ended = true;\n            emit StakeEnd(msg.sender, ledger[msg.sender][i].amount, _penalization, 0, i);\n\n            asset.safeTransfer(msg.sender, ledger[msg.sender][i].amount - _penalization);\n            asset.safeTransfer(getOwner(), _penalization);\n\n        \/\/ interest gained\n        } else {\n            \n            \/\/ interest is calculated in asset2\n            uint256 _interest = get_gains(msg.sender, i);\n\n            \/\/ check that the owner can pay interest before trying to pay, token 1\n            if (asset.allowance(getOwner(), address(this)) < _interest || asset.balanceOf(getOwner()) < _interest) {\n                _interest = 0;\n            }\n\n            \/\/ interest is calculated in asset2\n            uint256 _interest2 = get_gains2(msg.sender, i);\n\n            \/\/ check that the owner can pay interest before trying to pay, token 1\n            if (asset2.allowance(getOwner(), address(this)) < _interest2 || asset2.balanceOf(getOwner()) < _interest2) {\n                _interest2 = 0;\n            }\n\n            \/\/ the original asset is returned to the investor\n            ledger[msg.sender][i].gain = _interest;\n            ledger[msg.sender][i].gain2 = _interest2;\n            ledger[msg.sender][i].to = block.timestamp;\n            ledger[msg.sender][i].ended = true;\n            emit StakeEnd(msg.sender, ledger[msg.sender][i].amount, 0, _interest, i);\n\n            asset.safeTransfer(msg.sender, ledger[msg.sender][i].amount);\n\n            if (_interest > 0) {\n                asset.safeTransferFrom(getOwner(), msg.sender, _interest);\n            }\n\n            if (_interest2 > 0) {\n                asset2.safeTransferFrom(getOwner(), msg.sender, _interest2);\n            }\n\n        }\n    }\n\n    function set(ERC20 _erc20, ERC20 _erc20_2, uint256 _lower, uint256 _maturity, uint16 _rate, uint16 _rate2, uint8 _penalization, uint256 _ratio1, uint256 _ratio2) external isOwner {\n        require(_penalization<=100, \"Invalid value\");\n        asset = _erc20;\n        asset2 = _erc20_2;\n        ratio1 = _ratio1;\n        ratio2 = _ratio2;\n        lower_amount = _lower;\n        maturity = _maturity;\n        interest_rate = _rate;\n        interest_rate2 = _rate2;\n        penalization = _penalization;\n\n        emit ChangeRatio1(ratio1);\n        emit ChangeRatio2(ratio2);\n\n    }\n\n    \/\/ calculate interest of the token 1 to the current date time\n    function get_gains(address _address, uint256 _rec_number) public view returns (uint256) {\n        uint256 _record_seconds = block.timestamp - ledger[_address][_rec_number].from;\n        uint256 _year_seconds = 365*24*60*60;\n        return _record_seconds * \n            ledger[_address][_rec_number].amount * interest_rate \/ 100\n        \/ _year_seconds;\n    }\n\n    \/\/ calculate interest to the current date time\n    function get_gains2(address _address, uint256 _rec_number) public view returns (uint256) {\n        uint256 _record_seconds = block.timestamp - ledger[_address][_rec_number].from;\n        uint256 _year_seconds = 365*24*60*60;\n        \n        \/**\n         *\n         * Oririginal code:\n         * \n         *   \/\/ now we calculate the value of the transforming the staked asset (asset) into the asset2\n         *   \/\/ first we calculate the ratio\n         *   uint256 value_in_asset2 = ledger[_address][_rec_number].amount * ratio2 \/ ratio1;\n         *   \/\/ now we transform into decimals of the asset2\n         *   value_in_asset2 = value_in_asset2 * 10**asset2.decimals() \/ 10**asset.decimals();\n         *   uint256 interest = _record_seconds * value_in_asset2 * interest_rate2 \/ 100 \/ _year_seconds;\n         *   \/\/ now lets calculate the interest rate based on the converted value in asset 2\n         *\n         * Simplified into:\n         * \n         *\/\n\n        return (_record_seconds * ledger[_address][_rec_number].amount * ratio2 * 10**asset2.decimals() * interest_rate2) \/ \n               (ratio1 * 10**asset.decimals() * 100 * _year_seconds);\n\n    }\n\n    function ledger_length(address _address) external view \n        returns (uint256) {\n        return ledger[_address].length;\n    }\n\n}",
                "contractName": "StakesAlmond",
                "version": "3.0",
                "compilerVersion": "v0.8.2"
            }
        }
    },
    "yuzu": {
        "data": {
            "1.0": {
                "abi_factory": [{"inputs":[{"internalType":"contract ERC20","name":"_token","type":"address"},{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"},{"internalType":"uint256","name":"_claimRatio","type":"uint256"},{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"inputs":[],"name":"buyCoffee","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"},{"internalType":"address","name":"from_address","type":"address"}],"name":"buyTea","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"canBuyTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"uri","type":"string"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"string","name":"uri","type":"string"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"enableTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getPriceInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"master","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"contract ERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_claimRatio","type":"uint256"}],"name":"updateClaimRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_enabled","type":"bool"}],"name":"updateEnabled","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"}],"name":"updateRewardsRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract ERC20","name":"_token","type":"address"}],"name":"updateToken","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  ERC-1155 NFT Token\n    |\n    |----------------------------\n    |\n    |  Flavors\n    |\n    |  >  Yuzu: Standard ERC-1155 Token\n    |\n\n*\/\n\npragma solidity ^0.8.2;\n\n\/\/ File contracts\/access\/IAccessControl.sol\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\n\/\/ File contracts\/access\/IAccessControlEnumerable.sol\n\n\n\/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n *\/\ninterface IAccessControlEnumerable is IAccessControl {\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n\n\/\/ File contracts\/utils\/Context.sol\n\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\n\/\/ File contracts\/utils\/Strings.sol\n\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     *\/\n    function toString(uint256 value) internal pure returns (string memory) {\n        \/\/ Inspired by OraclizeAPI's implementation - MIT licence\n        \/\/ https:\/\/github.com\/oraclize\/ethereum-api\/blob\/b42146b063c7d6ee1358846c198246239e9360e8\/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp \/= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value \/= 10;\n        }\n        return string(buffer);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     *\/\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\n\/\/ File contracts\/utils\/introspection\/IERC165.sol\n\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\n\/\/ File contracts\/utils\/introspection\/ERC165.sol\n\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\n\/\/ File contracts\/access\/AccessControl.sol\n\n\n\n\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     *\/\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\n\/\/ File contracts\/utils\/structs\/EnumerableSet.sol\n\n\n\/**\n * @dev Library for managing\n * https:\/\/en.wikipedia.org\/wiki\/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     \/\/ Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     \/\/ Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\/\nlibrary EnumerableSet {\n    \/\/ To implement this library for multiple types with as little code\n    \/\/ repetition as possible, we write it in terms of a generic Set type with\n    \/\/ bytes32 values.\n    \/\/ The Set implementation uses private functions, and user-facing\n    \/\/ implementations (such as AddressSet) are just wrappers around the\n    \/\/ underlying Set.\n    \/\/ This means that we can only create new EnumerableSets for types that fit\n    \/\/ in bytes32.\n\n    struct Set {\n        \/\/ Storage of set values\n        bytes32[] _values;\n        \/\/ Position of the value in the `values` array, plus 1 because index 0\n        \/\/ means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            \/\/ The value is stored at length-1, but we add 1 to all indexes\n            \/\/ and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        \/\/ We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            \/\/ Equivalent to contains(set, value)\n            \/\/ To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            \/\/ the array, and then remove the last element (sometimes called as 'swap and pop').\n            \/\/ This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                \/\/ Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                \/\/ Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; \/\/ Replace lastvalue's index to valueIndex\n            }\n\n            \/\/ Delete the slot where the moved value was stored\n            set._values.pop();\n\n            \/\/ Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    \/\/ Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    \/\/ AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \/**\n     * @dev Returns the number of values in the set. O(1).\n     *\/\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    \/\/ UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    \/**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     *\/\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     *\/\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Returns true if the value is in the set. O(1).\n     *\/\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    \/**\n     * @dev Returns the number of values on the set. O(1).\n     *\/\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \/**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     *\/\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    \/**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     *\/\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n\n\/\/ File contracts\/access\/AccessControlEnumerable.sol\n\n\n\n\n\/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n *\/\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https:\/\/forum.openzeppelin.com\/t\/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts\/2296[forum post]\n     * for more information.\n     *\/\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    \/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     *\/\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    \/**\n     * @dev Overload {grantRole} to track enumerable memberships\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    \/**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    \/**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n}\n\n\n\/\/ File contracts\/token\/ERC1155\/IERC1155.sol\n\n\n\/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-1155[EIP].\n *\n * _Available since v3.1._\n *\/\ninterface IERC1155 is IERC165 {\n    \/**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     *\/\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    \/**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     *\/\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    \/**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     *\/\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    \/**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     *\/\n    event URI(string value, uint256 indexed id);\n\n    \/**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     *\/\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    \/**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     *\/\n    function setApprovalForAll(address operator, bool approved) external;\n\n    \/**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     *\/\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    \/**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n\n\n\/\/ File contracts\/token\/ERC1155\/IERC1155Receiver.sol\n\n\n\/**\n * @dev _Available since v3.1._\n *\/\ninterface IERC1155Receiver is IERC165 {\n    \/**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    \/**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\n\/\/ File contracts\/token\/ERC1155\/extensions\/IERC1155MetadataURI.sol\n\n\n\/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n *\/\ninterface IERC1155MetadataURI is IERC1155 {\n    \/**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     *\/\n    function uri(uint256 id) external view returns (string memory);\n}\n\n\n\/\/ File contracts\/utils\/Address.sol\n\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https:\/\/diligence.consensys.net\/posts\/2019\/09\/stop-using-soliditys-transfer-now\/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https:\/\/solidity.readthedocs.io\/en\/v0.5.11\/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\/\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \/**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https:\/\/solidity.readthedocs.io\/en\/latest\/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\n\/\/ File contracts\/token\/ERC1155\/ERC1155.sol\n\n\n\n\n\n\n\n\/**\n * @dev Implementation of the basic standard multi-token.\n * See https:\/\/eips.ethereum.org\/EIPS\/eip-1155\n * Originally based on code by Enjin: https:\/\/github.com\/enjin\/erc-1155\n *\n * _Available since v3.1._\n *\/\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    \/\/ Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    \/\/ Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/\/ Used as the URI for all token types by relying on ID substitution, e.g. https:\/\/token-cdn-domain\/{id}.json\n    string private _uri;\n\n    \/**\n     * @dev See {_setURI}.\n     *\/\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     *\/\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    \/**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    \/**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     *\/\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    \/**\n     * @dev See {IERC1155-setApprovalForAll}.\n     *\/\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    \/**\n     * @dev See {IERC1155-isApprovedForAll}.\n     *\/\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    \/**\n     * @dev See {IERC1155-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    \/**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     *\/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https:\/\/token-cdn-domain\/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https:\/\/token-cdn-domain\/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     *\/\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    \/**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     *\/\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 accountBalance = _balances[id][account];\n        require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][account] = accountBalance - amount;\n        }\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     *\/\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 accountBalance = _balances[id][account];\n            require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][account] = accountBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    \/**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     *\/\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n\n\n\/\/ File contracts\/token\/ERC1155\/extensions\/ERC1155BurnableSupply.sol\n\n\n\/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n *\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\n *\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\n * clearly identified. Note: While a totalSupply of 1 might mean the\n * corresponding is an NFT, there is no guarantees that no other token with the\n * same id are not going to be minted.\n *\/\n\nabstract contract ERC1155BurnableSupply is ERC1155 {\n\n    \/\/ Burnable section\n\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n\n    \/\/ supply section\n\n    mapping(uint256 => uint256) private _totalSupply;\n\n    \/**\n     * @dev Total amount of tokens in with a given id.\n     *\/\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    \/**\n     * @dev Indicates weither any token exist with a given id, or not.\n     *\/\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155BurnableSupply.totalSupply(id) > 0;\n    }\n\n    \/**\n     * @dev See {ERC1155-_mint}.\n     *\/\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual override {\n        super._mint(account, id, amount, data);\n        _totalSupply[id] += amount;\n    }\n\n    \/**\n     * @dev See {ERC1155-_mintBatch}.\n     *\/\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._mintBatch(to, ids, amounts, data);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            _totalSupply[ids[i]] += amounts[i];\n        }\n    }\n\n    \/**\n     * @dev See {ERC1155-_burn}.\n     *\/\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual override {\n        super._burn(account, id, amount);\n        _totalSupply[id] -= amount;\n    }\n\n    \/**\n     * @dev See {ERC1155-_burnBatch}.\n     *\/\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual override {\n        super._burnBatch(account, ids, amounts);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            _totalSupply[ids[i]] -= amounts[i];\n        }\n    }\n\n}\n\n\n\/\/ File contracts\/utils\/Counters.sol\n\n\n\/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n *\/\nlibrary Counters {\n    struct Counter {\n        \/\/ This variable should never be directly accessed by users of the library: interactions must be restricted to\n        \/\/ the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        \/\/ this feature: see https:\/\/github.com\/ethereum\/solidity\/issues\/4637\n        uint256 _value; \/\/ default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n\n\/\/ File contracts\/token\/ERC1155\/Yuzu.sol\n\n\/**\n * @dev {ERC1155} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter role, as well\n * as the default admin role, which will let it grant minter role to other accounts.\n *\/\ncontract ERC1155Yuzu is Context, AccessControlEnumerable, ERC1155BurnableSupply {\n    \n    using Counters for Counters.Counter;\n\n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    Counters.Counter private _tokenIdCounter;\n    bool public anyoneCanMint;\n\n    \/**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, and `MINTER_ROLE` to the account that\n     * deploys the contract. And initializes the contract by setting a `name` \n     * and a `symbol` to the token collection.\n     *\/\n    constructor(address owner, string memory uri, string memory name_, string memory symbol_, bool anyoneCanMint_) ERC1155(uri) {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(MINTER_ROLE, owner);\n        _name = name_;\n        _symbol = symbol_;\n        anyoneCanMint = anyoneCanMint_;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-name}.\n     *\/\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-symbol}.\n     *\/\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev Creates `amount` new tokens for `to`, using the next available `id`.\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function autoMint(address to, uint256 amount) public onlyMinter {\n        uint id;\n        do {\n          _tokenIdCounter.increment();\n          id = _tokenIdCounter.current();\n        } while(exists(id));\n        _mint(to, id, amount, \"0x\");\n    }\n\n    \/**\n     * @dev Creates `amounts` new tokens for `to`, using the next available `ids`.\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function autoMintBatch(address to, uint256[] memory amounts) public onlyMinter {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        for (uint256 i = 0; i < amounts.length; i++) {\n            autoMint(to, amounts[i]);\n        }\n    }\n\n    \/**\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\n     *\n     * See {ERC1155-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual onlyMinter {\n        _mint(to, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\n     *\/\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual onlyMinter {\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlEnumerable, ERC1155)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    function canIMint() public view returns (bool) {\n        return anyoneCanMint || isMinter(msg.sender);\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        string memory mensaje;\n        require(\n            canIMint(),\n            \"ERC1155Yuzu: must have minter role to mint\"\n        );\n        _;\n    }\n\n}",
                "contractName": "ERC1155Yuzu",
                "version": "1.0",
                "compilerVersion": "v0.8.2"
            },
            "2.0": {
                "abi_factory": [{"inputs":[{"internalType":"contract ERC20","name":"_token","type":"address"},{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"},{"internalType":"uint256","name":"_claimRatio","type":"uint256"},{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"inputs":[],"name":"buyCoffee","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"},{"internalType":"address","name":"from_address","type":"address"}],"name":"buyTea","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"canBuyTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"uri","type":"string"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"string","name":"uri","type":"string"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"enableTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getPriceInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"in_wei","type":"uint256"}],"name":"getRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"master","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"contract ERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_claimRatio","type":"uint256"}],"name":"updateClaimRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_enabled","type":"bool"}],"name":"updateEnabled","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_rewardsRatio","type":"uint256"}],"name":"updateRewardsRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract ERC20","name":"_token","type":"address"}],"name":"updateToken","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  ERC-1155 NFT Token\n    |\n    |----------------------------\n    |\n    |  Flavors\n    |\n    |  >  Yuzu v2: Standard ERC-1155 Token\n    |\n\n*\/\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n *\/\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \/\/ no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    \/**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https:\/\/web3js.readthedocs.io\/en\/v1.3.4\/web3-eth-accounts.html#sign[Web3.js]\n     * - with https:\/\/docs.ethers.io\/v5\/api\/signer\/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        \/\/ Check the signature length\n        \/\/ - case 65: r,s,v signature (standard)\n        \/\/ - case 64: r,vs signature (cf https:\/\/eips.ethereum.org\/EIPS\/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            \/\/ ecrecover takes the signature parameters, and the only way to get them\n            \/\/ currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            \/\/ ecrecover takes the signature parameters, and the only way to get them\n            \/\/ currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    \/**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\/\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https:\/\/eips.ethereum.org\/EIPS\/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     *\/\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        \/\/ EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        \/\/ unique. Appendix F in the Ethereum Yellow paper (https:\/\/ethereum.github.io\/yellowpaper\/paper.pdf), defines\n        \/\/ the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\n        \/\/ signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        \/\/\n        \/\/ If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        \/\/ with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        \/\/ vice versa. If your library also generates signatures with 0\/1 for v instead 27\/28, add 27 to v to accept\n        \/\/ these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        \/\/ If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\/\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    \/**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https:\/\/eth.wiki\/json-rpc\/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     *\/\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        \/\/ 32 is the length in bytes of hash,\n        \/\/ enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\u0019Ethereum Signed Message:\n32\", hash));\n    }\n\n    \/**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     *\/\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\u0019\u0001\", domainSeparator, structHash));\n    }\n}\n\n\/**\n * @dev https:\/\/eips.ethereum.org\/EIPS\/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https:\/\/docs.metamask.io\/guide\/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\/\nabstract contract EIP712 {\n    \/* solhint-disable var-name-mixedcase *\/\n    \/\/ Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    \/\/ invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    \/* solhint-enable var-name-mixedcase *\/\n\n    \/**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     *\/\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    \/**\n     * @dev Returns the domain separator for the current chain.\n     *\/\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    \/**\n     * @dev Given an already https:\/\/eips.ethereum.org\/EIPS\/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     *\/\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     *\/\n    function toString(uint256 value) internal pure returns (string memory) {\n        \/\/ Inspired by OraclizeAPI's implementation - MIT licence\n        \/\/ https:\/\/github.com\/oraclize\/ethereum-api\/blob\/b42146b063c7d6ee1358846c198246239e9360e8\/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp \/= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value \/= 10;\n        }\n        return string(buffer);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     *\/\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-1155[EIP].\n *\n * _Available since v3.1._\n *\/\ninterface IERC1155 is IERC165 {\n    \/**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     *\/\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    \/**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     *\/\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    \/**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     *\/\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    \/**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     *\/\n    event URI(string value, uint256 indexed id);\n\n    \/**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     *\/\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    \/**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     *\/\n    function setApprovalForAll(address operator, bool approved) external;\n\n    \/**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     *\/\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    \/**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n\n\/**\n * @dev _Available since v3.1._\n *\/\ninterface IERC1155Receiver is IERC165 {\n    \/**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    \/**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     *\/\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n *\/\ninterface IERC1155MetadataURI is IERC1155 {\n    \/**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     *\/\n    function uri(uint256 id) external view returns (string memory);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https:\/\/diligence.consensys.net\/posts\/2019\/09\/stop-using-soliditys-transfer-now\/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https:\/\/solidity.readthedocs.io\/en\/v0.5.11\/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\/\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \/**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https:\/\/solidity.readthedocs.io\/en\/latest\/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @dev Implementation of the basic standard multi-token.\n * See https:\/\/eips.ethereum.org\/EIPS\/eip-1155\n * Originally based on code by Enjin: https:\/\/github.com\/enjin\/erc-1155\n *\n * _Available since v3.1._\n *\/\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    \/\/ Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    \/\/ Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/\/ Used as the URI for all token types by relying on ID substitution, e.g. https:\/\/token-cdn-domain\/{id}.json\n    string private _uri;\n\n    \/**\n     * @dev See {_setURI}.\n     *\/\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     *\/\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    \/**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    \/**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     *\/\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    \/**\n     * @dev See {IERC1155-setApprovalForAll}.\n     *\/\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    \/**\n     * @dev See {IERC1155-isApprovedForAll}.\n     *\/\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    \/**\n     * @dev See {IERC1155-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    \/**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     *\/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https:\/\/token-cdn-domain\/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https:\/\/token-cdn-domain\/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     *\/\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    \/**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n\n\/**\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\n *\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\n * clearly identified. Note: While a totalSupply of 1 might mean the\n * corresponding is an NFT, there is no guarantees that no other token with the\n * same id are not going to be minted.\n *\/\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    \/**\n     * @dev Total amount of tokens in with a given id.\n     *\/\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    \/**\n     * @dev Indicates weither any token exist with a given id, or not.\n     *\/\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n\n    \/**\n     * @dev See {ERC1155-_mint}.\n     *\/\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual override {\n        super._mint(account, id, amount, data);\n        _totalSupply[id] += amount;\n    }\n\n    \/**\n     * @dev See {ERC1155-_mintBatch}.\n     *\/\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._mintBatch(to, ids, amounts, data);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            _totalSupply[ids[i]] += amounts[i];\n        }\n    }\n\n}\n\n\/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\/\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \/**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     *\/\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    \/**\n     * @dev Returns the address of the current owner.\n     *\/\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    \/**\n     * @dev Throws if called by any account other than the owner.\n     *\/\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\/\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    \/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     *\/\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\/**\n * @dev {ERC1155} token, including:\n *\n *  - a minter role that allows for token minting (creation)\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter role, as well\n * as the default admin role, which will let it grant minter role to other accounts.\n *\/\ncontract ERC1155Yuzu is Ownable, AccessControl, ERC1155Supply {\n    \n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    uint256 internal _tokenIdCounter;\n    bool public anyoneCanMint;\n\n    \/**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, and `MINTER_ROLE` to the account that\n     * deploys the contract. And initializes the contract by setting a `name` \n     * and a `symbol` to the token collection.\n     *\/\n    constructor(address owner, string memory uri, string memory name_, string memory symbol_, bool anyoneCanMint_) Ownable() ERC1155(uri) {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(MINTER_ROLE, owner);\n        transferOwnership(owner);\n        _name = name_;\n        _symbol = symbol_;\n        anyoneCanMint = anyoneCanMint_;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-name}.\n     *\/\n    function name() external view virtual returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-symbol}.\n     *\/\n    function symbol() external view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev Find next available tokenId\n     *\/\n    function findNextTokenId() internal {\n        do {\n          _tokenIdCounter++;\n        } while(exists(_tokenIdCounter));\n    }\n\n    \/**\n     * @dev Creates `amount` new tokens for `to`, using the next available `id`.\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function autoMint(address to, uint256 amount) public onlyMinter returns (uint256) {\n        findNextTokenId();\n        _mint(to, _tokenIdCounter, amount, \"0x\");\n        return _tokenIdCounter;\n    }\n\n    \/**\n     * @dev Creates `amounts` new tokens for `to`, using the next available `ids`.\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function autoMintBatch(address to, uint256[] memory amounts) external onlyMinter {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        for (uint256 i = 0; i < amounts.length; i++) {\n            autoMint(to, amounts[i]);\n        }\n    }\n\n    \/**\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\n     *\n     * See {ERC1155-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external virtual onlyMinter {\n        _mint(to, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\n     *\/\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external virtual onlyMinter {\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControl, ERC1155)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function addMinter(address account) external onlyMinter {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    function canIMint() public view returns (bool) {\n        return anyoneCanMint || isMinter(msg.sender);\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        string memory mensaje;\n        require(\n            canIMint(),\n            \"ERC1155Yuzu: must have minter role to mint\"\n        );\n        _;\n    }\n\n}",
                "contractName": "ERC1155Yuzu",
                "version": "2.0",
                "compilerVersion": "v0.8.2"
            },
            "3.0": {
                "abi_factory": [{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"uri","type":"string"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint8","name":"_whoCanMint","type":"uint8"},{"internalType":"address","name":"_affiliate","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"string","name":"uri","type":"string"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint8","name":"_whoCanMint","type":"uint8"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n *\/\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \/\/ no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    \/**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https:\/\/web3js.readthedocs.io\/en\/v1.3.4\/web3-eth-accounts.html#sign[Web3.js]\n     * - with https:\/\/docs.ethers.io\/v5\/api\/signer\/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        \/\/ Check the signature length\n        \/\/ - case 65: r,s,v signature (standard)\n        \/\/ - case 64: r,vs signature (cf https:\/\/eips.ethereum.org\/EIPS\/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            \/\/ ecrecover takes the signature parameters, and the only way to get them\n            \/\/ currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            \/\/ ecrecover takes the signature parameters, and the only way to get them\n            \/\/ currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    \/**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\/\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https:\/\/eips.ethereum.org\/EIPS\/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     *\/\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        \/\/ EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        \/\/ unique. Appendix F in the Ethereum Yellow paper (https:\/\/ethereum.github.io\/yellowpaper\/paper.pdf), defines\n        \/\/ the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\n        \/\/ signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        \/\/\n        \/\/ If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        \/\/ with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        \/\/ vice versa. If your library also generates signatures with 0\/1 for v instead 27\/28, add 27 to v to accept\n        \/\/ these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        \/\/ If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\/\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    \/**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https:\/\/eth.wiki\/json-rpc\/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     *\/\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        \/\/ 32 is the length in bytes of hash,\n        \/\/ enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\u0019Ethereum Signed Message:\n32\", hash));\n    }\n\n    \/**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     *\/\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\u0019\u0001\", domainSeparator, structHash));\n    }\n}\n\n\/**\n * @dev https:\/\/eips.ethereum.org\/EIPS\/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https:\/\/docs.metamask.io\/guide\/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\/\nabstract contract EIP712 {\n    \/* solhint-disable var-name-mixedcase *\/\n    \/\/ Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    \/\/ invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    \/* solhint-enable var-name-mixedcase *\/\n\n    \/**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     *\/\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    \/**\n     * @dev Returns the domain separator for the current chain.\n     *\/\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    \/**\n     * @dev Given an already https:\/\/eips.ethereum.org\/EIPS\/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     *\/\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     *\/\n    function toString(uint256 value) internal pure returns (string memory) {\n        \/\/ Inspired by OraclizeAPI's implementation - MIT licence\n        \/\/ https:\/\/github.com\/oraclize\/ethereum-api\/blob\/b42146b063c7d6ee1358846c198246239e9360e8\/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp \/= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value \/= 10;\n        }\n        return string(buffer);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     *\/\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-1155[EIP].\n *\n * _Available since v3.1._\n *\/\ninterface IERC1155 is IERC165 {\n    \/**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     *\/\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    \/**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     *\/\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    \/**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     *\/\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    \/**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     *\/\n    event URI(string value, uint256 indexed id);\n\n    \/**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     *\/\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    \/**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     *\/\n    function setApprovalForAll(address operator, bool approved) external;\n\n    \/**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     *\/\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    \/**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n\n\/**\n * @dev _Available since v3.1._\n *\/\ninterface IERC1155Receiver is IERC165 {\n    \/**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    \/**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     *\/\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n *\/\ninterface IERC1155MetadataURI is IERC1155 {\n    \/**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     *\/\n    function uri(uint256 id) external view returns (string memory);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https:\/\/diligence.consensys.net\/posts\/2019\/09\/stop-using-soliditys-transfer-now\/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https:\/\/solidity.readthedocs.io\/en\/v0.5.11\/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\/\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \/**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https:\/\/solidity.readthedocs.io\/en\/latest\/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @dev Implementation of the basic standard multi-token.\n * See https:\/\/eips.ethereum.org\/EIPS\/eip-1155\n * Originally based on code by Enjin: https:\/\/github.com\/enjin\/erc-1155\n *\n * _Available since v3.1._\n *\/\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    \/\/ Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    \/\/ Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/\/ Used as the URI for all token types by relying on ID substitution, e.g. https:\/\/token-cdn-domain\/{id}.json\n    string private _uri;\n\n    \/**\n     * @dev See {_setURI}.\n     *\/\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     *\/\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    \/**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    \/**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     *\/\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    \/**\n     * @dev See {IERC1155-setApprovalForAll}.\n     *\/\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    \/**\n     * @dev See {IERC1155-isApprovedForAll}.\n     *\/\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    \/**\n     * @dev See {IERC1155-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    \/**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     *\/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https:\/\/token-cdn-domain\/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https:\/\/token-cdn-domain\/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     *\/\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    \/**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n\n\/**\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\n *\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\n * clearly identified. Note: While a totalSupply of 1 might mean the\n * corresponding is an NFT, there is no guarantees that no other token with the\n * same id are not going to be minted.\n *\/\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    \/**\n     * @dev Total amount of tokens in with a given id.\n     *\/\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    \/**\n     * @dev Indicates weither any token exist with a given id, or not.\n     *\/\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n\n    \/**\n     * @dev See {ERC1155-_mint}.\n     *\/\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual override {\n        super._mint(account, id, amount, data);\n        _totalSupply[id] += amount;\n    }\n\n    \/**\n     * @dev See {ERC1155-_mintBatch}.\n     *\/\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._mintBatch(to, ids, amounts, data);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            _totalSupply[ids[i]] += amounts[i];\n        }\n    }\n\n}\n\n\/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\/\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \/**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     *\/\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    \/**\n     * @dev Returns the address of the current owner.\n     *\/\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    \/**\n     * @dev Throws if called by any account other than the owner.\n     *\/\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\/\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    \/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     *\/\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\/**\n * Yuzu v.3\n *\n * @dev {ERC1155} token, including:\n *\n *  - a minter role that allows for token minting (creation)\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter role, as well\n * as the default admin role, which will let it grant minter role to other accounts.\n *\/\ncontract ERC1155Yuzu is Ownable, AccessControl, ERC1155Supply {\n    \n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    uint256 internal _tokenIdCounter;\n\n    \/**\n     * Special setting to give special minting permissions\n     * whoCanMint = 0: only minter can mint\n     * whoCanMint = 1: only original creator of the Item can mint, multiple times\n     * whoCanMint = 2: anyone can arbitrarily mint\n     *\/\n    uint8 public whoCanMint;\n\n    \/\/ nft item creators list, used to pay royalties\n    mapping(uint256 => address) public creators;\n    \n    \/**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, and `MINTER_ROLE` to the account that\n     * deploys the contract. And initializes the contract by setting a `name` \n     * and a `symbol` to the token collection.\n     *\/\n    constructor(address owner, string memory uri, string memory name_, string memory symbol_, uint8 whoCanMint_) Ownable() ERC1155(uri) {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(MINTER_ROLE, owner);\n        transferOwnership(owner);\n        _name = name_;\n        _symbol = symbol_;\n        whoCanMint = whoCanMint_;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-name}.\n     *\/\n    function name() external view virtual returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-symbol}.\n     *\/\n    function symbol() external view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev Find next available tokenId\n     *\/\n    function findNextTokenId() internal {\n        do {\n          _tokenIdCounter++;\n        } while(exists(_tokenIdCounter));\n    }\n\n    \/\/\/ Overrides minting function to keep track of item creators\n\n    function _mint(address to, uint256 tokenId, uint256 amount, bytes memory data) override internal {\n        creators[tokenId] = _msgSender();\n        super._mint(to, tokenId, amount, data);\n    }\n\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) override internal {\n        super._mintBatch(to, ids, amounts, data);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            creators[ids[i]] = _msgSender();\n        }\n    }\n\n    \/**\n     * @dev Creates `amount` new tokens for `to`, using the next available `id`.\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function autoMint(address to, uint256 amount) public onlyMinter returns (uint256) {\n        findNextTokenId();\n        _mint(to, _tokenIdCounter, amount, \"0x\");\n        return _tokenIdCounter;\n    }\n\n    \/**\n     * @dev Creates `amounts` new tokens for `to`, using the next available `ids`.\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function autoMintBatch(address to, uint256[] memory amounts) external onlyMinter {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        for (uint256 i = 0; i < amounts.length; i++) {\n            autoMint(to, amounts[i]);\n        }\n    }\n\n    \/**\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\n     *\n     * See {ERC1155-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external virtual canMint(id) {\n        _mint(to, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\n     *\/\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external virtual onlyMinter {\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControl, ERC1155)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function addMinter(address account) external onlyMinter {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    \/**\n     * Check if a user can mint, and optionally check if an user can mint more of an specific token\n     * Who can mint?\n     * Case 1: a minter can mint\n     * Case 2: a creator can mint more items if he is allowed to\n     * Case 3: arbitrary minting is possible if set (not recommended)\n     * @param _id: NFT token ID (optional)\n     *\/\n    function canIMint(uint256 _id) public view returns (bool) {\n        return  isMinter(msg.sender) || \/\/ a minter can mint\n                (whoCanMint == 1 && _id == 0) || \/\/ a creator can mint for the first time any item\n                (whoCanMint == 1 && _id > 0 && creators[_id] == msg.sender) || \/\/ a creator can add more items to its own NFT items\n                whoCanMint == 2 \/\/ if anyone can mint, allow any mint request\n        ;\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        require(\n            canIMint(0), \/\/ it allows minters or anyone if anyone can mint is set\n            \"ERC1155Yuzu: must have minter role to mint\"\n        );\n        _;\n    }\n\n    \/**\n     * Open modifier to check who can mint, allowing the restriction that only creators can mint their own token\n     *\/\n    modifier canMint(uint256 _tokenId) {\n        require(\n            canIMint(_tokenId), \/\/ it allows minters or anyone if anyone can mint is set, but also check if only the creator can mint its token\n            \"ERC1155Yuzu: must have minter role to mint\"\n        );\n        _;\n    }\n\n}",
                "contractName": "ERC1155Yuzu",
                "version": "3.0",
                "compilerVersion": "v0.8.2"
            }
        }
    },
    "ikasumi": {
        "data": {
            "1.0": {
                "abi_factory": [{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"inputs":[],"name":"buyCoffee","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_payment_token","type":"address"},{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"uint256","name":"_royaltiesCommissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"},{"internalType":"string","name":"uri","type":"string"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"enableTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"master","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  ERC-1155 NFT Token Advanced Marketplace\n    |\n    |----------------------------\n    |\n    |  Flavors\n    |\n    |  >  Ikasumi v.1: Standard ERC-1155 Token with Marketplace\n    |\n    |                  > Token Marketplace\n    |                  > Royalties\n    |                  > Lazy minting\n    |\n\n*\/\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n *\/\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \/\/ no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    \/**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https:\/\/web3js.readthedocs.io\/en\/v1.3.4\/web3-eth-accounts.html#sign[Web3.js]\n     * - with https:\/\/docs.ethers.io\/v5\/api\/signer\/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        \/\/ Check the signature length\n        \/\/ - case 65: r,s,v signature (standard)\n        \/\/ - case 64: r,vs signature (cf https:\/\/eips.ethereum.org\/EIPS\/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            \/\/ ecrecover takes the signature parameters, and the only way to get them\n            \/\/ currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            \/\/ ecrecover takes the signature parameters, and the only way to get them\n            \/\/ currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    \/**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\/\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https:\/\/eips.ethereum.org\/EIPS\/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     *\/\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        \/\/ EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        \/\/ unique. Appendix F in the Ethereum Yellow paper (https:\/\/ethereum.github.io\/yellowpaper\/paper.pdf), defines\n        \/\/ the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\n        \/\/ signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        \/\/\n        \/\/ If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        \/\/ with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        \/\/ vice versa. If your library also generates signatures with 0\/1 for v instead 27\/28, add 27 to v to accept\n        \/\/ these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        \/\/ If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\/\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    \/**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https:\/\/eth.wiki\/json-rpc\/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     *\/\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        \/\/ 32 is the length in bytes of hash,\n        \/\/ enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\u0019Ethereum Signed Message:\n32\", hash));\n    }\n\n    \/**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     *\/\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\u0019\u0001\", domainSeparator, structHash));\n    }\n}\n\n\/**\n * @dev https:\/\/eips.ethereum.org\/EIPS\/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https:\/\/docs.metamask.io\/guide\/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\/\nabstract contract EIP712 {\n    \/* solhint-disable var-name-mixedcase *\/\n    \/\/ Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    \/\/ invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    \/* solhint-enable var-name-mixedcase *\/\n\n    \/**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     *\/\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    \/**\n     * @dev Returns the domain separator for the current chain.\n     *\/\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    \/**\n     * @dev Given an already https:\/\/eips.ethereum.org\/EIPS\/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     *\/\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     *\/\n    function toString(uint256 value) internal pure returns (string memory) {\n        \/\/ Inspired by OraclizeAPI's implementation - MIT licence\n        \/\/ https:\/\/github.com\/oraclize\/ethereum-api\/blob\/b42146b063c7d6ee1358846c198246239e9360e8\/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp \/= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value \/= 10;\n        }\n        return string(buffer);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     *\/\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n *\/\ninterface IERC20 {\n    \/**\n     * @dev Returns the amount of tokens in existence.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns the amount of tokens owned by `account`.\n     *\/\n    function balanceOf(address account) external view returns (uint256);\n\n    \/**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     *\/\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    \/**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \/**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     *\/\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-1155[EIP].\n *\n * _Available since v3.1._\n *\/\ninterface IERC1155 is IERC165 {\n    \/**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     *\/\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    \/**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     *\/\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    \/**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     *\/\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    \/**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     *\/\n    event URI(string value, uint256 indexed id);\n\n    \/**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     *\/\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    \/**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     *\/\n    function setApprovalForAll(address operator, bool approved) external;\n\n    \/**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     *\/\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    \/**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n\n\/**\n * @dev _Available since v3.1._\n *\/\ninterface IERC1155Receiver is IERC165 {\n    \/**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    \/**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     *\/\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n *\/\ninterface IERC1155MetadataURI is IERC1155 {\n    \/**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     *\/\n    function uri(uint256 id) external view returns (string memory);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https:\/\/diligence.consensys.net\/posts\/2019\/09\/stop-using-soliditys-transfer-now\/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https:\/\/solidity.readthedocs.io\/en\/v0.5.11\/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\/\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \/**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https:\/\/solidity.readthedocs.io\/en\/latest\/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @dev Implementation of the basic standard multi-token.\n * See https:\/\/eips.ethereum.org\/EIPS\/eip-1155\n * Originally based on code by Enjin: https:\/\/github.com\/enjin\/erc-1155\n *\n * _Available since v3.1._\n *\/\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    \/\/ Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    \/\/ Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/\/ Used as the URI for all token types by relying on ID substitution, e.g. https:\/\/token-cdn-domain\/{id}.json\n    string private _uri;\n\n    \/**\n     * @dev See {_setURI}.\n     *\/\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     *\/\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    \/**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    \/**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     *\/\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    \/**\n     * @dev See {IERC1155-setApprovalForAll}.\n     *\/\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    \/**\n     * @dev See {IERC1155-isApprovedForAll}.\n     *\/\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    \/**\n     * @dev See {IERC1155-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    \/**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     *\/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https:\/\/token-cdn-domain\/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https:\/\/token-cdn-domain\/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     *\/\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    \/**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n\n\/**\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\n *\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\n * clearly identified. Note: While a totalSupply of 1 might mean the\n * corresponding is an NFT, there is no guarantees that no other token with the\n * same id are not going to be minted.\n *\/\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    \/**\n     * @dev Total amount of tokens in with a given id.\n     *\/\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    \/**\n     * @dev Indicates weither any token exist with a given id, or not.\n     *\/\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n\n    \/**\n     * @dev See {ERC1155-_mint}.\n     *\/\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual override {\n        super._mint(account, id, amount, data);\n        _totalSupply[id] += amount;\n    }\n\n    \/**\n     * @dev See {ERC1155-_mintBatch}.\n     *\/\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._mintBatch(to, ids, amounts, data);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            _totalSupply[ids[i]] += amounts[i];\n        }\n    }\n\n}\n\n\/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\/\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \/**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     *\/\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    \/**\n     * @dev Returns the address of the current owner.\n     *\/\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    \/**\n     * @dev Throws if called by any account other than the owner.\n     *\/\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\/\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    \/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     *\/\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\/**\n * @dev {ERC1155} token, including:\n *\n *  - a minter role that allows for token minting (creation)\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter role, as well\n * as the default admin role, which will let it grant minter role to other accounts.\n *\/\ncontract ERC1155YuzuInternal is Ownable, AccessControl, ERC1155Supply {\n    \n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    uint256 internal _tokenIdCounter;\n    bool public anyoneCanMint;\n\n    \/**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, and `MINTER_ROLE` to the account that\n     * deploys the contract. And initializes the contract by setting a `name` \n     * and a `symbol` to the token collection.\n     *\/\n    constructor(address owner, string memory uri, string memory name_, string memory symbol_, bool anyoneCanMint_) Ownable() ERC1155(uri) {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(MINTER_ROLE, owner);\n        transferOwnership(owner);\n        _name = name_;\n        _symbol = symbol_;\n        anyoneCanMint = anyoneCanMint_;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-name}.\n     *\/\n    function name() external view virtual returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-symbol}.\n     *\/\n    function symbol() external view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev Find next available tokenId\n     *\/\n    function findNextTokenId() internal {\n        do {\n          _tokenIdCounter++;\n        } while(exists(_tokenIdCounter));\n    }\n\n    \/**\n     * @dev Creates `amount` new tokens for `to`, using the next available `id`.\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function autoMint(address to, uint256 amount) public onlyMinter returns (uint256) {\n        findNextTokenId();\n        _mint(to, _tokenIdCounter, amount, \"0x\");\n        return _tokenIdCounter;\n    }\n\n    \/**\n     * @dev Creates `amounts` new tokens for `to`, using the next available `ids`.\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function autoMintBatch(address to, uint256[] memory amounts) public onlyMinter {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        for (uint256 i = 0; i < amounts.length; i++) {\n            autoMint(to, amounts[i]);\n        }\n    }\n\n    \/**\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\n     *\n     * See {ERC1155-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual onlyMinter {\n        _mint(to, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\n     *\/\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual onlyMinter {\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControl, ERC1155)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function addMinter(address account) external onlyMinter {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    function canIMint() public view returns (bool) {\n        return anyoneCanMint || isMinter(msg.sender);\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        string memory mensaje;\n        require(\n            canIMint(),\n            \"ERC1155Yuzu: must have minter role to mint\"\n        );\n        _;\n    }\n\n}\n\n\/**\n * @title ERC1155Ikasumi\n * ERC-721 Marketplace with tokens and royalties support\n *\/\ncontract ERC1155Marketplace is ERC1155YuzuInternal, ReentrancyGuard {\n\n    using Address for address;\n\n    \/\/ admin address, the owner of the marketplace\n    address public admin;\n\n    \/\/ IERC20 token to be used for payments\n    IERC20 public paymentToken;\n\n    \/\/ commission rate is a value from 0 to 100\n    uint256 public commissionRate;\n\n    \/\/ royalties commission rate is a value from 0 to 100\n    uint256 public royaltiesCommissionRate;\n\n    \/\/ nft item creators list, used to pay royalties\n    mapping(uint256 => address) public creators;\n    \n    \/\/ a sale object\n    struct Sale {\n        uint256 qty;    \/\/ qty for sale\n        uint256 price;  \/\/ price \n        address user;   \/\/ seller\n        address wallet; \/\/ seller wallet\n    }\n\n    \/\/ opened sales by tokenIds\n    mapping(uint256 => Sale[]) public openSales;\n\n    \/\/ length of the array\n    mapping(uint256 => uint256) public openSalesLength;\n\n    \/\/ a buy offer object\n    struct Offer {\n        uint256 qty;    \/\/ qty for buying\n        uint256 price;  \/\/ buy price \n        address user;   \/\/ buyer\n    }\n\n    \/\/ opened offers by tokenIds\n    mapping(uint256 => Offer[]) public openOffers;\n\n    \/\/ length of the array\n    mapping(uint256 => uint256) public openOffersLength;\n\n    event Bid(        uint256 indexed tokenId, address indexed from,   uint256 qty,         uint256 price);\n    event Sell(       uint256 indexed tokenId, address indexed to,     uint256 qty,         uint256 price);\n    event Commission( uint256 indexed tokenId, address indexed from,   address indexed to,  uint256 value);\n    event Royalty(    uint256 indexed tokenId, address indexed from,   address indexed to,  uint256 value);\n    event Buy(        uint256 indexed tokenId, address indexed from,   address indexed to,  uint256 value);\n\n    event CancelSale(uint256 indexed tokenId, uint256 index);\n    event CancelBid(uint256 indexed tokenId, uint256 index);\n\n    constructor(\n        IERC20 _paymentToken, address _owner, address _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, \n        string memory name, string memory symbol, bool _anyoneCanMint, string memory uri) \n        ERC1155YuzuInternal(_owner, uri, name, symbol, _anyoneCanMint)\n    {\n        require(_commissionRate + _royaltiesCommissionRate < 100, \"Ikasumi: total commissions should be lower than 100\");\n        admin = _admin;\n        commissionRate = _commissionRate;\n        royaltiesCommissionRate = _royaltiesCommissionRate;\n        paymentToken = _paymentToken;\n    }\n\n    \/**\n     * Any user can sell X items at Y price each, valid ownership and qty of the sell will be handled by the UI\n     * All selling options are shown as \u201cListings\u201d in the UI\n     * Any user can buy W items at Y price, of one listing, they cannot combine two listings in one transaction, given that W>0 and W<=Y\n     * Restrictions:\n     *    Limit the sell to owned items, the user cannot sell items do not have\n     *\/\n    \n    function sell(uint256 tokenId, uint256 qty, uint256 price, address wallet) external {\n\n        \/\/ Limit the sell to owned items, the user cannot sell items do not have\n        require(balanceOf(_msgSender(), tokenId) >= qty, \"Ikasumi: you do not have enough tokens to sell\");\n\n        \/\/ set approval for all items of the user is not set already\n        if (!isApprovedForAll(_msgSender(), address(this))) {\n            setApprovalForAll(address(this), true);\n        }\n\n        \/\/ add the selling option to openSales\n        Sale memory sale = Sale(qty, price, _msgSender(), wallet);\n\n        \/\/ An owner can add only one selling listing for one item at a time, new listings for one item will replace the old ones\n\n        openSales[tokenId].push(sale);\n        openSalesLength[tokenId] = openSales[tokenId].length;\n        emit Sell(tokenId, _msgSender(), qty, price);\n\n    }\n\n    \/**\n     * Buy an NTF item, specifying qty to buy and index offer\n     * Funds are transferred from the caller user directly, previous approval required\n     *\/\n    \n    function buy(uint256 tokenId, uint256 index, uint256 qty) external nonReentrant {\n\n        \/\/ validate user\n        require(openSales[tokenId][index].user != _msgSender() , \"Ikasumi: the user cannot buy his own offer\");\n\n        \/\/ transfer ownership\n        \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n        callOptionalReturn(this, abi.encodeWithSelector(this.safeTransferFrom.selector, openSales[tokenId][index].user, _msgSender(), tokenId, qty, \"0x\"));\n\n        \/**\n         * distribute funds between owner, creator and admin\n         * This function will transfer the funds from the buyer, which must have previously approve the funds to the contract, to the beneficiaries of the sale\n         * The \"true\" parameter at the end means: do a transferFrom\n         *\/ \n        distributeFunds(qty * openSales[tokenId][index].price, _msgSender(), openSales[tokenId][index].wallet, tokenId, true);\n\n        \/\/ substract items sold\n        openSales[tokenId][index].qty -= qty;\n\n        \/\/ remove the offer and reorder the array\n        if (openSales[tokenId][index].qty == 0) {\n            openSales[tokenId][index] = openSales[tokenId][openSales[tokenId].length-1];\n            openSales[tokenId].pop();\n            openSalesLength[tokenId] = openSales[tokenId].length;\n        }\n\n    }\n\n    \/\/ cancel the sale\n    function cancelSale(uint256 tokenId, uint256 index) external {\n\n        \/\/ Only the original bidder can cancel his bids\n        require(openSales[tokenId][index].user == _msgSender(), \"Ikasumi: only the original seller can cancel his sales\");\n\n        \/\/ remove the sale\n        openSales[tokenId][index] = openSales[tokenId][openSales[tokenId].length-1];\n        openSales[tokenId].pop();\n        openSalesLength[tokenId] = openSales[tokenId].length;\n\n        emit CancelSale(tokenId, index);\n\n    }\n\n    \/**\n     * Any user can make an offer of X items at Y price each\n     * Funds of the offer are stored on the contract\n     * All offers are shown as \u201cOffers\u201d in the UI\n     * Restrictions\n     *    A buyer cannot add an offer bigger than the total supply\n     *\/\n    \n    function bid(uint256 tokenId, uint256 qty, uint256 price) external nonReentrant {\n\n        require(qty>0, \"Iksasumi: qty has to be positive\");\n        require(price>0, \"Iksasumi: price has to be positive\");\n        require(qty <= totalSupply(tokenId), \"Iksasumi: not enough items for sale\");\n        \n        \/\/ transfer qty * price tokens to the contract\n        uint256 total = qty * price;\n        require(paymentToken.transferFrom(_msgSender(), address(this), total), \"Transfer failed.\");\n\n        \/\/ record the offer\n        Offer memory theBid = Offer(qty, price, _msgSender());\n\n        openOffers[tokenId].push(theBid);\n        openOffersLength[tokenId] = openOffers[tokenId].length;\n        emit Bid(tokenId, _msgSender(), qty, price);\n\n    }\n\n    \/\/ cancel the offer and return funds\n    function cancelBid(uint256 tokenId, uint256 index) external nonReentrant {\n\n        \/\/ Only the original bidder can cancel his bids\n        require(openOffers[tokenId][index].user == _msgSender(), \"Ikasumi: only the original bidder can cancel his bids\");\n\n        \/\/ save the total\n        uint256 total = openOffers[tokenId][index].qty * openOffers[tokenId][index].price;\n\n        \/\/ remove the bid\n        openOffers[tokenId][index] = openOffers[tokenId][openOffers[tokenId].length-1];\n        openOffers[tokenId].pop();\n        openOffersLength[tokenId] = openOffers[tokenId].length;\n\n        \/\/ return the funds\n        require(paymentToken.transfer(_msgSender(), total), \"Transfer failed.\");\n\n        emit CancelBid(tokenId, index);\n\n    }\n\n    \/\/ owner accepts the bid and distribute the funds\n    function acceptBid(uint256 tokenId, uint256 index, uint256 qty) external nonReentrant {\n\n        \/\/ validate user\n        require(openOffers[tokenId][index].user != _msgSender() , \"Ikasumi: the user cannot accept his own bid\");\n\n        \/\/ set approval for all items of the user is not set already\n        if (!isApprovedForAll(_msgSender(), address(this))) {\n            setApprovalForAll(address(this), true);\n        }\n\n        \/\/ transfer item to bidder\n        \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n        callOptionalReturn(this, abi.encodeWithSelector(this.safeTransferFrom.selector, _msgSender(), openOffers[tokenId][index].user, tokenId, qty, \"0x\"));\n\n        \/**\n         * distribute funds between owner, creator and admin\n         * This function will transfer the funds from the contract, which must have previously sent to the contract, to the beneficiaries of the sale\n         * The \"false\" parameter at the end means: do a simple transfer\n         *\/ \n        distributeFunds(qty * openOffers[tokenId][index].price, openOffers[tokenId][index].user, _msgSender(), tokenId, false);\n\n        \/\/ substract items sold\n        openOffers[tokenId][index].qty -= qty;\n\n        \/\/ remove the offer and reorder the array\n        if (openOffers[tokenId][index].qty == 0) {\n            openOffers[tokenId][index] = openOffers[tokenId][openOffers[tokenId].length-1];\n            openOffers[tokenId].pop();\n            openOffersLength[tokenId] = openOffers[tokenId].length;\n        }\n    }\n\n    \/**\n     * do the funds distribution between owner, creator and admin\n     * @param totalPrice the total value to distribute\n     * @param from if useTransferFrom is true then the \"from\" is the origin of the funds, if false, then the \"from\" is only used for logs purposes\n     * @param to is the owner of the token on sale \/ bid\n     * @param tokenId is the token being sold\n     * @param useTransferFrom if true the transfer will be made from to, if not, a simple transfer will be done from the contract to the beneficiaries\n     *\/\n\n    function distributeFunds(uint256 totalPrice, address from, address to, uint256 tokenId, bool useTransferFrom) internal {\n\n        \/\/ calculate amounts\n        uint256 amount4admin = totalPrice * commissionRate \/ 100;\n        uint256 amount4creator = totalPrice * royaltiesCommissionRate \/ 100;\n        uint256 amount4owner = totalPrice - amount4admin - amount4creator;\n\n        \/\/ to owner\n        if (useTransferFrom) {\n            require(paymentToken.transferFrom(from, to, amount4owner), \"Transfer failed.\");\n        } else {\n            require(paymentToken.transfer(to, amount4owner), \"Transfer failed.\");\n        }\n        emit Buy(tokenId, from, to, amount4owner);\n\n        \/\/ to creator\n        if (amount4creator>0) {\n            if (useTransferFrom) {\n                require(paymentToken.transferFrom(from, creators[tokenId], amount4creator), \"Transfer failed.\");\n            } else {\n                require(paymentToken.transfer(creators[tokenId], amount4creator), \"Transfer failed.\");\n            }\n            emit Royalty(tokenId, from, creators[tokenId], amount4creator);\n        }\n\n        \/\/ to admin\n        if (amount4admin>0) {\n            if (useTransferFrom) {\n                require(paymentToken.transferFrom(from, admin, amount4admin), \"Transfer failed.\");\n            } else {\n                require(paymentToken.transfer(admin, amount4admin), \"Transfer failed.\");\n            }\n            emit Commission(tokenId, from, admin, amount4admin);\n        }\n\n    }\n\n    \/\/\/ Overrides minting function to keep track of item creators\n\n    function _mint(address to, uint256 tokenId, uint256 amount, bytes memory data) override internal {\n        creators[tokenId] = _msgSender();\n        super._mint(to, tokenId, amount, data);\n    }\n\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) override internal {\n        super._mintBatch(to, ids, amounts, data);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            creators[ids[i]] = _msgSender();\n        }\n    }\n\n    \/**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\/\n    function callOptionalReturn(IERC1155 token, bytes memory data) private {\n        \/\/ We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        \/\/ we're implementing it ourselves.\n\n        \/\/ A Solidity high level call has three parts:\n        \/\/  1. The target address is checked to verify it contains contract code\n        \/\/  2. The call itself is made, and success asserted\n        \/\/  3. The return value is decoded, which in turn checks the size of the returned data.\n        \/\/ solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"Ikasumi: call to non-contract\");\n\n        \/\/ solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"Ikasumi: low-level call failed\");\n\n        if (returndata.length > 0) { \/\/ Return data is optional\n            \/\/ solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"Ikasumi: ERC20 operation did not succeed\");\n        }\n    }\n\n    \/\/ update contract fields\n    function updateAdmin(address _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, bool _anyoneCanMint, IERC20 _paymentToken) external onlyOwner() {\n        require(_commissionRate + _royaltiesCommissionRate < 100, \"Ikasumi: total commissions should be lower than 100\");\n        admin = _admin;\n        commissionRate = _commissionRate;\n        royaltiesCommissionRate = _royaltiesCommissionRate;\n        anyoneCanMint = _anyoneCanMint;\n        paymentToken = _paymentToken;\n    }\n    \n}\n\n\/**\n * Marketplace with Lazy Minting feature\n *\/\ncontract ERC1155Ikasumi is ERC1155Marketplace, EIP712 {\n    string private constant SIGNING_DOMAIN = \"ERC1155Ikasumi-Voucher\";\n    string private constant SIGNATURE_VERSION = \"1\";\n\n    constructor(IERC20 _paymentToken, address _owner, address _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, \n        string memory name, string memory symbol, bool _anyoneCanMint, string memory uri)\n        ERC1155Marketplace(_paymentToken, _owner, _admin, _commissionRate, _royaltiesCommissionRate, name, symbol, _anyoneCanMint, uri)\n        EIP712(SIGNING_DOMAIN, SIGNATURE_VERSION) {}\n\n    \/\/ minted qty for each voucher ID\n    mapping(uint256 => uint256) public vouchersMintedQty;\n\n    \/\/ minted NFT ID for each voucher ID\n    mapping(uint256 => uint256) public vouchersNFTIds;\n\n    event LazyMint(uint256 indexed tokenId, address indexed from, address indexed to, uint256 value);\n\n    \/\/\/ @notice Redeems an NFTVoucher for an actual NFT, creating it in the process.\n    function redeem(\n        uint256 nftId, uint256 id, uint256 nftPostId, uint256 qty, uint256 price, uint256 collectionId, uint256 chainId, address author, uint256 salt, bytes memory signature, uint256 qtyToMint\n    ) external nonReentrant {\n\n        require(chainId == getChainId(), \"Ikasumi: Wrong chain\");\n        require(vouchersMintedQty[id] + qtyToMint <= qty, \"Ikasumi: the qty exceeds the amount available for minting\");\n        require(nftId == 0 || exists(nftId), \"Ikasumi: Wrong NFT ID\");\n\n        \/\/ make sure signature is valid and get the address of the signer\n        verify(id, nftPostId, qty, price, collectionId, chainId, author, salt, address(this), signature, owner());\n\n        \/\/ allow to mint less qty of the amounts in voucher, until all qtys are minted\n        \/\/ first time minting? find the next available tokenId or use the existing NFT Id if it was passed to the function\n        if (vouchersNFTIds[id]==0) { \n            if (nftId>0) {\n                vouchersNFTIds[id] = nftId;\n            } else {\n                findNextTokenId();\n                vouchersNFTIds[id] = _tokenIdCounter;\n            }\n        }\n\n        \/\/ mint the items\n        _mint(_msgSender(), vouchersNFTIds[id], qtyToMint, '0x');\n\n        \/\/ manually set the creator \/ author for the tokenId just minted\n        \/\/ the author is set by the contract owner in the signed message, and this is meant to receive royalties\n        creators[vouchersNFTIds[id]] = author;\n\n        \/\/ distribute payments\n        distributeFunds(qtyToMint * price, _msgSender(), owner(), vouchersNFTIds[id], true);\n\n        \/\/ Inform the Lazy Mint\n        emit LazyMint(vouchersNFTIds[id], _msgSender(), owner(), qtyToMint * price);\n\n        \/\/ keep track of minted qties\n        vouchersMintedQty[id] += qtyToMint;\n\n    }\n\n    function domainSeparator() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function verify(\n        uint256 id,\n        uint256 nftPostId,\n        uint256 qty,\n        uint256 price,\n        uint256 collectionId,\n        uint256 chainId,\n        address author,\n        uint256 salt,\n        address thisContract,\n        bytes memory signature,\n        address signer\n    ) internal view {\n        bytes32 digest = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\"NFTVoucher(uint256 id,uint256 nftPostId,uint256 qty,uint256 price,uint256 collectionId,uint256 chainId,address author,uint256 salt,address thisContract)\"), \n                    id, nftPostId, qty, price, collectionId, chainId, author, salt, thisContract\n                )\n            )\n        );\n        address recoveredSigner = ECDSA.recover(digest, signature);\n        require(recoveredSigner == signer, \"Ikasumi: wrong signature\");\n    }\n\n    function getChainId() public view returns (uint256) {\n        return block.chainid;\n    }\n\n}",
                "contractName": "ERC1155Ikasumi",
                "version": "1.0",
                "compilerVersion": "v0.8.2"
            },
            "2.0": {
                "abi_factory": [{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_payment_token","type":"address"},{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"uint256","name":"_royaltiesCommissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint8","name":"_whoCanMint","type":"uint8"},{"internalType":"string","name":"uri","type":"string"},{"internalType":"address","name":"_affiliate","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "abi_factory_wpic": [{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_payment_token","type":"address"},{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"uint256","name":"_royaltiesCommissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint8","name":"_whoCanMint","type":"uint8"},{"internalType":"string","name":"uri","type":"string"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n *\/\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \/\/ no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    \/**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https:\/\/web3js.readthedocs.io\/en\/v1.3.4\/web3-eth-accounts.html#sign[Web3.js]\n     * - with https:\/\/docs.ethers.io\/v5\/api\/signer\/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        \/\/ Check the signature length\n        \/\/ - case 65: r,s,v signature (standard)\n        \/\/ - case 64: r,vs signature (cf https:\/\/eips.ethereum.org\/EIPS\/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            \/\/ ecrecover takes the signature parameters, and the only way to get them\n            \/\/ currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            \/\/ ecrecover takes the signature parameters, and the only way to get them\n            \/\/ currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    \/**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\/\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https:\/\/eips.ethereum.org\/EIPS\/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        \/\/ EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        \/\/ unique. Appendix F in the Ethereum Yellow paper (https:\/\/ethereum.github.io\/yellowpaper\/paper.pdf), defines\n        \/\/ the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\n        \/\/ signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        \/\/\n        \/\/ If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        \/\/ with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        \/\/ vice versa. If your library also generates signatures with 0\/1 for v instead 27\/28, add 27 to v to accept\n        \/\/ these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        \/\/ If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    \/**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     *\/\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\u0019\u0001\", domainSeparator, structHash));\n    }\n}\n\n\/**\n * @dev https:\/\/eips.ethereum.org\/EIPS\/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https:\/\/docs.metamask.io\/guide\/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\/\nabstract contract EIP712 {\n    \/* solhint-disable var-name-mixedcase *\/\n    \/\/ Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    \/\/ invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    \/* solhint-enable var-name-mixedcase *\/\n\n    \/**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     *\/\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    \/**\n     * @dev Returns the domain separator for the current chain.\n     *\/\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    \/**\n     * @dev Given an already https:\/\/eips.ethereum.org\/EIPS\/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     *\/\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n *\/\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-1155[EIP].\n *\n * _Available since v3.1._\n *\/\ninterface IERC1155 is IERC165 {\n    \/**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     *\/\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    \/**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     *\/\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    \/**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     *\/\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    \/**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     *\/\n    event URI(string value, uint256 indexed id);\n\n    \/**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     *\/\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    \/**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     *\/\n    function setApprovalForAll(address operator, bool approved) external;\n\n    \/**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     *\/\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    \/**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n\n\/**\n * @dev _Available since v3.1._\n *\/\ninterface IERC1155Receiver is IERC165 {\n    \/**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    \/**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n *\/\ninterface IERC1155MetadataURI is IERC1155 {\n    \/**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     *\/\n    function uri(uint256 id) external view returns (string memory);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https:\/\/solidity.readthedocs.io\/en\/latest\/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n\/**\n * @dev Implementation of the basic standard multi-token.\n * See https:\/\/eips.ethereum.org\/EIPS\/eip-1155\n * Originally based on code by Enjin: https:\/\/github.com\/enjin\/erc-1155\n *\n * _Available since v3.1._\n *\/\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    \/\/ Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    \/\/ Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/\/ Used as the URI for all token types by relying on ID substitution, e.g. https:\/\/token-cdn-domain\/{id}.json\n    string private _uri;\n\n    \/**\n     * @dev See {_setURI}.\n     *\/\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     *\/\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    \/**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    \/**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     *\/\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    \/**\n     * @dev See {IERC1155-setApprovalForAll}.\n     *\/\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    \/**\n     * @dev See {IERC1155-isApprovedForAll}.\n     *\/\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    \/**\n     * @dev See {IERC1155-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    \/**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     *\/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https:\/\/token-cdn-domain\/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https:\/\/token-cdn-domain\/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     *\/\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    \/**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n}\n\n\/**\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\n *\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\n * clearly identified. Note: While a totalSupply of 1 might mean the\n * corresponding is an NFT, there is no guarantees that no other token with the\n * same id are not going to be minted.\n *\/\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    \/**\n     * @dev Total amount of tokens in with a given id.\n     *\/\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    \/**\n     * @dev Indicates weither any token exist with a given id, or not.\n     *\/\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n\n    \/**\n     * @dev See {ERC1155-_mint}.\n     *\/\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual override {\n        super._mint(account, id, amount, data);\n        _totalSupply[id] += amount;\n    }\n\n    \/**\n     * @dev See {ERC1155-_mintBatch}.\n     *\/\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._mintBatch(to, ids, amounts, data);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            _totalSupply[ids[i]] += amounts[i];\n        }\n    }\n\n}\n\n\/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\/\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \/**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     *\/\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    \/**\n     * @dev Returns the address of the current owner.\n     *\/\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    \/**\n     * @dev Throws if called by any account other than the owner.\n     *\/\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\/\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    \/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     *\/\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\/**\n * @dev {ERC1155} token, including:\n *\n *  - a minter role that allows for token minting (creation)\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter role, as well\n * as the default admin role, which will let it grant minter role to other accounts.\n *\/\ncontract ERC1155_Yuzu is Ownable, AccessControl, ERC1155Supply {\n    \n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    uint256 internal _tokenIdCounter;\n\n    \/**\n     * Special setting to give special minting permissions\n     * whoCanMint = 0: only minter can mint\n     * whoCanMint = 1: only original creator of the Item can mint, multiple times\n     * whoCanMint = 2: anyone can arbitrarily mint\n     *\/\n    uint8 public whoCanMint;\n\n    \/\/ nft item creators list, used to pay royalties\n    mapping(uint256 => address) public creators;\n    \n    \/**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, and `MINTER_ROLE` to the account that\n     * deploys the contract. And initializes the contract by setting a `name` \n     * and a `symbol` to the token collection.\n     *\/\n    constructor(address owner, string memory uri, string memory name_, string memory symbol_, uint8 whoCanMint_) Ownable() ERC1155(uri) {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(MINTER_ROLE, owner);\n        transferOwnership(owner);\n        _name = name_;\n        _symbol = symbol_;\n        whoCanMint = whoCanMint_;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-name}.\n     *\/\n    function name() external view virtual returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-symbol}.\n     *\/\n    function symbol() external view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev Find next available tokenId\n     *\/\n    function findNextTokenId() internal {\n        do {\n          _tokenIdCounter++;\n        } while(exists(_tokenIdCounter));\n    }\n\n    \/\/\/ Overrides minting function to keep track of item creators\n\n    function _mint(address to, uint256 tokenId, uint256 amount, bytes memory data) internal virtual override {\n        creators[tokenId] = _msgSender();\n        super._mint(to, tokenId, amount, data);\n    }\n\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual override {\n        super._mintBatch(to, ids, amounts, data);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            creators[ids[i]] = _msgSender();\n        }\n    }\n\n    \/**\n     * @dev Creates `amount` new tokens for `to`, using the next available `id`.\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function autoMint(address to, uint256 amount) public onlyMinter returns (uint256) {\n        findNextTokenId();\n        _mint(to, _tokenIdCounter, amount, \"0x\");\n        return _tokenIdCounter;\n    }\n\n    \/**\n     * @dev Creates `amounts` new tokens for `to`, using the next available `ids`.\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function autoMintBatch(address to, uint256[] memory amounts) external onlyMinter {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        for (uint256 i = 0; i < amounts.length; i++) {\n            autoMint(to, amounts[i]);\n        }\n    }\n\n    \/**\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\n     *\n     * See {ERC1155-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external virtual canMint(id) {\n        _mint(to, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\n     *\/\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external virtual onlyMinter {\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControl, ERC1155)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function addMinter(address account) external onlyMinter {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    \/**\n     * Check if a user can mint, and optionally check if an user can mint more of an specific token\n     * Who can mint?\n     * Case 1: a minter can mint\n     * Case 2: a creator can mint more items if he is allowed to\n     * Case 3: arbitrary minting is possible if set (not recommended)\n     * @param _id: NFT token ID (optional)\n     *\/\n    function canIMint(uint256 _id) public view returns (bool) {\n        return  isMinter(msg.sender) || \/\/ a minter can mint\n                (whoCanMint == 1 && _id == 0) || \/\/ a creator can mint for the first time any item\n                (whoCanMint == 1 && _id > 0 && creators[_id] == msg.sender) || \/\/ a creator can add more items to its own NFT items\n                whoCanMint == 2 \/\/ if anyone can mint, allow any mint request\n        ;\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        require(\n            canIMint(0), \/\/ it allows minters or anyone if anyone can mint is set\n            \"ERC1155Yuzu: must have minter role to mint\"\n        );\n        _;\n    }\n\n    \/**\n     * Open modifier to check who can mint, allowing the restriction that only creators can mint their own token\n     *\/\n    modifier canMint(uint256 _tokenId) {\n        require(\n            canIMint(_tokenId), \/\/ it allows minters or anyone if anyone can mint is set, but also check if only the creator can mint its token\n            \"ERC1155Yuzu: must have minter role to mint\"\n        );\n        _;\n    }\n\n}\n\n\/**\n *\n * ERC1155 Marketplace Ikasumi v.2\n * @title ERC1155Ikasumi\n * \n * ERC-1155 Marketplace with tokens and royalties support\n *\/\ncontract ERC1155Marketplace is ERC1155_Yuzu, ReentrancyGuard {\n\n    using Address for address;\n    using SafeERC20 for IERC20;\n\n    \/\/ admin address, the owner of the marketplace\n    address public admin;\n\n    \/\/ IERC20 token to be used for payments\n    IERC20 public paymentToken;\n\n    \/\/ commission rate is a value from 0 to 100\n    uint256 public commissionRate;\n\n    \/\/ royalties commission rate is a value from 0 to 100\n    uint256 public royaltiesCommissionRate;\n\n    \/\/ a sale object\n    struct Sale {\n        uint256 qty;    \/\/ qty for sale\n        uint256 price;  \/\/ price \n        address user;   \/\/ seller\n        address wallet; \/\/ seller wallet\n    }\n\n    \/\/ opened sales by tokenIds\n    mapping(uint256 => Sale[]) public openSales;\n\n    \/\/ length of the array\n    mapping(uint256 => uint256) public openSalesLength;\n\n    \/\/ a buy offer object\n    struct Offer {\n        uint256 qty;    \/\/ qty for buying\n        uint256 price;  \/\/ buy price \n        address user;   \/\/ buyer\n    }\n\n    \/\/ opened offers by tokenIds\n    mapping(uint256 => Offer[]) public openOffers;\n\n    \/\/ length of the array\n    mapping(uint256 => uint256) public openOffersLength;\n\n    event Bid(        uint256 indexed tokenId, address indexed from,   uint256 qty,         uint256 price);\n    event Sell(       uint256 indexed tokenId, address indexed to,     uint256 qty,         uint256 price);\n    event Commission( uint256 indexed tokenId, address indexed from,   address indexed to,  uint256 value);\n    event Royalty(    uint256 indexed tokenId, address indexed from,   address indexed to,  uint256 value);\n    event Buy(        uint256 indexed tokenId, address indexed from,   address indexed to,  uint256 value);\n\n    event CancelSale(uint256 indexed tokenId, uint256 index);\n    event CancelBid(uint256 indexed tokenId, uint256 index);\n\n    constructor(\n        IERC20 _paymentToken, address _owner, address _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, \n        string memory name, string memory symbol, uint8 _whoCanMint, string memory uri) \n        ERC1155_Yuzu(_owner, uri, name, symbol, _whoCanMint)\n    {\n        require(_commissionRate + _royaltiesCommissionRate < 100, \"Ikasumi: total commissions should be lower than 100\");\n        admin = _admin;\n        commissionRate = _commissionRate;\n        royaltiesCommissionRate = _royaltiesCommissionRate;\n        paymentToken = _paymentToken;\n    }\n\n    \/**\n     * Any user can sell X items at Y price each, valid ownership and qty of the sell will be handled by the UI\n     * All selling options are shown as \u201cListings\u201d in the UI\n     * Any user can buy W items at Y price, of one listing, they cannot combine two listings in one transaction, given that W>0 and W<=Y\n     * Restrictions:\n     *    Limit the sell to owned items, the user cannot sell items do not have\n     *\/\n    \n    function sell(uint256 tokenId, uint256 qty, uint256 price, address wallet) external {\n\n        \/\/ Limit the sell to owned items, the user cannot sell items do not have\n        require(balanceOf(_msgSender(), tokenId) >= qty, \"Ikasumi: you do not have enough tokens to sell\");\n\n        \/\/ set approval for all items of the user is not set already\n        if (!isApprovedForAll(_msgSender(), address(this))) {\n            setApprovalForAll(address(this), true);\n        }\n\n        \/\/ add the selling option to openSales\n        Sale memory sale = Sale(qty, price, _msgSender(), wallet);\n\n        \/\/ An owner can add only one selling listing for one item at a time, new listings for one item will replace the old ones\n\n        openSales[tokenId].push(sale);\n        openSalesLength[tokenId] = openSales[tokenId].length;\n        emit Sell(tokenId, _msgSender(), qty, price);\n\n    }\n\n    \/**\n     * Buy an NTF item, specifying qty to buy and index offer\n     * Funds are transferred from the caller user directly, previous approval required\n     *\/\n    \n    function buy(uint256 tokenId, uint256 index, uint256 qty) external nonReentrant {\n\n        \/\/ validate user\n        require(openSales[tokenId][index].user != _msgSender() , \"Ikasumi: the user cannot buy his own offer\");\n\n        \/\/ transfer ownership\n        \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n        callOptionalReturn(this, abi.encodeWithSelector(this.safeTransferFrom.selector, openSales[tokenId][index].user, _msgSender(), tokenId, qty, \"0x\"));\n\n        \/**\n         * distribute funds between owner, creator and admin\n         * This function will transfer the funds from the buyer, which must have previously approve the funds to the contract, to the beneficiaries of the sale\n         * The \"true\" parameter at the end means: do a transferFrom\n         *\/ \n        distributeFunds(qty * openSales[tokenId][index].price, _msgSender(), openSales[tokenId][index].wallet, tokenId, true);\n\n        \/\/ substract items sold\n        openSales[tokenId][index].qty -= qty;\n\n    }\n\n    \/\/ cancel the sale\n    function cancelSale(uint256 tokenId, uint256 index) external {\n\n        \/\/ Only the original bidder can cancel his bids\n        require(openSales[tokenId][index].user == _msgSender(), \"Ikasumi: only the original seller can cancel his sales\");\n\n        \/\/ remove the sale\n        openSales[tokenId][index].qty = 0;\n\n        emit CancelSale(tokenId, index);\n\n    }\n\n    \/**\n     * Any user can make an offer of X items at Y price each\n     * Funds of the offer are stored on the contract\n     * All offers are shown as \u201cOffers\u201d in the UI\n     * Restrictions\n     *    A buyer cannot add an offer bigger than the total supply\n     *\/\n    \n    function bid(uint256 tokenId, uint256 qty, uint256 price) external nonReentrant {\n\n        require(qty>0, \"Iksasumi: qty has to be positive\");\n        require(price>0, \"Iksasumi: price has to be positive\");\n        require(qty <= totalSupply(tokenId), \"Iksasumi: not enough items for sale\");\n        \n        \/\/ transfer qty * price tokens to the contract\n        uint256 total = qty * price;\n        paymentToken.safeTransferFrom(_msgSender(), address(this), total);\n\n        \/\/ record the offer\n        Offer memory theBid = Offer(qty, price, _msgSender());\n\n        openOffers[tokenId].push(theBid);\n        openOffersLength[tokenId] = openOffers[tokenId].length;\n        emit Bid(tokenId, _msgSender(), qty, price);\n\n    }\n\n    \/\/ cancel the offer and return funds\n    function cancelBid(uint256 tokenId, uint256 index) external nonReentrant {\n\n        \/\/ Only the original bidder can cancel his bids\n        require(openOffers[tokenId][index].user == _msgSender(), \"Ikasumi: only the original bidder can cancel his bids\");\n\n        \/\/ save the total\n        uint256 total = openOffers[tokenId][index].qty * openOffers[tokenId][index].price;\n\n        \/\/ remove the bid\n        openOffers[tokenId][index].qty = 0;\n\n        \/\/ return the funds\n        paymentToken.safeTransfer(_msgSender(), total);\n\n        emit CancelBid(tokenId, index);\n\n    }\n\n    \/\/ owner accepts the bid and distribute the funds\n    function acceptBid(uint256 tokenId, uint256 index, uint256 qty) external nonReentrant {\n\n        \/\/ validate user\n        require(openOffers[tokenId][index].user != _msgSender() , \"Ikasumi: the user cannot accept his own bid\");\n\n        \/\/ set approval for all items of the user is not set already\n        if (!isApprovedForAll(_msgSender(), address(this))) {\n            setApprovalForAll(address(this), true);\n        }\n\n        \/\/ transfer item to bidder\n        \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n        callOptionalReturn(this, abi.encodeWithSelector(this.safeTransferFrom.selector, _msgSender(), openOffers[tokenId][index].user, tokenId, qty, \"0x\"));\n\n        \/**\n         * distribute funds between owner, creator and admin\n         * This function will transfer the funds from the contract, which must have previously sent to the contract, to the beneficiaries of the sale\n         * The \"false\" parameter at the end means: do a simple transfer\n         *\/ \n        distributeFunds(qty * openOffers[tokenId][index].price, openOffers[tokenId][index].user, _msgSender(), tokenId, false);\n\n        \/\/ substract items sold\n        openOffers[tokenId][index].qty -= qty;\n\n    }\n\n    \/**\n     * do the funds distribution between owner, creator and admin\n     * @param totalPrice the total value to distribute\n     * @param from if useTransferFrom is true then the \"from\" is the origin of the funds, if false, then the \"from\" is only used for logs purposes\n     * @param to is the owner of the token on sale \/ bid\n     * @param tokenId is the token being sold\n     * @param useTransferFrom if true the transfer will be made from to, if not, a simple transfer will be done from the contract to the beneficiaries\n     *\/\n\n    function distributeFunds(uint256 totalPrice, address from, address to, uint256 tokenId, bool useTransferFrom) internal {\n\n        \/\/ calculate amounts\n        uint256 amount4admin = totalPrice * commissionRate \/ 100;\n        uint256 amount4creator = totalPrice * royaltiesCommissionRate \/ 100;\n        uint256 amount4owner = totalPrice - amount4admin - amount4creator;\n\n        \/\/ to owner\n        if (useTransferFrom) {\n            paymentToken.safeTransferFrom(from, to, amount4owner);\n        } else {\n            paymentToken.safeTransfer(to, amount4owner);\n        }\n        emit Buy(tokenId, from, to, amount4owner);\n\n        \/\/ to creator\n        if (amount4creator>0) {\n            if (useTransferFrom) {\n                paymentToken.safeTransferFrom(from, creators[tokenId], amount4creator);\n            } else {\n                paymentToken.safeTransfer(creators[tokenId], amount4creator);\n            }\n            emit Royalty(tokenId, from, creators[tokenId], amount4creator);\n        }\n\n        \/\/ to admin\n        if (amount4admin>0) {\n            if (useTransferFrom) {\n                paymentToken.safeTransferFrom(from, admin, amount4admin);\n            } else {\n                paymentToken.safeTransfer(admin, amount4admin);\n            }\n            emit Commission(tokenId, from, admin, amount4admin);\n        }\n\n    }\n\n    \/**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\/\n    function callOptionalReturn(IERC1155 token, bytes memory data) private {\n        \/\/ We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        \/\/ we're implementing it ourselves.\n\n        \/\/ A Solidity high level call has three parts:\n        \/\/  1. The target address is checked to verify it contains contract code\n        \/\/  2. The call itself is made, and success asserted\n        \/\/  3. The return value is decoded, which in turn checks the size of the returned data.\n        \/\/ solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"Ikasumi: call to non-contract\");\n\n        \/\/ solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"Ikasumi: low-level call failed\");\n\n        if (returndata.length > 0) { \/\/ Return data is optional\n            \/\/ solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"Ikasumi: ERC20 operation did not succeed\");\n        }\n    }\n\n    \/\/ update contract fields\n    function updateAdmin(address _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, uint8 _whoCanMint, IERC20 _paymentToken) external onlyOwner() {\n        require(_commissionRate + _royaltiesCommissionRate < 100, \"Ikasumi: total commissions should be lower than 100\");\n        admin = _admin;\n        commissionRate = _commissionRate;\n        royaltiesCommissionRate = _royaltiesCommissionRate;\n        whoCanMint = _whoCanMint;\n        paymentToken = _paymentToken;\n    }\n    \n}\n\n\/**\n * Marketplace with Lazy Minting feature\n *\/\ncontract ERC1155Ikasumi is ERC1155Marketplace, EIP712 {\n    string private constant SIGNING_DOMAIN = \"ERC1155Ikasumi-Voucher\";\n    string private constant SIGNATURE_VERSION = \"1\";\n\n    constructor(IERC20 _paymentToken, address _owner, address _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, \n        string memory name, string memory symbol, uint8 _whoCanMint, string memory uri)\n        ERC1155Marketplace(_paymentToken, _owner, _admin, _commissionRate, _royaltiesCommissionRate, name, symbol, _whoCanMint, uri)\n        EIP712(SIGNING_DOMAIN, SIGNATURE_VERSION) {}\n\n    \/\/ minted qty for each voucher ID\n    mapping(uint256 => uint256) public vouchersMintedQty;\n\n    \/\/ minted NFT ID for each voucher ID\n    mapping(uint256 => uint256) public vouchersNFTIds;\n\n    event LazyMint(uint256 indexed tokenId, address indexed from, address indexed to, uint256 value);\n\n    \/\/\/ @notice Redeems an NFTVoucher for an actual NFT, creating it in the process.\n    function redeem(\n        uint256 nftId, uint256 id, uint256 nftPostId, uint256 qty, uint256 price, uint256 collectionId, uint256 chainId, address author, uint256 salt, bytes memory signature, uint256 qtyToMint\n    ) external nonReentrant {\n\n        require(chainId == getChainId(), \"Ikasumi: Wrong chain\");\n        require(vouchersMintedQty[id] + qtyToMint <= qty, \"Ikasumi: the qty exceeds the amount available for minting\");\n        require(nftId == 0 || exists(nftId), \"Ikasumi: Wrong NFT ID\");\n\n        \/\/ make sure signature is valid and get the address of the signer\n        verify(id, nftPostId, qty, price, collectionId, chainId, author, salt, address(this), signature, owner());\n\n        \/\/ allow to mint less qty of the amounts in voucher, until all qtys are minted\n        \/\/ first time minting? find the next available tokenId or use the existing NFT Id if it was passed to the function\n        if (vouchersNFTIds[id]==0) { \n            if (nftId>0) {\n                vouchersNFTIds[id] = nftId;\n            } else {\n                findNextTokenId();\n                vouchersNFTIds[id] = _tokenIdCounter;\n            }\n        }\n\n        \/\/ mint the items\n        _mint(_msgSender(), vouchersNFTIds[id], qtyToMint, '0x');\n\n        \/\/ manually set the creator \/ author for the tokenId just minted\n        \/\/ the author is set by the contract owner in the signed message, and this is meant to receive royalties\n        creators[vouchersNFTIds[id]] = author;\n\n        \/\/ distribute payments\n        distributeFunds(qtyToMint * price, _msgSender(), owner(), vouchersNFTIds[id], true);\n\n        \/\/ Inform the Lazy Mint\n        emit LazyMint(vouchersNFTIds[id], _msgSender(), owner(), qtyToMint * price);\n\n        \/\/ keep track of minted qties\n        vouchersMintedQty[id] += qtyToMint;\n\n    }\n\n    function domainSeparator() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function verify(\n        uint256 id,\n        uint256 nftPostId,\n        uint256 qty,\n        uint256 price,\n        uint256 collectionId,\n        uint256 chainId,\n        address author,\n        uint256 salt,\n        address thisContract,\n        bytes memory signature,\n        address signer\n    ) internal view {\n        bytes32 digest = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\"NFTVoucher(uint256 id,uint256 nftPostId,uint256 qty,uint256 price,uint256 collectionId,uint256 chainId,address author,uint256 salt,address thisContract)\"), \n                    id, nftPostId, qty, price, collectionId, chainId, author, salt, thisContract\n                )\n            )\n        );\n        address recoveredSigner = ECDSA.recover(digest, signature);\n        require(recoveredSigner == signer, \"Ikasumi: wrong signature\");\n    }\n\n    function getChainId() public view returns (uint256) {\n        return block.chainid;\n    }\n\n}",
                "contractName": "ERC1155Ikasumi",
                "version": "2.0",
                "compilerVersion": "v0.8.2"
            }            
        }
    },
    "azuki": {
        "data": {
            "1.0": {
                "abi_factory": [{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"},{"internalType":"address payable","name":"_masterAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"newContract","type":"event"},{"inputs":[],"name":"buyCoffee","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"uint256","name":"_royaltiesCommissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"bool","name":"_anyoneCanMint","type":"bool"},{"internalType":"string","name":"uri","type":"string"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"enableTea","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"master","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"_masterAddress","type":"address"}],"name":"updateMasterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\n\n\/**\n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKKKXXXXKKKKKKXXNWWMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKKXXNWWWWMMWWWWMWWWWNXXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNXKKKXNWMMMMMMMMMNOdxKWMMMMMMMMWNXKKKXNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWXKKKNWMMMMMMMMMMMMNx:;;l0WMMMMMMMMMMMWNK0KXWMMMMMMMMMMMM\nMMMMMMMMMMMWXKKXWMMMMMMMMMMMMMMXd:;;;;cOWMMMMMMMMMMMMMWXKKXWMMMMMMMMMM\nMMMMMMMMMWNKKXWMMMMMMMMMMMMMMWKo;;col:;:kNMMMMMMMMMMMMMMWX0KNWMMMMMMMM\nMMMMMMMMWX0XWMMMMMMMMMMMMMMMWOl;;oKWXkc;:dXMMMMMMMMMMMMMMMWX0XWMMMMMMM\nMMMMMMMNKKNWMMMMMMMMMMMMMMMNkc;:dXMMMWOc;;oKWMMMMMMMMMMMMMMWNKKNMMMMMM\nMMMMMMNKKNMMMMMMMMMMMMMMMMNx:;:xNMMMMMW0l;;l0WMMMMMMMWMMMMMMMNKKNMMMMM\nMMMMMNKKNMMMMMMMMMMMMMMMMXd:;ckNMMMMMMMMKo:;cOWMMMMXkxkXWMMMMMNKKNMMMM\nMMMMWK0NMMMMMMMMMMMMMMMWKo;;l0WMMMMMMMMMMXx:;:xNMMW0lccxXMMMMMMN0KWMMM\nMMMMX0XWMMMMMMWWMMMMMMWOl;;oKWMMMMMMMMMMMMNkc;:dXMMNklcoKMMMMMMMX0XMMM\nMMMWKKNMMWK0OkkkkkkKWNkc;:dXMMMMMMMMMMMMMMMWOl;;oKWMXdcxNMMMMMMMNKKWMM\nMMMN0XWMMWNXX0OdlccdKOc;:xNMMMWXKKXNWNNNNWWMW0o;;l0WNkdKWMMMMMMMWX0NMM\nMMMX0XMMMMMMMMMN0dlcdOxoONMMMMW0xdddddodxk0KNWXd:;l0Kx0WMMMMMMMMMX0XMM\nMMMX0NMMMMMMMMMMWXxlcoOXWMMMMWKkolclodkKNNNNWWMNxcxOkKWMMMMMMMMMMX0XMM\nMMMX0XMMMMMMMMMMMMNklclkNMMWXklccodxdodKWMMMMMMMNKOkKWMMMMMMMMMMMX0XMM\nMMMN0XWMMMMMMMMMMMMNOoclxXN0occcdKX0xlco0WMMMMMMNOOXMMMMMMMMMMMMMX0NMM\nMMMWKKWMMMMMMMMMMMMMW0dccoxocccdKWMWNklclONMMMMXOONMMMMMMMMMMMMMWKKWMM\nMMMMX0XMMMMMMMMMMMMMMWKdcccccco0WMMMMNOoclkNWWKk0NMMMMMMMMMMMMMMX0XWMM\nMMMMWKKNMMMMMMMMMMMMMMMXxlcccckNMMMMMMW0oclxK0kKWMMMMMMMMMMMMMMNKKWMMM\nMMMMMN0KWMMMMMMMMMMMMMMMNklccoKWMMMMMMMWKdlcoxKWMMMMMMMMMMMMMMWK0NMMMM\nMMMMMMN0KWMMMMMMMMMMMMMMMNOod0KXWMMMMMMNK0xoxXWMMMMMMMMMMMMMMWK0NMMMMM\nMMMMMMMN0KNMMMMMMMMMMMMMMMWXKkll0WMMMMXdcoOKNMMMMMMMMMMMMMMMNK0NMMMMMM\nMMMMMMMMNK0XWMMMMMMMMMMMMMMMNd:;cOWMWKo:;c0WMMMMMMMMMMMMMMWX0KNMMMMMMM\nMMMMMMMMMWXKKNWMMMMMMMMMMMMMMXd:;cx0kl;;l0WMMMMMMMMMMMMMWNKKXWMMMMMMMM\nMMMMMMMMMMMWX0KNWMMMMMMMMMMMMMNkc;;::;:oKWMMMMMMMMMMMMWNK0XWMMMMMMMMMM\nMMMMMMMMMMMMMNXKKXNWMMMMMMMMMMMWOc;;;:dXMMMMMMMMMMMWNXKKXWMMMMMMMMMMMM\nMMMMMMMMMMMMMMMWNKKKXNWMMMMMMMMMW0l:ckNMMMMMMMMMWNXKKKNWMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMWNXKKKXXNWWWMMMMX0KWMMMWWWNXXKKKXNWMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWWNXXKKKKKXXXXXXXXXXKKKKXXNWWMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNNNNNNNNNNNWWWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n\n---------------------- [ WPSmartContracts.com ] ----------------------\n\n                       [ Blockchain Made Easy ]\n\n\n    |\n    |  ERC-1155 NFT Advanced Marketplace\n    |\n    |----------------------------\n    |\n    |  Flavors\n    |\n    |  >  Azuki v.1: Standard ERC-1155 Token with Marketplace\n    |\n    |                  > Native Coin Marketplace\n    |                  > Royalties\n    |                  > Lazy minting\n    |\n\n*\/\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n *\/\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \/\/ no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    \/**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https:\/\/web3js.readthedocs.io\/en\/v1.3.4\/web3-eth-accounts.html#sign[Web3.js]\n     * - with https:\/\/docs.ethers.io\/v5\/api\/signer\/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        \/\/ Check the signature length\n        \/\/ - case 65: r,s,v signature (standard)\n        \/\/ - case 64: r,vs signature (cf https:\/\/eips.ethereum.org\/EIPS\/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            \/\/ ecrecover takes the signature parameters, and the only way to get them\n            \/\/ currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            \/\/ ecrecover takes the signature parameters, and the only way to get them\n            \/\/ currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    \/**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\/\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https:\/\/eips.ethereum.org\/EIPS\/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     *\/\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        \/\/ EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        \/\/ unique. Appendix F in the Ethereum Yellow paper (https:\/\/ethereum.github.io\/yellowpaper\/paper.pdf), defines\n        \/\/ the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\n        \/\/ signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        \/\/\n        \/\/ If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        \/\/ with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        \/\/ vice versa. If your library also generates signatures with 0\/1 for v instead 27\/28, add 27 to v to accept\n        \/\/ these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        \/\/ If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\/\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    \/**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https:\/\/eth.wiki\/json-rpc\/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     *\/\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        \/\/ 32 is the length in bytes of hash,\n        \/\/ enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\u0019Ethereum Signed Message:\n32\", hash));\n    }\n\n    \/**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     *\/\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\u0019\u0001\", domainSeparator, structHash));\n    }\n}\n\n\/**\n * @dev https:\/\/eips.ethereum.org\/EIPS\/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https:\/\/docs.metamask.io\/guide\/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\/\nabstract contract EIP712 {\n    \/* solhint-disable var-name-mixedcase *\/\n    \/\/ Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    \/\/ invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    \/* solhint-enable var-name-mixedcase *\/\n\n    \/**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     *\/\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    \/**\n     * @dev Returns the domain separator for the current chain.\n     *\/\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    \/**\n     * @dev Given an already https:\/\/eips.ethereum.org\/EIPS\/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     *\/\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     *\/\n    function toString(uint256 value) internal pure returns (string memory) {\n        \/\/ Inspired by OraclizeAPI's implementation - MIT licence\n        \/\/ https:\/\/github.com\/oraclize\/ethereum-api\/blob\/b42146b063c7d6ee1358846c198246239e9360e8\/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp \/= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value \/= 10;\n        }\n        return string(buffer);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     *\/\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-1155[EIP].\n *\n * _Available since v3.1._\n *\/\ninterface IERC1155 is IERC165 {\n    \/**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     *\/\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    \/**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     *\/\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    \/**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     *\/\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    \/**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     *\/\n    event URI(string value, uint256 indexed id);\n\n    \/**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     *\/\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    \/**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     *\/\n    function setApprovalForAll(address operator, bool approved) external;\n\n    \/**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     *\/\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    \/**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n\n\/**\n * @dev _Available since v3.1._\n *\/\ninterface IERC1155Receiver is IERC165 {\n    \/**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    \/**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     *\/\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n *\/\ninterface IERC1155MetadataURI is IERC1155 {\n    \/**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     *\/\n    function uri(uint256 id) external view returns (string memory);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https:\/\/diligence.consensys.net\/posts\/2019\/09\/stop-using-soliditys-transfer-now\/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https:\/\/solidity.readthedocs.io\/en\/v0.5.11\/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\/\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \/**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https:\/\/solidity.readthedocs.io\/en\/latest\/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @dev Implementation of the basic standard multi-token.\n * See https:\/\/eips.ethereum.org\/EIPS\/eip-1155\n * Originally based on code by Enjin: https:\/\/github.com\/enjin\/erc-1155\n *\n * _Available since v3.1._\n *\/\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    \/\/ Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    \/\/ Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/\/ Used as the URI for all token types by relying on ID substitution, e.g. https:\/\/token-cdn-domain\/{id}.json\n    string private _uri;\n\n    \/**\n     * @dev See {_setURI}.\n     *\/\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     *\/\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    \/**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    \/**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     *\/\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    \/**\n     * @dev See {IERC1155-setApprovalForAll}.\n     *\/\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    \/**\n     * @dev See {IERC1155-isApprovedForAll}.\n     *\/\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    \/**\n     * @dev See {IERC1155-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    \/**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     *\/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https:\/\/token-cdn-domain\/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https:\/\/token-cdn-domain\/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     *\/\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    \/**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n\n\/**\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\n *\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\n * clearly identified. Note: While a totalSupply of 1 might mean the\n * corresponding is an NFT, there is no guarantees that no other token with the\n * same id are not going to be minted.\n *\/\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    \/**\n     * @dev Total amount of tokens in with a given id.\n     *\/\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    \/**\n     * @dev Indicates weither any token exist with a given id, or not.\n     *\/\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n\n    \/**\n     * @dev See {ERC1155-_mint}.\n     *\/\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual override {\n        super._mint(account, id, amount, data);\n        _totalSupply[id] += amount;\n    }\n\n    \/**\n     * @dev See {ERC1155-_mintBatch}.\n     *\/\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._mintBatch(to, ids, amounts, data);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            _totalSupply[ids[i]] += amounts[i];\n        }\n    }\n\n}\n\n\/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\/\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \/**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     *\/\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    \/**\n     * @dev Returns the address of the current owner.\n     *\/\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    \/**\n     * @dev Throws if called by any account other than the owner.\n     *\/\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\/\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    \/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     *\/\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\/**\n * @dev {ERC1155} token, including:\n *\n *  - a minter role that allows for token minting (creation)\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter role, as well\n * as the default admin role, which will let it grant minter role to other accounts.\n *\/\ncontract ERC1155YuzuInternal is Ownable, AccessControl, ERC1155Supply {\n    \n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    uint256 internal _tokenIdCounter;\n    bool public anyoneCanMint;\n\n    \/**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, and `MINTER_ROLE` to the account that\n     * deploys the contract. And initializes the contract by setting a `name` \n     * and a `symbol` to the token collection.\n     *\/\n    constructor(address owner, string memory uri, string memory name_, string memory symbol_, bool anyoneCanMint_) Ownable() ERC1155(uri) {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(MINTER_ROLE, owner);\n        transferOwnership(owner);\n        _name = name_;\n        _symbol = symbol_;\n        anyoneCanMint = anyoneCanMint_;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-name}.\n     *\/\n    function name() external view virtual returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-symbol}.\n     *\/\n    function symbol() external view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev Find next available tokenId\n     *\/\n    function findNextTokenId() internal {\n        do {\n          _tokenIdCounter++;\n        } while(exists(_tokenIdCounter));\n    }\n\n    \/**\n     * @dev Creates `amount` new tokens for `to`, using the next available `id`.\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function autoMint(address to, uint256 amount) public onlyMinter returns (uint256) {\n        findNextTokenId();\n        _mint(to, _tokenIdCounter, amount, \"0x\");\n        return _tokenIdCounter;\n    }\n\n    \/**\n     * @dev Creates `amounts` new tokens for `to`, using the next available `ids`.\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function autoMintBatch(address to, uint256[] memory amounts) external onlyMinter {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        for (uint256 i = 0; i < amounts.length; i++) {\n            autoMint(to, amounts[i]);\n        }\n    }\n\n    \/**\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\n     *\n     * See {ERC1155-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual onlyMinter {\n        _mint(to, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\n     *\/\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external virtual onlyMinter {\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControl, ERC1155)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function addMinter(address account) external onlyMinter {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    function canIMint() public view returns (bool) {\n        return anyoneCanMint || isMinter(msg.sender);\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        string memory mensaje;\n        require(\n            canIMint(),\n            \"ERC1155Yuzu: must have minter role to mint\"\n        );\n        _;\n    }\n\n}\n\n\/**\n * @title ERC1155Azuki\n * ERC-721 Marketplace with tokens and royalties support\n *\/\ncontract ERC1155Marketplace is ERC1155YuzuInternal, ReentrancyGuard {\n\n    using Address for address;\n\n    \/\/ admin address, the owner of the marketplace\n    address public admin;\n\n    \/\/ commission rate is a value from 0 to 100\n    uint256 public commissionRate;\n\n    \/\/ royalties commission rate is a value from 0 to 100\n    uint256 public royaltiesCommissionRate;\n\n    \/\/ nft item creators list, used to pay royalties\n    mapping(uint256 => address) public creators;\n    \n    \/\/ a sale object\n    struct Sale {\n        uint256 qty;    \/\/ qty for sale\n        uint256 price;  \/\/ price \n        address user;   \/\/ seller\n        address wallet; \/\/ seller wallet\n    }\n\n    \/\/ opened sales by tokenIds\n    mapping(uint256 => Sale[]) public openSales;\n\n    \/\/ length of the array\n    mapping(uint256 => uint256) public openSalesLength;\n\n    \/\/ a buy offer object\n    struct Offer {\n        uint256 qty;    \/\/ qty for buying\n        uint256 price;  \/\/ buy price \n        address user;   \/\/ buyer\n    }\n\n    \/\/ opened offers by tokenIds\n    mapping(uint256 => Offer[]) public openOffers;\n\n    \/\/ length of the array\n    mapping(uint256 => uint256) public openOffersLength;\n\n    event Bid(        uint256 indexed tokenId, address indexed from,   uint256 qty,         uint256 price);\n    event Sell(       uint256 indexed tokenId, address indexed to,     uint256 qty,         uint256 price);\n    event Commission( uint256 indexed tokenId, address indexed from,   address indexed to,  uint256 value);\n    event Royalty(    uint256 indexed tokenId, address indexed from,   address indexed to,  uint256 value);\n    event Buy(        uint256 indexed tokenId, address indexed from,   address indexed to,  uint256 value);\n\n    event CancelSale(uint256 indexed tokenId, uint256 index);\n    event CancelBid(uint256 indexed tokenId, uint256 index);\n\n    event Change(address beneficiary, uint256 value);\n\n    constructor(\n        address _owner, address _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, \n        string memory name, string memory symbol, bool _anyoneCanMint, string memory uri) \n        ERC1155YuzuInternal(_owner, uri, name, symbol, _anyoneCanMint)\n    {\n        require(_commissionRate + _royaltiesCommissionRate < 100, \"Azuki: total commissions should be lower than 100\");\n        admin = _admin;\n        commissionRate = _commissionRate;\n        royaltiesCommissionRate = _royaltiesCommissionRate;\n    }\n\n    \/**\n     * Any user can sell X items at Y price each, valid ownership and qty of the sell will be handled by the UI\n     * All selling options are shown as \u201cListings\u201d in the UI\n     * Any user can buy W items at Y price, of one listing, they cannot combine two listings in one transaction, given that W>0 and W<=Y\n     * Restrictions:\n     *    Limit the sell to owned items, the user cannot sell items do not have\n     *\/\n    \n    function sell(uint256 tokenId, uint256 qty, uint256 price, address wallet) external {\n\n        \/\/ Limit the sell to owned items, the user cannot sell items do not have\n        require(balanceOf(_msgSender(), tokenId) >= qty, \"Azuki: you do not have enough tokens to sell\");\n\n        \/\/ set approval for all items of the user is not set already\n        if (!isApprovedForAll(_msgSender(), address(this))) {\n            setApprovalForAll(address(this), true);\n        }\n\n        \/\/ add the selling option to openSales\n        Sale memory sale = Sale(qty, price, _msgSender(), wallet);\n\n        \/\/ An owner can add only one selling listing for one item at a time, new listings for one item will replace the old ones\n\n        openSales[tokenId].push(sale);\n        openSalesLength[tokenId] = openSales[tokenId].length;\n        emit Sell(tokenId, _msgSender(), qty, price);\n\n    }\n\n    \/**\n     * Return the extra funds sent to the contract\n     *\/\n    function returnTheChange(uint256 total) internal {\n        if(msg.value > total) {\n            (bool success, ) = _msgSender().call{value:msg.value - total}(\"\");\n            require(success, \"Transfer failed.\");\n            emit Change(_msgSender(), msg.value - total);\n        }\n    }\n\n    \/**\n     * Buy an NTF item, specifying qty to buy and index offer\n     * Funds are transferred from the caller user directly, previous approval required\n     *\/\n    \n    function buy(uint256 tokenId, uint256 index, uint256 qty) payable external nonReentrant {\n\n        \/\/ validate user\n        require(openSales[tokenId][index].user != _msgSender() , \"Azuki: the user cannot buy his own offer\");\n\n        uint256 total = qty * openSales[tokenId][index].price;\n\n        \/\/ require enough funds\n        require(msg.value >= total, \"Azuki: payment is too low\");\n\n        \/\/ return the change\n        returnTheChange(total);\n\n        \/**\n         * distribute funds between owner, creator and admin\n         * This function will transfer the funds from the buyer, which must have previously approve the funds to the contract, to the beneficiaries of the sale\n         *\/ \n        distributeFunds(total, _msgSender(), openSales[tokenId][index].wallet, tokenId);\n\n        \/\/ transfer ownership\n        \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n        callOptionalReturn(this, abi.encodeWithSelector(this.safeTransferFrom.selector, openSales[tokenId][index].user, _msgSender(), tokenId, qty, \"0x\"));\n\n        \/\/ substract items sold\n        openSales[tokenId][index].qty -= qty;\n\n        \/\/ remove the offer and reorder the array\n        if (openSales[tokenId][index].qty == 0) {\n            openSales[tokenId][index] = openSales[tokenId][openSales[tokenId].length-1];\n            openSales[tokenId].pop();\n            openSalesLength[tokenId] = openSales[tokenId].length;\n        }\n\n    }\n\n    \/\/ cancel the sale\n    function cancelSale(uint256 tokenId, uint256 index) external {\n\n        \/\/ Only the original bidder can cancel his bids\n        require(openSales[tokenId][index].user == _msgSender(), \"Azuki: only the original seller can cancel his sales\");\n\n        \/\/ remove the sale\n        openSales[tokenId][index] = openSales[tokenId][openSales[tokenId].length-1];\n        openSales[tokenId].pop();\n        openSalesLength[tokenId] = openSales[tokenId].length;\n\n        emit CancelSale(tokenId, index);\n\n    }\n\n    \/**\n     * Any user can make an offer of X items at Y price each\n     * Funds of the offer are stored on the contract\n     * All offers are shown as \u201cOffers\u201d in the UI\n     * Restrictions\n     *    A buyer cannot add an offer bigger than the total supply\n     *\/\n    \n    function bid(uint256 tokenId, uint256 qty, uint256 price) external payable nonReentrant {\n\n        require(qty>0, \"Iksasumi: qty has to be positive\");\n        require(price>0, \"Iksasumi: price has to be positive\");\n\n        require(qty <= totalSupply(tokenId), \"Iksasumi: not enough items for sale\");\n        \n        \/\/ transfer qty * price tokens to the contract\n        uint256 total = qty * price;\n\n        \/\/ require enough funds\n        require(msg.value >= total, \"Azuki: payment is too low\");\n\n        \/\/ return the change\n        returnTheChange(total);\n\n        \/\/ record the offer\n        Offer memory theBid = Offer(qty, price, _msgSender());\n\n        openOffers[tokenId].push(theBid);\n        openOffersLength[tokenId] = openOffers[tokenId].length;\n        emit Bid(tokenId, _msgSender(), qty, price);\n\n    }\n\n    \/\/ cancel the offer and return funds\n    function cancelBid(uint256 tokenId, uint256 index) external nonReentrant {\n\n        \/\/ Only the original bidder can cancel his bids\n        require(openOffers[tokenId][index].user == _msgSender(), \"Azuki: only the original bidder can cancel his bids\");\n\n        \/\/ save the total\n        uint256 total = openOffers[tokenId][index].qty * openOffers[tokenId][index].price;\n\n        \/\/ remove the bid\n        openOffers[tokenId][index] = openOffers[tokenId][openOffers[tokenId].length-1];\n        openOffers[tokenId].pop();\n        openOffersLength[tokenId] = openOffers[tokenId].length;\n\n        \/\/ return the funds\n\n        (bool success, ) = _msgSender().call{value:total}(\"\");\n        require(success, \"Transfer failed.\");\n\n        emit CancelBid(tokenId, index);\n\n    }\n\n    \/\/ owner accepts the bid and distribute the funds\n    function acceptBid(uint256 tokenId, uint256 index, uint256 qty) external nonReentrant {\n\n        \/\/ validate user\n        require(openOffers[tokenId][index].user != _msgSender() , \"Azuki: the user cannot accept his own bid\");\n\n        \/\/ set approval for all items of the user is not set already\n        if (!isApprovedForAll(_msgSender(), address(this))) {\n            setApprovalForAll(address(this), true);\n        }\n\n        \/\/ transfer item to bidder\n        \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n        callOptionalReturn(this, abi.encodeWithSelector(this.safeTransferFrom.selector, _msgSender(), openOffers[tokenId][index].user, tokenId, qty, \"0x\"));\n\n        \/**\n         * distribute funds between owner, creator and admin\n         * This function will transfer the funds from the contract, which must have previously sent to the contract, to the beneficiaries of the sale\n         *\/ \n        distributeFunds(qty * openOffers[tokenId][index].price, openOffers[tokenId][index].user, _msgSender(), tokenId);\n\n        \/\/ substract items sold\n        openOffers[tokenId][index].qty -= qty;\n\n        \/\/ remove the offer and reorder the array\n        if (openOffers[tokenId][index].qty == 0) {\n            openOffers[tokenId][index] = openOffers[tokenId][openOffers[tokenId].length-1];\n            openOffers[tokenId].pop();\n            openOffersLength[tokenId] = openOffers[tokenId].length;\n        }\n    }\n\n    \/**\n     * do the funds distribution between owner, creator and admin\n     * @param totalPrice the total value to distribute\n     * @param from if useTransferFrom is true then the \"from\" is the origin of the funds, if false, then the \"from\" is only used for logs purposes\n     * @param to is the owner of the token on sale \/ bid\n     * @param tokenId is the token being sold\n     *\/\n\n    function distributeFunds(uint256 totalPrice, address from, address to, uint256 tokenId) internal {\n\n        \/\/ calculate amounts\n        uint256 amount4admin = totalPrice * commissionRate \/ 100;\n        uint256 amount4creator = totalPrice * royaltiesCommissionRate \/ 100;\n        uint256 amount4owner = totalPrice - amount4admin - amount4creator;\n\n        \/\/ to owner\n        (bool success, ) = to.call{value:amount4owner}(\"\");\n        require(success, \"Transfer failed.\");\n        emit Buy(tokenId, from, to, amount4owner);\n\n        \/\/ to creator\n        if (amount4creator>0) {\n            (bool success2, ) = creators[tokenId].call{value:amount4creator}(\"\");\n            require(success2, \"Transfer failed.\");\n            emit Royalty(tokenId, from, creators[tokenId], amount4creator);\n        }\n\n        \/\/ to admin\n        if (amount4admin>0) {\n            (bool success3, ) = admin.call{value:amount4admin}(\"\");\n            require(success3, \"Transfer failed.\");\n            emit Commission(tokenId, from, admin, amount4admin);\n        }\n\n    }\n\n    \/\/\/ Overrides minting function to keep track of item creators\n\n    function _mint(address to, uint256 tokenId, uint256 amount, bytes memory data) override internal {\n        creators[tokenId] = _msgSender();\n        super._mint(to, tokenId, amount, data);\n    }\n\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) override internal {\n        super._mintBatch(to, ids, amounts, data);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            creators[ids[i]] = _msgSender();\n        }\n    }\n\n    \/**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\/\n    function callOptionalReturn(IERC1155 token, bytes memory data) private {\n        \/\/ We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        \/\/ we're implementing it ourselves.\n\n        \/\/ A Solidity high level call has three parts:\n        \/\/  1. The target address is checked to verify it contains contract code\n        \/\/  2. The call itself is made, and success asserted\n        \/\/  3. The return value is decoded, which in turn checks the size of the returned data.\n        \/\/ solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"Azuki: call to non-contract\");\n\n        \/\/ solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"Azuki: low-level call failed\");\n\n        if (returndata.length > 0) { \/\/ Return data is optional\n            \/\/ solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"Azuki: ERC20 operation did not succeed\");\n        }\n    }\n\n    \/\/ update contract fields\n    function updateAdmin(address _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, bool _anyoneCanMint) external onlyOwner() {\n        require(_commissionRate + _royaltiesCommissionRate < 100, \"Azuki: total commissions should be lower than 100\");\n        admin = _admin;\n        commissionRate = _commissionRate;\n        royaltiesCommissionRate = _royaltiesCommissionRate;\n        anyoneCanMint = _anyoneCanMint;\n    }\n    \n}\n\n\/**\n * Marketplace with Lazy Minting feature\n *\/\ncontract ERC1155Azuki is ERC1155Marketplace, EIP712 {\n    string private constant SIGNING_DOMAIN = \"ERC1155Azuki-Voucher\";\n    string private constant SIGNATURE_VERSION = \"1\";\n\n    constructor(address _owner, address _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, \n        string memory name, string memory symbol, bool _anyoneCanMint, string memory uri)\n        ERC1155Marketplace(_owner, _admin, _commissionRate, _royaltiesCommissionRate, name, symbol, _anyoneCanMint, uri)\n        EIP712(SIGNING_DOMAIN, SIGNATURE_VERSION) {}\n\n    \/\/ minted qty for each voucher ID\n    mapping(uint256 => uint256) public vouchersMintedQty;\n\n    \/\/ minted NFT ID for each voucher ID\n    mapping(uint256 => uint256) public vouchersNFTIds;\n\n    event LazyMint(uint256 indexed tokenId, address indexed from, address indexed to, uint256 value);\n\n    \/\/\/ @notice Redeems an NFTVoucher for an actual NFT, creating it in the process.\n    function redeem(\n        uint256 nftId, uint256 id, uint256 nftPostId, uint256 qty, uint256 price, uint256 collectionId, uint256 chainId, address author, uint256 salt, bytes memory signature, uint256 qtyToMint\n    ) external payable nonReentrant {\n\n        require(chainId == getChainId(), \"Azuki: Wrong chain\");\n        require(vouchersMintedQty[id] + qtyToMint <= qty, \"Azuki: the qty exceeds the amount available for minting\");\n        require(nftId == 0 || exists(nftId), \"Azuki: Wrong NFT ID\");\n\n        \/\/ require enough funds\n        require(msg.value >= qtyToMint * price, \"Azuki: payment is too low\");\n\n        \/\/ return the change\n        returnTheChange(qtyToMint * price);\n\n        \/\/ make sure signature is valid and get the address of the signer\n        verify(id, nftPostId, qty, price, collectionId, chainId, author, salt, address(this), signature, owner());\n\n        \/\/ allow to mint less qty of the amounts in voucher, until all qtys are minted\n        \/\/ first time minting? find the next available tokenId or use the existing NFT Id if it was passed to the function\n        if (vouchersNFTIds[id]==0) { \n            if (nftId>0) {\n                vouchersNFTIds[id] = nftId;\n            } else {\n                findNextTokenId();\n                vouchersNFTIds[id] = _tokenIdCounter;\n            }\n        }\n\n        \/\/ mint the items\n        _mint(_msgSender(), vouchersNFTIds[id], qtyToMint, '0x');\n\n        \/\/ manually set the creator \/ author for the tokenId just minted\n        \/\/ the author is set by the contract owner in the signed message, and this is meant to receive royalties\n        creators[vouchersNFTIds[id]] = author;\n\n        \/\/ distribute payments\n        distributeFunds(qtyToMint * price, _msgSender(), owner(), vouchersNFTIds[id]);\n\n        \/\/ Inform the Lazy Mint\n        emit LazyMint(vouchersNFTIds[id], _msgSender(), owner(), qtyToMint * price);\n\n        \/\/ keep track of minted qties\n        vouchersMintedQty[id] += qtyToMint;\n\n    } \n\n    function domainSeparator() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function verify(\n        uint256 id,\n        uint256 nftPostId,\n        uint256 qty,\n        uint256 price,\n        uint256 collectionId,\n        uint256 chainId,\n        address author,\n        uint256 salt,\n        address thisContract,\n        bytes memory signature,\n        address signer\n    ) internal view {\n        bytes32 digest = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\"NFTVoucher(uint256 id,uint256 nftPostId,uint256 qty,uint256 price,uint256 collectionId,uint256 chainId,address author,uint256 salt,address thisContract)\"), \n                    id, nftPostId, qty, price, collectionId, chainId, author, salt, thisContract\n                )\n            )\n        );\n        address recoveredSigner = ECDSA.recover(digest, signature);\n        require(recoveredSigner == signer, \"Azuki: wrong signature\");\n    }\n\n    function getChainId() public view returns (uint256) {\n        return block.chainid;\n    }\n\n}",
                "contractName": "ERC1155Azuki",
                "version": "1.0",
                "compilerVersion": "v0.8.2"
            },
            "2.0": {
                "abi_factory": [{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"uint256","name":"_royaltiesCommissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint8","name":"_whoCanMint","type":"uint8"},{"internalType":"string","name":"uri","type":"string"},{"internalType":"address","name":"_affiliate","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "abi_factory_wpic": [{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address payable","name":"_admin","type":"address"},{"internalType":"uint256","name":"_commissionRate","type":"uint256"},{"internalType":"uint256","name":"_royaltiesCommissionRate","type":"uint256"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint8","name":"_whoCanMint","type":"uint8"},{"internalType":"string","name":"uri","type":"string"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n *\/\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \/\/ no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    \/**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https:\/\/web3js.readthedocs.io\/en\/v1.3.4\/web3-eth-accounts.html#sign[Web3.js]\n     * - with https:\/\/docs.ethers.io\/v5\/api\/signer\/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        \/\/ Check the signature length\n        \/\/ - case 65: r,s,v signature (standard)\n        \/\/ - case 64: r,vs signature (cf https:\/\/eips.ethereum.org\/EIPS\/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            \/\/ ecrecover takes the signature parameters, and the only way to get them\n            \/\/ currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            \/\/ ecrecover takes the signature parameters, and the only way to get them\n            \/\/ currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    \/**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\/\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https:\/\/eips.ethereum.org\/EIPS\/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    \/**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     *\/\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        \/\/ EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        \/\/ unique. Appendix F in the Ethereum Yellow paper (https:\/\/ethereum.github.io\/yellowpaper\/paper.pdf), defines\n        \/\/ the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\n        \/\/ signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        \/\/\n        \/\/ If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        \/\/ with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        \/\/ vice versa. If your library also generates signatures with 0\/1 for v instead 27\/28, add 27 to v to accept\n        \/\/ these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        \/\/ If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    \/**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     *\/\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\u0019\u0001\", domainSeparator, structHash));\n    }\n}\n\n\/**\n * @dev https:\/\/eips.ethereum.org\/EIPS\/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https:\/\/docs.metamask.io\/guide\/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\/\nabstract contract EIP712 {\n    \/* solhint-disable var-name-mixedcase *\/\n    \/\/ Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    \/\/ invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    \/* solhint-enable var-name-mixedcase *\/\n\n    \/**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     *\/\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    \/**\n     * @dev Returns the domain separator for the current chain.\n     *\/\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    \/**\n     * @dev Given an already https:\/\/eips.ethereum.org\/EIPS\/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     *\/\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n\n\/**\n * @dev String operations.\n *\/\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \/**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     *\/\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n *\/\ninterface IAccessControl {\n    \/**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     *\/\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \/**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     *\/\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     *\/\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) external;\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) external;\n}\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-1155[EIP].\n *\n * _Available since v3.1._\n *\/\ninterface IERC1155 is IERC165 {\n    \/**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     *\/\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    \/**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     *\/\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    \/**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     *\/\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    \/**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     *\/\n    event URI(string value, uint256 indexed id);\n\n    \/**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     *\/\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    \/**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     *\/\n    function setApprovalForAll(address operator, bool approved) external;\n\n    \/**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     *\/\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    \/**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n\n\/**\n * @dev _Available since v3.1._\n *\/\ninterface IERC1155Receiver is IERC165 {\n    \/**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    \/**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n *\/\nabstract contract AccessControl is IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \/**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\n     * _Available since v4.1._\n     *\/\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, msg.sender);\n        _;\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     *\/\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \/**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  \/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$\/\n     *\/\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     *\/\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\/\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\/\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == msg.sender, \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\/\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, msg.sender);\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, msg.sender);\n        }\n    }\n}\n\n\/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n *\/\ninterface IERC1155MetadataURI is IERC1155 {\n    \/**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     *\/\n    function uri(uint256 id) external view returns (string memory);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n}\n\n\/**\n * @dev Implementation of the basic standard multi-token.\n * See https:\/\/eips.ethereum.org\/EIPS\/eip-1155\n * Originally based on code by Enjin: https:\/\/github.com\/enjin\/erc-1155\n *\n * _Available since v3.1._\n *\/\ncontract ERC1155 is ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    \/\/ Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    \/\/ Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    \/\/ Used as the URI for all token types by relying on ID substitution, e.g. https:\/\/token-cdn-domain\/{id}.json\n    string private _uri;\n\n    \/**\n     * @dev See {_setURI}.\n     *\/\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    \/**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     *\/\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    \/**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    \/**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     *\/\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    \/**\n     * @dev See {IERC1155-setApprovalForAll}.\n     *\/\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(msg.sender != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    \/**\n     * @dev See {IERC1155-isApprovedForAll}.\n     *\/\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    \/**\n     * @dev See {IERC1155-safeTransferFrom}.\n     *\/\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    \/**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     *\/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = msg.sender;\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = msg.sender;\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https:\/\/token-cdn-domain\/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https:\/\/token-cdn-domain\/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     *\/\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    \/**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = msg.sender;\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     *\/\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = msg.sender;\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n}\n\n\/**\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\n *\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\n * clearly identified. Note: While a totalSupply of 1 might mean the\n * corresponding is an NFT, there is no guarantees that no other token with the\n * same id are not going to be minted.\n *\/\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    \/**\n     * @dev Total amount of tokens in with a given id.\n     *\/\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    \/**\n     * @dev Indicates weither any token exist with a given id, or not.\n     *\/\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n\n    \/**\n     * @dev See {ERC1155-_mint}.\n     *\/\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual override {\n        super._mint(account, id, amount, data);\n        _totalSupply[id] += amount;\n    }\n\n    \/**\n     * @dev See {ERC1155-_mintBatch}.\n     *\/\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._mintBatch(to, ids, amounts, data);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            _totalSupply[ids[i]] += amounts[i];\n        }\n    }\n\n}\n\n\/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\/\nabstract contract Ownable {\n    address public owner;\n\n    \/**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     *\/\n    constructor() {\n        owner = msg.sender;\n    }\n\n    \/**\n     * @dev Throws if called by any account other than the owner.\n     *\/\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\/\n    function renounceOwnership() public virtual onlyOwner {\n        owner = address(0);\n    }\n\n    \/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     *\/\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n    }\n\n}\n\n\/**\n * @dev {ERC1155} token, including:\n *\n *  - a minter role that allows for token minting (creation)\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter role, as well\n * as the default admin role, which will let it grant minter role to other accounts.\n *\/\ncontract ERC1155_Yuzu is Ownable, AccessControl, ERC1155Supply {\n    \n    \/\/ Token name\n    string private _name;\n\n    \/\/ Token symbol\n    string private _symbol;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    uint256 internal _tokenIdCounter;\n\n    \/**\n     * Special setting to give special minting permissions\n     * whoCanMint = 0: only minter can mint\n     * whoCanMint = 1: only original creator of the Item can mint, multiple times\n     * whoCanMint = 2: anyone can arbitrarily mint\n     *\/\n    uint8 public whoCanMint;\n\n    \/\/ nft item creators list, used to pay royalties\n    mapping(uint256 => address) public creators;\n    \n    \/**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, and `MINTER_ROLE` to the account that\n     * deploys the contract. And initializes the contract by setting a `name` \n     * and a `symbol` to the token collection.\n     *\/\n    constructor(address owner, string memory uri, string memory name_, string memory symbol_, uint8 whoCanMint_) Ownable() ERC1155(uri) {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(MINTER_ROLE, owner);\n        transferOwnership(owner);\n        _name = name_;\n        _symbol = symbol_;\n        whoCanMint = whoCanMint_;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-name}.\n     *\/\n    function name() external view virtual returns (string memory) {\n        return _name;\n    }\n\n    \/**\n     * @dev See {IERC721Metadata-symbol}.\n     *\/\n    function symbol() external view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    \/**\n     * @dev Find next available tokenId\n     *\/\n    function findNextTokenId() internal {\n        do {\n          _tokenIdCounter++;\n        } while(exists(_tokenIdCounter));\n    }\n\n    \/\/\/ Overrides minting function to keep track of item creators\n\n    function _mint(address to, uint256 tokenId, uint256 amount, bytes memory data) internal virtual override {\n        creators[tokenId] = msg.sender;\n        super._mint(to, tokenId, amount, data);\n    }\n\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual override {\n        super._mintBatch(to, ids, amounts, data);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            creators[ids[i]] = msg.sender;\n        }\n    }\n\n    \/**\n     * @dev Creates `amount` new tokens for `to`, using the next available `id`.\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function autoMint(address to, uint256 amount) public onlyMinter returns (uint256) {\n        findNextTokenId();\n        _mint(to, _tokenIdCounter, amount, \"0x\");\n        return _tokenIdCounter;\n    }\n\n    \/**\n     * @dev Creates `amounts` new tokens for `to`, using the next available `ids`.\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function autoMintBatch(address to, uint256[] memory amounts) external onlyMinter {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        for (uint256 i = 0; i < amounts.length; i++) {\n            autoMint(to, amounts[i]);\n        }\n    }\n\n    \/**\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\n     *\n     * See {ERC1155-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     *\/\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external virtual canMint(id) {\n        _mint(to, id, amount, data);\n    }\n\n    \/**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\n     *\/\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external virtual onlyMinter {\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControl, ERC1155)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function addMinter(address account) external onlyMinter {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    \/**\n     * Check if a user can mint, and optionally check if an user can mint more of an specific token\n     * Who can mint?\n     * Case 1: a minter can mint\n     * Case 2: a creator can mint more items if he is allowed to\n     * Case 3: arbitrary minting is possible if set (not recommended)\n     * @param _id: NFT token ID (optional)\n     *\/\n    function canIMint(uint256 _id) public view returns (bool) {\n        return  isMinter(msg.sender) || \/\/ a minter can mint\n                (whoCanMint == 1 && _id == 0) || \/\/ a creator can mint for the first time any item\n                (whoCanMint == 1 && _id > 0 && creators[_id] == msg.sender) || \/\/ a creator can add more items to its own NFT items\n                whoCanMint == 2 \/\/ if anyone can mint, allow any mint request\n        ;\n    }\n\n    \/**\n     * Open modifier to anyone can mint possibility\n     *\/\n    modifier onlyMinter() {\n        require(\n            canIMint(0), \/\/ it allows minters or anyone if anyone can mint is set\n            \"ERC1155Yuzu: must have minter role to mint\"\n        );\n        _;\n    }\n\n    \/**\n     * Open modifier to check who can mint, allowing the restriction that only creators can mint their own token\n     *\/\n    modifier canMint(uint256 _tokenId) {\n        require(\n            canIMint(_tokenId), \/\/ it allows minters or anyone if anyone can mint is set, but also check if only the creator can mint its token\n            \"ERC1155Yuzu: must have minter role to mint\"\n        );\n        _;\n    }\n\n}\n\n\/**\n *\n * ERC1155 Marketplace Azuki v.2\n * \n * @title ERC1155Azuki\n * \n * ERC-721 Marketplace with tokens and royalties support\n *\/\ncontract ERC1155Marketplace is ERC1155_Yuzu, ReentrancyGuard {\n\n    using Address for address;\n\n    \/\/ admin address, the owner of the marketplace\n    address public admin;\n\n    \/\/ commission rate is a value from 0 to 100\n    uint256 public commissionRate;\n\n    \/\/ royalties commission rate is a value from 0 to 100\n    uint256 public royaltiesCommissionRate;\n\n    \/\/ a sale object\n    struct Sale {\n        uint256 qty;    \/\/ qty for sale\n        uint256 price;  \/\/ price \n        address user;   \/\/ seller\n        address wallet; \/\/ seller wallet\n    }\n\n    \/\/ opened sales by tokenIds\n    mapping(uint256 => Sale[]) public openSales;\n\n    \/\/ length of the array\n    mapping(uint256 => uint256) public openSalesLength;\n\n    \/\/ a buy offer object\n    struct Offer {\n        uint256 qty;    \/\/ qty for buying\n        uint256 price;  \/\/ buy price \n        address user;   \/\/ buyer\n    }\n\n    \/\/ opened offers by tokenIds\n    mapping(uint256 => Offer[]) public openOffers;\n\n    \/\/ length of the array\n    mapping(uint256 => uint256) public openOffersLength;\n\n    event Bid(        uint256 indexed tokenId, address indexed from,   uint256 qty,         uint256 price);\n    event Sell(       uint256 indexed tokenId, address indexed to,     uint256 qty,         uint256 price);\n    event Commission( uint256 indexed tokenId, address indexed from,   address indexed to,  uint256 value);\n    event Royalty(    uint256 indexed tokenId, address indexed from,   address indexed to,  uint256 value);\n    event Buy(        uint256 indexed tokenId, address indexed from,   address indexed to,  uint256 value);\n\n    event CancelSale(uint256 indexed tokenId, uint256 index);\n    event CancelBid(uint256 indexed tokenId, uint256 index);\n\n    event Change(address beneficiary, uint256 value);\n\n    constructor(\n        address _owner, address _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, \n        string memory name, string memory symbol, uint8 _whoCanMint, string memory uri) \n        ERC1155_Yuzu(_owner, uri, name, symbol, _whoCanMint)\n    {\n        require(_commissionRate + _royaltiesCommissionRate < 100, \"Azuki: total commissions should be lower than 100\");\n        admin = _admin;\n        commissionRate = _commissionRate;\n        royaltiesCommissionRate = _royaltiesCommissionRate;\n    }\n\n    \/**\n     * Any user can sell X items at Y price each, valid ownership and qty of the sell will be handled by the UI\n     * All selling options are shown as \u201cListings\u201d in the UI\n     * Any user can buy W items at Y price, of one listing, they cannot combine two listings in one transaction, given that W>0 and W<=Y\n     * Restrictions:\n     *    Limit the sell to owned items, the user cannot sell items do not have\n     *\/\n    \n    function sell(uint256 tokenId, uint256 qty, uint256 price, address wallet) external {\n\n        \/\/ Limit the sell to owned items, the user cannot sell items do not have\n        require(balanceOf(msg.sender, tokenId) >= qty, \"Azuki: you do not have enough tokens to sell\");\n\n        \/\/ set approval for all items of the user is not set already\n        if (!isApprovedForAll(msg.sender, address(this))) {\n            setApprovalForAll(address(this), true);\n        }\n\n        \/\/ add the selling option to openSales\n        Sale memory sale = Sale(qty, price, msg.sender, wallet);\n\n        \/\/ An owner can add only one selling listing for one item at a time, new listings for one item will replace the old ones\n\n        openSales[tokenId].push(sale);\n        openSalesLength[tokenId] = openSales[tokenId].length;\n        emit Sell(tokenId, msg.sender, qty, price);\n\n    }\n\n    \/**\n     * Return the extra funds sent to the contract\n     *\/\n    function returnTheChange(uint256 total) internal {\n        if(msg.value > total) {\n            (bool success, ) = msg.sender.call{value:msg.value - total}(\"\");\n            require(success, \"Transfer failed.\");\n            emit Change(msg.sender, msg.value - total);\n        }\n    }\n\n    \/**\n     * Buy an NTF item, specifying qty to buy and index offer\n     * Funds are transferred from the caller user directly, previous approval required\n     *\/\n    \n    function buy(uint256 tokenId, uint256 index, uint256 qty) payable external nonReentrant {\n\n        \/\/ validate user\n        require(openSales[tokenId][index].user != msg.sender , \"Azuki: the user cannot buy his own offer\");\n\n        uint256 total = qty * openSales[tokenId][index].price;\n\n        \/\/ require enough funds\n        require(msg.value >= total, \"Azuki: payment is too low\");\n\n        \/\/ return the change\n        returnTheChange(total);\n\n        \/**\n         * distribute funds between owner, creator and admin\n         * This function will transfer the funds from the buyer, which must have previously approve the funds to the contract, to the beneficiaries of the sale\n         *\/ \n        distributeFunds(total, msg.sender, openSales[tokenId][index].wallet, tokenId);\n\n        \/\/ transfer ownership\n        \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n        callOptionalReturn(this, abi.encodeWithSelector(this.safeTransferFrom.selector, openSales[tokenId][index].user, msg.sender, tokenId, qty, \"0x\"));\n\n        \/\/ substract items sold\n        openSales[tokenId][index].qty -= qty;\n\n    }\n\n    \/\/ cancel the sale\n    function cancelSale(uint256 tokenId, uint256 index) external {\n\n        \/\/ Only the original bidder can cancel his bids\n        require(openSales[tokenId][index].user == msg.sender, \"Azuki: only the original seller can cancel his sales\");\n\n        \/\/ remove the sale\n        openSales[tokenId][index].qty = 0;\n\n        emit CancelSale(tokenId, index);\n\n    }\n\n    \/**\n     * Any user can make an offer of X items at Y price each\n     * Funds of the offer are stored on the contract\n     * All offers are shown as \u201cOffers\u201d in the UI\n     * Restrictions\n     *    A buyer cannot add an offer bigger than the total supply\n     *\/\n    \n    function bid(uint256 tokenId, uint256 qty, uint256 price) external payable nonReentrant {\n\n        require(qty>0, \"Iksasumi: qty has to be positive\");\n        require(price>0, \"Iksasumi: price has to be positive\");\n\n        require(qty <= totalSupply(tokenId), \"Iksasumi: not enough items for sale\");\n        \n        \/\/ transfer qty * price tokens to the contract\n        uint256 total = qty * price;\n\n        \/\/ require enough funds\n        require(msg.value >= total, \"Azuki: payment is too low\");\n\n        \/\/ return the change\n        returnTheChange(total);\n\n        \/\/ record the offer\n        Offer memory theBid = Offer(qty, price, msg.sender);\n\n        openOffers[tokenId].push(theBid);\n        openOffersLength[tokenId] = openOffers[tokenId].length;\n        emit Bid(tokenId, msg.sender, qty, price);\n\n    }\n\n    \/\/ cancel the offer and return funds\n    function cancelBid(uint256 tokenId, uint256 index) external nonReentrant {\n\n        \/\/ Only the original bidder can cancel his bids\n        require(openOffers[tokenId][index].user == msg.sender, \"Azuki: only the original bidder can cancel his bids\");\n\n        \/\/ save the total\n        uint256 total = openOffers[tokenId][index].qty * openOffers[tokenId][index].price;\n\n        \/\/ remove the bid\n        openOffers[tokenId][index].qty = 0;\n\n        \/\/ return the funds\n\n        (bool success, ) = msg.sender.call{value:total}(\"\");\n        require(success, \"Transfer failed.\");\n\n        emit CancelBid(tokenId, index);\n\n    }\n\n    \/\/ owner accepts the bid and distribute the funds\n    function acceptBid(uint256 tokenId, uint256 index, uint256 qty) external nonReentrant {\n\n        \/\/ validate user\n        require(openOffers[tokenId][index].user != msg.sender , \"Azuki: the user cannot accept his own bid\");\n\n        \/\/ set approval for all items of the user is not set already\n        if (!isApprovedForAll(msg.sender, address(this))) {\n            setApprovalForAll(address(this), true);\n        }\n\n        \/\/ transfer item to bidder\n        \/\/ we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\n        callOptionalReturn(this, abi.encodeWithSelector(this.safeTransferFrom.selector, msg.sender, openOffers[tokenId][index].user, tokenId, qty, \"0x\"));\n\n        \/**\n         * distribute funds between owner, creator and admin\n         * This function will transfer the funds from the contract, which must have previously sent to the contract, to the beneficiaries of the sale\n         *\/ \n        distributeFunds(qty * openOffers[tokenId][index].price, openOffers[tokenId][index].user, msg.sender, tokenId);\n\n        \/\/ substract items sold\n        openOffers[tokenId][index].qty -= qty;\n\n    }\n\n    \/**\n     * do the funds distribution between owner, creator and admin\n     * @param totalPrice the total value to distribute\n     * @param from if useTransferFrom is true then the \"from\" is the origin of the funds, if false, then the \"from\" is only used for logs purposes\n     * @param to is the owner of the token on sale \/ bid\n     * @param tokenId is the token being sold\n     *\/\n\n    function distributeFunds(uint256 totalPrice, address from, address to, uint256 tokenId) internal {\n\n        \/\/ calculate amounts\n        uint256 amount4admin = totalPrice * commissionRate \/ 100;\n        uint256 amount4creator = totalPrice * royaltiesCommissionRate \/ 100;\n        uint256 amount4owner = totalPrice - amount4admin - amount4creator;\n\n        \/\/ to owner\n        (bool success, ) = to.call{value:amount4owner}(\"\");\n        require(success, \"Transfer failed.\");\n        emit Buy(tokenId, from, to, amount4owner);\n\n        \/\/ to creator\n        if (amount4creator>0) {\n            (bool success2, ) = creators[tokenId].call{value:amount4creator}(\"\");\n            require(success2, \"Transfer failed.\");\n            emit Royalty(tokenId, from, creators[tokenId], amount4creator);\n        }\n\n        \/\/ to admin\n        if (amount4admin>0) {\n            (bool success3, ) = admin.call{value:amount4admin}(\"\");\n            require(success3, \"Transfer failed.\");\n            emit Commission(tokenId, from, admin, amount4admin);\n        }\n\n    }\n\n    \/\/\/ Overrides minting function to keep track of item creators\n\n    function _mint(address to, uint256 tokenId, uint256 amount, bytes memory data) override internal {\n        creators[tokenId] = msg.sender;\n        super._mint(to, tokenId, amount, data);\n    }\n\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) override internal {\n        super._mintBatch(to, ids, amounts, data);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            creators[ids[i]] = msg.sender;\n        }\n    }\n\n    \/**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\/\n    function callOptionalReturn(IERC1155 token, bytes memory data) private {\n        \/\/ We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        \/\/ we're implementing it ourselves.\n\n        \/\/ A Solidity high level call has three parts:\n        \/\/  1. The target address is checked to verify it contains contract code\n        \/\/  2. The call itself is made, and success asserted\n        \/\/  3. The return value is decoded, which in turn checks the size of the returned data.\n        \/\/ solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"Azuki: call to non-contract\");\n\n        \/\/ solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"Azuki: low-level call failed\");\n\n        if (returndata.length > 0) { \/\/ Return data is optional\n            \/\/ solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"Azuki: ERC20 operation did not succeed\");\n        }\n    }\n\n    \/\/ update contract fields\n    function updateAdmin(address _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, uint8 _whoCanMint) external onlyOwner() {\n        require(_commissionRate + _royaltiesCommissionRate < 100, \"Azuki: total commissions should be lower than 100\");\n        admin = _admin;\n        commissionRate = _commissionRate;\n        royaltiesCommissionRate = _royaltiesCommissionRate;\n        whoCanMint = _whoCanMint;\n    }\n    \n}\n\n\/**\n * Marketplace with Lazy Minting feature\n *\/\ncontract ERC1155Azuki is ERC1155Marketplace, EIP712 {\n    string private constant SIGNING_DOMAIN = \"ERC1155Azuki-Voucher\";\n    string private constant SIGNATURE_VERSION = \"1\";\n\n    constructor(address _owner, address _admin, uint256 _commissionRate, uint256 _royaltiesCommissionRate, \n        string memory name, string memory symbol, uint8 _whoCanMint, string memory uri)\n        ERC1155Marketplace(_owner, _admin, _commissionRate, _royaltiesCommissionRate, name, symbol, _whoCanMint, uri)\n        EIP712(SIGNING_DOMAIN, SIGNATURE_VERSION) {}\n\n    \/\/ minted qty for each voucher ID\n    mapping(uint256 => uint256) public vouchersMintedQty;\n\n    \/\/ minted NFT ID for each voucher ID\n    mapping(uint256 => uint256) public vouchersNFTIds;\n\n    event LazyMint(uint256 indexed tokenId, address indexed from, address indexed to, uint256 value);\n\n    \/\/\/ @notice Redeems an NFTVoucher for an actual NFT, creating it in the process.\n    function redeem(\n        uint256 nftId, uint256 id, uint256 nftPostId, uint256 qty, uint256 price, uint256 collectionId, uint256 chainId, address author, uint256 salt, bytes memory signature, uint256 qtyToMint\n    ) external payable nonReentrant {\n\n        require(chainId == getChainId(), \"Azuki: Wrong chain\");\n        require(vouchersMintedQty[id] + qtyToMint <= qty, \"Azuki: the qty exceeds the amount available for minting\");\n        require(nftId == 0 || exists(nftId), \"Azuki: Wrong NFT ID\");\n\n        \/\/ require enough funds\n        require(msg.value >= qtyToMint * price, \"Azuki: payment is too low\");\n\n        \/\/ return the change\n        returnTheChange(qtyToMint * price);\n\n        \/\/ make sure signature is valid and get the address of the signer\n        verify(id, nftPostId, qty, price, collectionId, chainId, author, salt, address(this), signature, owner);\n\n        \/\/ allow to mint less qty of the amounts in voucher, until all qtys are minted\n        \/\/ first time minting? find the next available tokenId or use the existing NFT Id if it was passed to the function\n        if (vouchersNFTIds[id]==0) { \n            if (nftId>0) {\n                vouchersNFTIds[id] = nftId;\n            } else {\n                findNextTokenId();\n                vouchersNFTIds[id] = _tokenIdCounter;\n            }\n        }\n\n        \/\/ mint the items\n        _mint(msg.sender, vouchersNFTIds[id], qtyToMint, '0x');\n\n        \/\/ manually set the creator \/ author for the tokenId just minted\n        \/\/ the author is set by the contract owner in the signed message, and this is meant to receive royalties\n        creators[vouchersNFTIds[id]] = author;\n\n        \/\/ distribute payments\n        distributeFunds(qtyToMint * price, msg.sender, owner, vouchersNFTIds[id]);\n\n        \/\/ Inform the Lazy Mint\n        emit LazyMint(vouchersNFTIds[id], msg.sender, owner, qtyToMint * price);\n\n        \/\/ keep track of minted qties\n        vouchersMintedQty[id] += qtyToMint;\n\n    } \n\n    function domainSeparator() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function verify(\n        uint256 id,\n        uint256 nftPostId,\n        uint256 qty,\n        uint256 price,\n        uint256 collectionId,\n        uint256 chainId,\n        address author,\n        uint256 salt,\n        address thisContract,\n        bytes memory signature,\n        address signer\n    ) internal view {\n        bytes32 digest = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\"NFTVoucher(uint256 id,uint256 nftPostId,uint256 qty,uint256 price,uint256 collectionId,uint256 chainId,address author,uint256 salt,address thisContract)\"), \n                    id, nftPostId, qty, price, collectionId, chainId, author, salt, thisContract\n                )\n            )\n        );\n        address recoveredSigner = ECDSA.recover(digest, signature);\n        require(recoveredSigner == signer, \"Azuki: wrong signature\");\n    }\n\n    function getChainId() public view returns (uint256) {\n        return block.chainid;\n    }\n\n}",
                "contractName": "ERC1155Azuki",
                "version": "2.0",
                "compilerVersion": "v0.8.2"
            }
        }
    },
    "macadamia": {
        "data": {
            "1.0": {
                "abi_factory": [{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint8","name":"_decimals","type":"uint8"},{"internalType":"uint256","name":"_supply","type":"uint256"},{"internalType":"uint8","name":"_feeDivider","type":"uint8"},{"internalType":"address","name":"_affiliate","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint8","name":"_decimals","type":"uint8"},{"internalType":"uint256","name":"_supply","type":"uint256"},{"internalType":"uint8","name":"_feeDivider","type":"uint8"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: GPL-3.0 \/ GNU GPLv3\n\npragma solidity ^0.8.2;\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n *\/\ninterface IERC20 {\n    \/**\n     * @dev Returns the amount of tokens in existence.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns the amount of tokens owned by `account`.\n     *\/\n    function balanceOf(address account) external view returns (uint256);\n\n    \/**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     *\/\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    \/**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \/**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     *\/\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https:\/\/diligence.consensys.net\/posts\/2019\/09\/stop-using-soliditys-transfer-now\/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https:\/\/solidity.readthedocs.io\/en\/v0.5.11\/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\/\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \/**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https:\/\/solidity.readthedocs.io\/en\/latest\/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     *\/\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     *\/\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\/\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \/**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     *\/\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    \/**\n     * @dev Returns the address of the current owner.\n     *\/\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    \/**\n     * @dev Throws if called by any account other than the owner.\n     *\/\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\/\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    \/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     *\/\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\/**\n * Macadamia 1.0\n * ERC-20 Reflection Token\n * Based on https:\/\/github.com\/reflectfinance\/reflect-contracts\/blob\/main\/contracts\/REFLECT.sol\n * Original contract audit: https:\/\/github.com\/reflectfinance\/certik-audit\/blob\/main\/CertiK-Final-Comments-for-Reflect.pdf\n *\/\ncontract ERC20Macadamia is IERC20, Ownable {\n\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private _tTotal;\n    uint256 private _rTotal;\n    uint256 private _tFeeTotal;\n    uint8 public _feeDivider;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (address owner_, string memory name_, string memory symbol_, uint8 decimals_, uint256 supply_, uint8 feeDivider_) Ownable() {\n\n        require(feeDivider_ > 0, \"ERC20 Macadamia: divider has to be grater than zero\");\n        require(decimals_ < 19, \"ERC20 Macadamia: decimals has to be between 0 and 18\");\n        require(supply_ > 0, \"ERC20 Macadamia: supply has to be grater than zero\");\n\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n        _feeDivider = feeDivider_;\n\n        _tTotal = supply_;\n        _rTotal = (MAX - (MAX % _tTotal));\n\n        _rOwned[owner_] = _rTotal;\n        emit Transfer(address(0), owner_, _tTotal);\n\n        transferOwnership(owner_);\n\n    }\n\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\n        return true;\n    }\n\n    function isExcluded(address account) external view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() external view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function reflect(uint256 tAmount) external {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _rTotal = _rTotal - rAmount;\n        _tFeeTotal = _tFeeTotal + tAmount;\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount \/ currentRate;\n    }\n\n    function excludeAccount(address account) external onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccount(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already included\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferFromExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferToExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferStandard(sender, recipient, amount);\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferBothExcluded(sender, recipient, amount);\n        } else {\n            _transferStandard(sender, recipient, amount);\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender] - tAmount;\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender] - tAmount;\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal - rFee;\n        _tFeeTotal = _tFeeTotal + tFee;\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    }\n\n    function _getTValues(uint256 tAmount) private view returns (uint256, uint256) {\n        uint256 tFee = tAmount \/ _feeDivider;\n        uint256 tTransferAmount = tAmount - tFee;\n        return (tTransferAmount, tFee);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount * currentRate;\n        uint256 rFee = tFee * currentRate;\n        uint256 rTransferAmount = rAmount - rFee;\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply \/ tSupply;\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply - _rOwned[_excluded[i]];\n            tSupply = tSupply - _tOwned[_excluded[i]];\n        }\n        if (rSupply < _rTotal \/ _tTotal) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}",
                "contractName": "ERC20Macadamia",
                "version": "1.0",
                "compilerVersion": "v0.8.4"
            }
        }
    },
    "bubblegum": {
        "data": {
            "1.0": {
                "abi_factory": [{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"rate_","type":"uint256"},{"internalType":"address payable","name":"wallet_","type":"address"},{"internalType":"contract IERC20Metadata","name":"token_","type":"address"},{"internalType":"address","name":"tokenWallet_","type":"address"},{"internalType":"address","name":"_affiliate","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"rate_","type":"uint256"},{"internalType":"address payable","name":"wallet_","type":"address"},{"internalType":"contract IERC20Metadata","name":"token_","type":"address"},{"internalType":"address","name":"tokenWallet_","type":"address"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n\n\/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n *\/\ninterface IERC20 {\n    \/**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \/**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     *\/\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    \/**\n     * @dev Returns the amount of tokens in existence.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns the amount of tokens owned by `account`.\n     *\/\n    function balanceOf(address account) external view returns (uint256);\n\n    \/**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     *\/\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\n\/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n *\/\ninterface IERC20Metadata is IERC20 {\n    \/**\n     * @dev Returns the name of the token.\n     *\/\n    function name() external view returns (string memory);\n\n    \/**\n     * @dev Returns the symbol of the token.\n     *\/\n    function symbol() external view returns (string memory);\n\n    \/**\n     * @dev Returns the decimals places of the token.\n     *\/\n    function decimals() external view returns (uint8);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize\/address.code.length, which returns 0\n        \/\/ for contracts in construction, since the code is only stored at the end\n        \/\/ of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     *\/\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                \/\/ only check isContract if the call was successful and the return data is empty\n                \/\/ otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        \/\/ Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            \/\/ The easiest way to bubble the revert reason is using memory via assembly\n            \/\/\/ @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n    \n\/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n *\/\nlibrary SafeERC20 {\n    using Address for address;\n\n    \/**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\/\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    \/**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\/\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        \/\/ We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        \/\/ we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        \/\/ the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        \/\/ On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     *\/\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n\n\/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n *\/\nabstract contract Pausable is Context {\n    \/**\n     * @dev Emitted when the pause is triggered by `account`.\n     *\/\n    event Paused(address account);\n\n    \/**\n     * @dev Emitted when the pause is lifted by `account`.\n     *\/\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    \/**\n     * @dev Initializes the contract in unpaused state.\n     *\/\n    constructor() {\n        _paused = false;\n    }\n\n    \/**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     *\/\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    \/**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     *\/\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    \/**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     *\/\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    \/**\n     * @dev Throws if the contract is paused.\n     *\/\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    \/**\n     * @dev Throws if the contract is not paused.\n     *\/\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    \/**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     *\/\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    \/**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     *\/\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n\/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\/\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \/**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     *\/\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    \/**\n     * @dev Returns the address of the current owner.\n     *\/\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    \/**\n     * @dev Throws if called by any account other than the owner.\n     *\/\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\/\n    function renounceOwnership() external virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    \/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     *\/\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\/**\n * @dev Standard math utilities missing in the Solidity language.\n *\/\nlibrary Math {\n    \/**\n     * @dev Returns the smallest of two numbers.\n     *\/\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\n\/**\n * @title Crowdsale\n * @dev Base contract for managing a token crowdsale.\n * Allows investors to purchase tokens with ether until the contract is paused.\n * This contract can be extended to provide additional functionality.\n * The external interface represents the basic interface for purchasing tokens.\n * The internal interface is for extensible and modifiable surface of crowdsales.\n * Do not modify the external interface. Override methods for additional functionality.\n *\/\ncontract Crowdsale is Ownable, Pausable, ReentrancyGuard {\n\n    using SafeERC20 for IERC20Metadata;\n\n    \/\/ The token being sold\n    IERC20Metadata public token;\n\n    \/\/ Address where funds are collected\n    address payable public wallet;\n\n    \/\/ The rate determines how many token units a buyer receives per wei.\n    \/\/ It represents the conversion between wei and the smallest, indivisible token unit.\n    \/\/ The 'rate' is expressed as a wei-like precision, where a rate of 10^18 is equal to one unit.\n    \/\/ This approach allows for token decimal conversions and rates less than 1.\n    uint256 public rate;\n\n    \/\/ Amount of wei raised\n    uint256 public weiRaised;\n\n    \/**\n     * @dev Event emitted when tokens are purchased.\n     * @param purchaser Address of the user who purchased tokens\n     * @param beneficiary Address where purchased tokens were sent\n     * @param value Amount of ether paid for purchase\n     * @param amount Amount of tokens purchased\n     *\/\n    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n    \/**\n     * @dev Event emitted when the rate is changed.\n     * @param rate the new rate\n     *\/\n    event RateChanged(uint256 rate);\n\n    \/**\n     * @dev The rate is the conversion between wei and the smallest and indivisible\n     * token unit. So, if you are using a rate of 1 with a ERC20Detailed token\n     * with 3 decimals called TOK, 1 wei will give you 1 unit, or 0.001 TOK.\n     * @param rate_ Number of token units a buyer gets per wei\n     * @param wallet_ Address where collected funds will be forwarded to\n     * @param token_ Address of the token being sold\n     * @param owner_ Address of the contract owner\n     *\/\n    constructor (uint256 rate_, address payable wallet_, IERC20Metadata token_, address owner_) Ownable() {\n        setRate(rate_);\n        setWallet(wallet_);\n        setToken(token_);\n        transferOwnership(owner_);\n    }\n\n    \/**\n     * @dev Owner can change the rate.\n     * @param rate_ Number of token units a buyer gets per wei\n     *\/\n    function setRate(uint256 rate_) public onlyOwner() {\n        require(rate_ > 0, \"Crowdsale: rate is 0\");\n        require(weiRaised == 0, \"Crowdsale has started\");\n        emit RateChanged(rate_);\n        rate = rate_;\n    }\n\n    \/**\n     * @dev Owner can change the wallet.\n     * @param wallet_ Address where collected funds will be forwarded to\n     *\/\n    function setWallet(address payable wallet_) public onlyOwner() {\n        require(wallet_ != address(0), \"Crowdsale: wallet is the zero address\");\n        wallet = wallet_;\n    }\n\n    \/**\n     * @dev Owner can change the token if the crowdsale hasn't started yet.\n     * @param token_ Address of the token being sold\n     *\/\n    function setToken(IERC20Metadata token_) public onlyOwner() {\n        require(weiRaised == 0, \"Crowdsale has started\");\n        require(address(token_) != address(0), \"Crowdsale: token is the zero address\");\n        token = token_;\n    }\n\n    \/**\n     * @dev Fallback function ***DO NOT OVERRIDE***\n     * Note that other contracts will transfer funds with a base gas stipend\n     * of 2300, which is not enough to call buyTokens. Consider calling\n     * buyTokens directly when purchasing tokens from a contract.\n     * This function is automatically called when ether is sent to the contract address.\n     * Users should send Ethers from the beneficiary address in the transaction.\n     *\/\n    receive() external payable {\n        buyTokens(_msgSender());\n    }\n\n    \/**\n     * @dev Low-level token purchase ***DO NOT OVERRIDE***\n     * Allows users to purchase tokens with ether.\n     * This function has a non-reentrancy guard, so it shouldn't be called by\n     * another `nonReentrant` function.\n     * @param beneficiary Address where purchased tokens will be sent\n     *\/\n    function buyTokens(address beneficiary) public nonReentrant whenNotPaused payable {\n\n        uint256 weiAmount = msg.value;\n\n        require(beneficiary != address(0), \"Crowdsale: beneficiary is the zero address\");\n        require(weiAmount != 0, \"Crowdsale: weiAmount is 0\");\n\n        \/\/ Calculate token amount to be created\n        uint256 tokens = getTokenAmount(weiAmount);\n        require(tokens != 0, \"Crowdsale: cannot buy 0 tokens\");\n\n        \/\/ Update state\n        weiRaised += weiAmount;\n\n        emit TokensPurchased(_msgSender(), beneficiary, weiAmount, tokens);\n        _deliverTokens(beneficiary, tokens);\n\n        wallet.transfer(msg.value);\n\n    }\n\n    \/**\n     * @dev Calculate the number of tokens that can be purchased with a specified amount of wei.\n     *\n     * This function provides a conversion mechanism for converting Ethereum wei (the smallest unit of Ether) into tokens\n     * based on the current rate and the number of decimal places in the token's representation.\n     *\n     * @param weiAmount The amount of wei to be converted into tokens.\n     * @return The number of tokens that can be purchased with the specified `weiAmount`.\n     *\/\n    function getTokenAmount(uint256 weiAmount) public view returns (uint256) {\n        \/\/ Calculate the number of tokens using the specified wei amount, rate, and token decimals.\n        \/\/ The formula is: (weiAmount * rate * 10^tokenDecimals) \/ (10^18 \/ 10^rateDecimals)\n        \/\/ where 10^18 is used to account for Ether's 18 decimal places and 10^rateDecimals is used to adjust for rate precision.\n        return (weiAmount * rate * 10**token.decimals()) \/ 10**36;\n    }\n\n    \/**\n     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends\n     * its tokens.\n     * @param beneficiary Address performing the token purchase\n     * @param tokenAmount Number of tokens to be emitted\n     *\/\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) virtual internal {}\n\n    \/**\n     * @dev Pauses the ICO activity. Only the contract owner can call this function.\n     *\/\n    function pause() external onlyOwner() {\n        _pause();\n    }\n\n    \/**\n     * @dev Resumes the ICO activity. Only the contract owner can call this function.\n     *\/\n    function unpause() external onlyOwner() {\n        _unpause();\n    }\n}\n\n\/**\n * @title BubblegumCrowdsale\n * @dev Extension of Crowdsale where tokens are held by a wallet, which approves an allowance to the crowdsale.\n *\/\ncontract BubblegumCrowdsale is Crowdsale {\n\n    using SafeERC20 for IERC20Metadata;\n\n    address private _tokenWallet;\n\n    \/**\n     * @dev The rate is the conversion between wei and the smallest and indivisible\n     * token unit. So, if you are using a rate of 1 with a ERC20Detailed token\n     * with 3 decimals called TOK, 1 wei will give you 1 unit, or 0.001 TOK.\n     * @param wallet_ Address where collected funds will be forwarded to\n     * @param token_ Address of the token being sold\n     * @param rate_ Number of token units a buyer gets per wei\n     * @param owner_ Address of the contract owner\n     * @param distributionWallet_ Address holding the tokens, which has approved allowance to the crowdsale.\n     *\/\n    constructor (uint256 rate_, address payable wallet_, IERC20Metadata token_, address distributionWallet_, address owner_) \n        Crowdsale(rate_, wallet_, token_, owner_) {\n        require(distributionWallet_ != address(0), \"AllowanceCrowdsale: token wallet is the zero address\");\n        _tokenWallet = distributionWallet_;\n    }\n\n    \/**\n     * @dev Owner can change the token wallet.\n     * @param distributionWallet_ Address that holds the token to be distributed\n     *\/\n    function setTokenWallet(address distributionWallet_) external onlyOwner() {\n        require(distributionWallet_ != address(0), \"Crowdsale: token wallet is the zero address\");\n        _tokenWallet = distributionWallet_;\n    }\n\n    \/**\n     * @return the address of the wallet that will hold the tokens.\n     *\/\n    function tokenWallet() external view returns (address) {\n        return _tokenWallet;\n    }\n\n    \/**\n     * @dev Checks the amount of tokens left in the allowance.\n     * @return Amount of tokens left in the allowance\n     *\/\n    function remainingTokens() external view returns (uint256) {\n        return Math.min(token.balanceOf(_tokenWallet), token.allowance(_tokenWallet, address(this)));\n    }\n\n    \/**\n     * @dev Overrides parent behavior by transferring tokens from wallet.\n     * @param beneficiary Token purchaser\n     * @param tokenAmount Amount of tokens purchased\n     *\/\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal override {\n        token.safeTransferFrom(_tokenWallet, beneficiary, tokenAmount);\n    }\n\n}",
                "contractName": "BubblegumCrowdsale",
                "version": "1.0",
                "compilerVersion": "v0.8.2"
            }
        }
    },
    "coconut": {
        "data": {
            "1.0": {
                "abi_factory": [{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_lapse","type":"uint256"},{"internalType":"address","name":"_affiliate","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_lapse","type":"uint256"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n\n\/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\/\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \/**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     *\/\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    \/**\n     * @dev Returns the address of the current owner.\n     *\/\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    \/**\n     * @dev Throws if called by any account other than the owner.\n     *\/\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\/\n    function renounceOwnership() external virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    \/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     *\/\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n *\/\ninterface IERC20 {\n    \/**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \/**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     *\/\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    \/**\n     * @dev Returns the amount of tokens in existence.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns the amount of tokens owned by `account`.\n     *\/\n    function balanceOf(address account) external view returns (uint256);\n\n    \/**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     *\/\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\n\/**\n * @dev Required interface of an ERC721 compliant contract.\n *\/\ninterface IERC721 {\n\n    \/**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     *\/\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    \/**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\/\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    \/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n}\n\n\/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-1155[EIP].\n *\/\ninterface IERC1155  {\n\n    \/**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\/\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    \/**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     *\/\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n *\/\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    \/**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     *\/\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    \/**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\/\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        \/\/ We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        \/\/ we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        \/\/ the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n}\n\n\/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n *\/\ninterface IERC721Receiver {\n    \n    \/**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     *\/\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n *\/\ncontract ERC721Holder is IERC721Receiver {\n    \/**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     *\/\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n\n\/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https:\/\/eips.ethereum.org\/EIPS\/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n *\/\ninterface IERC165 {\n    \/**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https:\/\/eips.ethereum.org\/EIPS\/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     *\/\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n *\/\nabstract contract ERC165 is IERC165 {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\/**\n * @dev _Available since v3.1._\n *\/\ninterface IERC1155Receiver is IERC165 {\n    \/**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    \/**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    *\/\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\/**\n * @dev _Available since v3.1._\n *\/\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    \/**\n     * @dev See {IERC165-supportsInterface}.\n     *\/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n\n\/**\n * @dev _Available since v3.1._\n *\/\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n\n\/**\n * @title CoconutVault\n * @dev A smart contract for securely storing and managing native coins, ERC-20 tokens,\n * ERC-721 NFTs, and ERC-1155 NFTs. It includes functionalities for deposits,\n * withdrawals, and trusted account management in case of emergencies.\n *\/\ncontract CoconutVault is ERC721Holder, ERC1155Holder, Ownable, ReentrancyGuard {\n    \n    using SafeERC20 for IERC20;\n\n    \/\/ Timestamp of the last owner activity\n    uint256 public lastActivity;\n\n    \/\/ Expiration time in seconds since the last owner activity\n    uint256 public expirationLapse;\n\n    \/\/ Mapping of trusted accounts that can withdraw the vault assets in case of expiration\n    mapping(address => bool) public trustedAccounts; \n\n    \/\/ Event for recording the last owner activity timestamp\n    event LastActivityUpdate(uint256 timestamp);\n\n    \/\/ Events for asset deposits\n    event CoinsReceived(address indexed sender, uint256 value);\n    event ERC20Received(address indexed sender, address indexed token, uint256 amount);\n    event ERC721Received(address indexed sender, address indexed nft, uint256 id);\n    event ERC1155Received(address indexed sender, address indexed nft, uint256 id, uint256 qty);\n\n    \/\/ Events for asset withdrawals\n    event CoinsWithdrawn(address indexed beneficiary, uint256 value);\n    event ERC20Withdrawn(address indexed beneficiary, address indexed token, uint256 amount);\n    event ERC721Withdrawn(address indexed beneficiary, address indexed nft, uint256 indexed id);\n    event ERC1155Withdrawn(address indexed beneficiary, address indexed nft, uint256 indexed id, uint256 qty);\n\n    \/\/ Event for changing trusted accounts\n    event TrustedAccountChanged(address indexed trustedAccount, bool trusted);\n\n    \/**\n     * @dev Constructor for CoconutVault.\n     * @param expirationTime_ Default expiration lapse in seconds\n     * @param owner_ The address of the owner of the contract.\n     *\/\n    constructor (uint256 expirationTime_, address owner_) Ownable() {\n        require(expirationTime_ > 0, \"Expiration time must be positive\");\n        lastActivity = block.timestamp;\n        expirationLapse = expirationTime_;\n        transferOwnership(owner_);\n    }\n\n    \/\/ Owner methods:\n\n    \/**\n     * @dev Owner method to manually set the expiration time.\n     * @param lapse The new expiration time in seconds.\n     *\/\n    function setExpiration(uint256 lapse) public onlyOwner {\n        require(lapse > 0, \"Expiration time must be positive\");\n        _updateActivity();\n        expirationLapse = lapse;\n    }\n\n    \/**\n     * @dev Owner method to manually update the last activity timestamp.\n     *\/\n    function keepAlive() external onlyOwner {\n        _updateActivity();\n    }\n\n    \/\/ Deposit functions:\n\n    \/**\n     * @dev Allows anyone to deposit native coins into the vault. \n     * Updates the last activity in the contract if the sender is the owner.\n     *\/\n    function deposit() public payable nonReentrant {\n        require(msg.value > 0, \"Transfer value must be positive\");\n        emit CoinsReceived(msg.sender, msg.value);\n        _updateActivity();\n    }\n\n    \/**\n     * @dev Fallback function to handle transfers of Ether.\n     * Updates the last activity in the contract if the sender is the owner.\n     *\/\n    receive() external payable {\n        deposit();\n    }\n\n    \/**\n     * @dev Allows users to deposit ERC-20 tokens into the vault.\n     * @param token_ The ERC-20 token contract address.\n     * @param amount_ The amount of tokens to deposit.\n     * Updates the last activity in the contract if the sender is the owner.\n     * Token transfers directly to the contract can be done, but the last activity will not be updated if such transfers are made by the owner.\n     *\/\n    function tokenDeposit(IERC20 token_, uint256 amount_) external nonReentrant {\n        require(amount_ > 0, \"Transfer amount must be positive\");\n        _updateActivity();\n        emit ERC20Received(msg.sender, address(token_), amount_);\n        token_.safeTransferFrom(msg.sender, address(this), amount_);\n    }\n\n    \/**\n     * @dev Allows users to deposit NFT ERC-721 tokens into the vault.\n     * @param token_ The ERC-721 token contract address.\n     * @param id_ The NFT ID to deposit.\n     * Updates the last activity in the contract if the sender is the owner.\n     * Token transfers directly to the contract can be done, but the last activity will not be updated if such transfers are made by the owner.\n     *\/\n    function erc721Deposit(IERC721 token_, uint256 id_) external nonReentrant {\n        require(id_ > 0, \"NFT ID must be positive\");\n        _updateActivity();\n        emit ERC721Received(msg.sender, address(token_), id_);\n        token_.safeTransferFrom(msg.sender, address(this), id_);\n    }\n\n    \/**\n     * @dev Allows users to deposit NFT ERC-1155 tokens into the vault.\n     * @param token_ The ERC-1155 token contract address.\n     * @param id_ The NFT ID to deposit.\n     * @param qty_ The number of NFT items to deposit.\n     * Updates the last activity in the contract if the sender is the owner.\n     * Token transfers directly to the contract can be done, but the last activity will not be updated if such transfers are made by the owner.\n     *\/\n    function erc1155Deposit(IERC1155 token_, uint256 id_, uint256 qty_) external nonReentrant {\n        require(id_ > 0, \"NFT ID must be positive\");\n        require(qty_ > 0, \"Quantity must be positive\");\n        _updateActivity();\n        emit ERC1155Received(msg.sender, address(token_), id_, qty_);\n        token_.safeTransferFrom(msg.sender, address(this), id_, qty_, '0x');\n    }\n\n    \/\/ Withdraw functions:\n\n    \/**\n     * @dev Allows the owner or a trusted account after expiration to withdraw native coins.\n     * @param value_ The amount of native coins to withdraw.\n     * Updates the last activity in the contract if the sender is the owner.\n     *\/\n    function withdraw(uint256 value_) external nonReentrant canWithdraw {\n        require(value_ > 0, \"Transfer value must be positive\");\n        _updateActivity();\n        emit CoinsWithdrawn(msg.sender, value_);\n        (bool success, ) = msg.sender.call{value:value_}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    \/**\n     * @dev Allows the owner or a trusted account after expiration to withdraw ERC-20 tokens.\n     * @param token_ The ERC-20 token to withdraw.\n     * @param amount_ The amount of tokens to withdraw.\n     * Updates the last activity in the contract if the sender is the owner.\n     *\/\n    function tokenWithdraw(IERC20 token_, uint256 amount_) external nonReentrant canWithdraw {\n        require(amount_ > 0, \"Transfer amount must be positive\");\n        _updateActivity();\n        emit ERC20Withdrawn(msg.sender, address(token_), amount_);\n        token_.safeTransfer(msg.sender, amount_);\n    }\n\n    \/**\n     * @dev Allows the owner or a trusted account after expiration to withdraw ERC-721 tokens.\n     * @param token_ The ERC-721 token to withdraw.\n     * @param id_ The NFT ID of tokens to withdraw.\n     * Updates the last activity in the contract if the sender is the owner.\n     *\/\n    function erc721Withdraw(IERC721 token_, uint256 id_) external nonReentrant canWithdraw {\n        require(id_ > 0, \"NFT ID must be positive\");\n        _updateActivity();\n        emit ERC721Withdrawn(msg.sender, address(token_), id_);\n        token_.safeTransferFrom(address(this), msg.sender, id_);\n    }\n\n    \/**\n     * @dev Allows the owner or a trusted account after expiration to withdraw ERC-1155 tokens.\n     * @param token_ The ERC-1155 token to withdraw.\n     * @param id_ The NFT ID of tokens to withdraw.\n     * @param qty_ The number of NFT items to withdraw.\n     * Updates the last activity in the contract if the sender is the owner.\n     *\/\n    function erc1155Withdraw(IERC1155 token_, uint256 id_, uint256 qty_) external nonReentrant canWithdraw {\n        require(id_ > 0, \"NFT ID must be positive\");\n        require(qty_ > 0, \"Quantity must be positive\");\n        _updateActivity();\n        emit ERC1155Withdrawn(msg.sender, address(token_), id_, qty_);\n        token_.safeTransferFrom(address(this), msg.sender, id_, qty_, \"0x\");\n    }\n\n    \/\/ Manage trusted accounts:\n\n    \/**\n     * @dev Add or update a trusted account to withdraw Coins, ERC-20, ERC-721, or ERC-1155 in case of emergency.\n     * @param account_ The address of the beneficiary.\n     * @param trusted_ Whether the account is trusted or not.\n     *\/\n    function changeTrustedAccount(address account_, bool trusted_) external onlyOwner {\n        require(account_ != address(0), \"Trusted account cannot be the zero address\");\n        _updateActivity();\n        emit TrustedAccountChanged(account_, trusted_);\n        trustedAccounts[account_] = trusted_;\n    }\n\n    \/**\n     * @dev Internal function to update the last activity timestamp.\n     *\/\n    function _updateActivity() internal {\n        if (msg.sender == owner()) {\n            lastActivity = block.timestamp;\n            emit LastActivityUpdate(block.timestamp);\n        }\n    }\n\n    \/**\n     * @dev Modifier to check if the caller is the owner or a trusted account and the contract has expired.\n     *\/\n    modifier canWithdraw() {\n        require(msg.sender == owner() || (trustedAccounts[msg.sender] && block.timestamp - lastActivity > expirationLapse), \"Caller cannot withdraw\");\n        _;\n    }\n}",
                "contractName": "CoconutVault",
                "version": "1.0",
                "compilerVersion": "v0.8.2"
            }
        }
    },
    "guava": {
        "data": {
            "1.0": {
                "abi_factory": [{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_wallet","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"},{"internalType":"address","name":"_affiliate","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_wallet","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n\n\/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\/\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \/**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     *\/\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    \/**\n     * @dev Returns the address of the current owner.\n     *\/\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    \/**\n     * @dev Throws if called by any account other than the owner.\n     *\/\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\/\n    function renounceOwnership() external virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    \/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     *\/\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n *\/\ninterface IERC20 {\n    \/**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \/**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     *\/\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    \/**\n     * @dev Returns the amount of tokens in existence.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns the amount of tokens owned by `account`.\n     *\/\n    function balanceOf(address account) external view returns (uint256);\n\n    \/**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     *\/\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n *\/\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    \/**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     *\/\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    \/**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\/\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        \/\/ We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        \/\/ we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        \/\/ the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n}\n\n\/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n *\/\nabstract contract Pausable is Context {\n    \/**\n     * @dev Emitted when the pause is triggered by `account`.\n     *\/\n    event Paused(address account);\n\n    \/**\n     * @dev Emitted when the pause is lifted by `account`.\n     *\/\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    \/**\n     * @dev Initializes the contract in unpaused state.\n     *\/\n    constructor() {\n        _paused = false;\n    }\n\n    \/**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     *\/\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    \/**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     *\/\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    \/**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     *\/\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    \/**\n     * @dev Throws if the contract is paused.\n     *\/\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    \/**\n     * @dev Throws if the contract is not paused.\n     *\/\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    \/**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     *\/\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    \/**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     *\/\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n\/**\n * @title Guava Airdrop Contract\n * @dev This smart contract facilitates a one-time fixed amount airdrop of ERC20 tokens to beneficiaries.\n * The contract owner can set the total amount of tokens available for each beneficiary.\n * Beneficiaries can claim their tokens at any time.\n *\/\ncontract Guava is Ownable, Pausable, ReentrancyGuard {\n    \n    using SafeERC20 for IERC20;\n\n    \/\/ The ERC20 token to be airdropped\n    IERC20 public token;\n    \n    \/\/ The wallet address that holds the funds for the airdrop\n    address public wallet;\n    \n    \/\/ Amount of tokens each beneficiary can claim\n    uint256 public amount;\n\n    \/\/ Mapping to track claimed tokens for each beneficiary\n    mapping (address => bool) public claimed;\n\n    \/\/ Event emitted when a beneficiary claims tokens\n    event Claim(address indexed user, uint256 qty);\n\n    \/\/ Event emitted when the owner sets the airdrop amount\n    event AmountChanged(uint256 amount);\n\n    \/\/ Event emitted when the owner sets a new Token\n    event TokenChanged(address indexed newToken);\n\n    \/\/ Event emitted when the owner sets a new Wallet\n    event WalletChanged(address indexed newWallet);\n\n    \/**\n     * @dev Constructor to initialize the Guava contract\n     * @param _token The ERC20 token contract address\n     * @param _owner The initial owner of the contract\n     * @param _wallet The address holding the airdrop tokens\n     * @param _amount The initial airdrop amount per beneficiary\n     *\/\n    constructor (IERC20 _token, address _owner, address _wallet, uint256 _amount) Ownable() {\n        require(address(_token) != address(0), \"Token cannot be the zero address\");\n        require(_wallet != address(0), \"Wallet cannot be the zero address\");\n        token = _token;\n        wallet = _wallet;\n        amount = _amount;\n        transferOwnership(_owner);\n    }\n\n    \/**\n     * @dev Allows the contract owner to set the airdrop amount.\n     * @param amount_ The new total amount that any beneficiary can claim once\n     *\/\n    function set(uint256 amount_) external onlyOwner {\n        emit AmountChanged(amount_);\n        amount = amount_;\n    }\n\n    \/**\n     * @dev Allows beneficiaries to claim their airdrop tokens.\n     * The claim is subject to available balance and approval by the contract owner.\n     *\/\n    function claim() external nonReentrant whenNotPaused {\n        require(amount > 0, \"Airdrop is not available at this time\");\n        require(!claimed[msg.sender], \"You have already claimed your airdrop tokens.\");\n        \/\/ Check allowance before transferring tokens\n        uint256 allowance = token.allowance(wallet, address(this));\n        require(allowance >= amount, \"Insufficient allowance. Approve the contract to spend tokens.\");\n        claimed[msg.sender] = true;\n        emit Claim(msg.sender, amount);\n        token.safeTransferFrom(wallet, msg.sender, amount);\n    }\n    \n    \/**\n     * Owner functions to manage contract parameters\n     *\/\n\n    \/**\n     * @dev Changes the address of the ERC20 token contract. Only the contract owner can perform this action.\n     * @param token_ The new ERC20 token contract address\n     *\/\n    function changeToken(IERC20 token_) external onlyOwner {\n        require(address(token_) != address(0), \"Token cannot be the zero address\");\n        emit TokenChanged(address(token_));\n        token = token_;\n    }\n\n    \/**\n     * @dev Changes the wallet address holding the airdrop tokens. Only the contract owner can perform this action.\n     * @param _wallet The new wallet address\n     *\/\n    function changeWallet(address _wallet) external onlyOwner {\n        require(_wallet != address(0), \"Wallet cannot be the zero address\");\n        emit WalletChanged(_wallet);\n        wallet = _wallet;\n    }\n    \n    \/**\n     * @dev Pause the airdrop activity. Only the contract owner can pause and resume the airdrop.\n     *\/\n    function pause() external onlyOwner() {\n        _pause();\n    }\n\n    \/**\n     * @dev Resume the airdrop activity. Only the contract owner can pause and resume the airdrop.\n     *\/\n    function unpause() external onlyOwner() {\n        _unpause();\n    }\n\n    \/\/ Fallback function to handle accidental transfers of Ether and revert them.\n    receive() external payable {\n        revert(\"Ether transfers are not accepted by this contract.\");\n    }\n}",
                "contractName": "Guava",
                "version": "1.0",
                "compilerVersion": "v0.8.2"
            }
        }
    },
    "tiramisu": {
        "data": {
            "1.0": {
                "abi_factory": [{"inputs":[{"internalType":"contract ICoffee","name":"_coffee","type":"address"},{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"add","type":"address"}],"name":"NewContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"coffee","outputs":[{"internalType":"contract ICoffee","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_wallet","type":"address"},{"internalType":"address","name":"_affiliate","type":"address"}],"name":"createContract","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_wallet","type":"address"}],"name":"createContractWithWPST","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"masterFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_masterFee","type":"uint256"}],"name":"updateFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],
                "source": "\/\/ SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n\/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\/\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n\n\/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\/\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \/**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     *\/\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    \/**\n     * @dev Returns the address of the current owner.\n     *\/\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    \/**\n     * @dev Throws if called by any account other than the owner.\n     *\/\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\/\n    function renounceOwnership() external virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    \/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     *\/\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https:\/\/blog.openzeppelin.com\/reentrancy-after-istanbul\/[Reentrancy After Istanbul].\n *\/\nabstract contract ReentrancyGuard {\n    \/\/ Booleans are more expensive than uint256 or any type that takes up a full\n    \/\/ word because each write operation emits an extra SLOAD to first read the\n    \/\/ slot's contents, replace the bits taken up by the boolean, and then write\n    \/\/ back. This is the compiler's defense against contract upgrades and\n    \/\/ pointer aliasing, and it cannot be disabled.\n\n    \/\/ The values being non-zero value makes deployment a bit more expensive,\n    \/\/ but in exchange the refund on every call to nonReentrant will be lower in\n    \/\/ amount. Since refunds are capped to a percentage of the total\n    \/\/ transaction's gas, it is best to keep them low in cases like this one, to\n    \/\/ increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    \/**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     *\/\n    modifier nonReentrant() {\n        \/\/ On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \/\/ Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        \/\/ By storing the original value once again, a refund is triggered (see\n        \/\/ https:\/\/eips.ethereum.org\/EIPS\/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n *\/\ninterface IERC20 {\n    \/**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     *\/\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \/**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     *\/\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    \/**\n     * @dev Returns the amount of tokens in existence.\n     *\/\n    function totalSupply() external view returns (uint256);\n\n    \/**\n     * @dev Returns the amount of tokens owned by `account`.\n     *\/\n    function balanceOf(address account) external view returns (uint256);\n\n    \/**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     *\/\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \/**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     *\/\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \/**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     *\/\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\n\/**\n * @dev Collection of functions related to the address type\n *\/\nlibrary Address {\n    \/**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\/\n    function isContract(address account) internal view returns (bool) {\n        \/\/ This method relies on extcodesize, which returns 0 for contracts in\n        \/\/ construction, since the code is only stored at the end of the\n        \/\/ constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \/**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     *\/\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \/**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     *\/\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \/\/ Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                \/\/ The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n *\/\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    \/**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     *\/\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    \/**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\/\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        \/\/ We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        \/\/ we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        \/\/ the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n}\n\n\/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n *\/\nabstract contract Pausable is Context {\n    \/**\n     * @dev Emitted when the pause is triggered by `account`.\n     *\/\n    event Paused(address account);\n\n    \/**\n     * @dev Emitted when the pause is lifted by `account`.\n     *\/\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    \/**\n     * @dev Initializes the contract in unpaused state.\n     *\/\n    constructor() {\n        _paused = false;\n    }\n\n    \/**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     *\/\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    \/**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     *\/\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    \/**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     *\/\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    \/**\n     * @dev Throws if the contract is paused.\n     *\/\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    \/**\n     * @dev Throws if the contract is not paused.\n     *\/\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    \/**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     *\/\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    \/**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     *\/\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n\/**\n * Tiramisu \u2013 A whitelisted airdrop that allows recipients to receive a fixed amount at once\n * Owner can bulk load the total amount of tokens for each beneficiary\n * Beneficiaries can claim the tokens at any time\n *\/\ncontract Tiramisu is Ownable, Pausable, ReentrancyGuard {\n    \n    using SafeERC20 for IERC20;\n\n    \/\/ The token to be airdropped\n    IERC20 public token;\n    \n    \/\/ The wallet that holds the funds for the airdrop\n    address public wallet;\n    \n    \/\/ Amount of tokens to claim per beneficiary\n    mapping (address => uint256) public totalTokens;\n\n    \/\/ Event emitted when a beneficiary is loaded with tokens\n    event BeneficiaryLoaded(address indexed user, uint256 qty);\n\n    \/\/ Event emitted when a beneficiary claims tokens\n    event Claim(address indexed user, uint256 qty);\n\n    \/\/ Event emitted when the owner sets a new Token\n    event TokenChanged(address indexed newToken);\n\n    \/\/ Event emitted when the owner sets a new Wallet\n    event WalletChanged(address indexed newWallet);\n\n    \/**\n     * Constructor to initialize the Tiramisu contract\n     * @param _token The ERC20 token contract address\n     * @param _owner The initial owner of the contract\n     * @param _wallet The address holding the airdrop tokens\n     *\/\n    constructor (IERC20 _token, address _owner, address _wallet) Ownable() {\n        require(address(_token)!=address(0), \"Token cannot be the zero address\");\n        require(_wallet!=address(0), \"Wallet cannot be the zero address\");\n        token = _token;\n        wallet = _wallet;\n        transferOwnership(_owner);\n    }\n\n    \/**\n     * @dev Allows the contract owner to bulk load the addresses and their corresponding total token amounts for airdrop.\n     * @param beneficiaries_ Array of beneficiary addresses. Zero Addresses are ignored\n     * @param quantities_ Array of total token quantities to airdrop to each account\n     *\/\n    function load(address[] memory beneficiaries_, uint256[] memory quantities_) external onlyOwner {\n        for (uint256 index = 0; index < beneficiaries_.length; index++) {\n            if (beneficiaries_[index] != address(0)) {\n                emit BeneficiaryLoaded(beneficiaries_[index], quantities_[index]);\n                totalTokens[beneficiaries_[index]] = quantities_[index];\n            }\n        }\n    }\n\n    \/**\n     * @dev Allows the contract owner to load a single beneficiary's address and the total token amount to airdrop to their account.\n     * @param beneficiary_ The address of the beneficiary\n     * @param qty_ The quantity of tokens to airdrop to the account\n     *\/\n    function loadSingle(address beneficiary_, uint256 qty_) external onlyOwner {\n        require(address(beneficiary_)!=address(0), \"Beneficiary cannot be the zero address\");\n        totalTokens[beneficiary_] = qty_;\n        emit BeneficiaryLoaded(beneficiary_, qty_);\n    }\n\n    \/**\n     * @dev Allows beneficiaries to claim the tokens allocated to them. The claim is subject to available balance and approval by the contract owner.\n     *\/\n    function claim() external nonReentrant whenNotPaused {\n        uint256 _amountToClaim = totalTokens[msg.sender];\n        require(_amountToClaim > 0, \"Error: No tokens available for claiming.\");\n        \/\/ Check allowance before transferring tokens\n        uint256 allowance = token.allowance(wallet, address(this));\n        require(allowance >= _amountToClaim, \"Insufficient allowance. Approve the contract to spend tokens.\");\n        totalTokens[msg.sender] = 0;\n        emit Claim(msg.sender, _amountToClaim);\n        token.safeTransferFrom(wallet, msg.sender, _amountToClaim);\n    }\n    \n    \/**\n     * Owner functions to set contract parameters\n     *\/\n\n    \/**\n     * @dev Changes the address of the ERC20 token contract. Only the contract owner can perform this action.\n     * @param token_ The new ERC20 token contract address\n     *\/\n    function changeToken(IERC20 token_) external onlyOwner {\n        require(address(token_)!=address(0), \"Token cannot be the zero address\");\n        emit TokenChanged(address(token_));\n        token = token_;\n    }\n\n    \/**\n     * @dev Changes the wallet address holding the airdrop tokens. Only the contract owner can perform this action.\n     * @param _wallet The new wallet address\n     *\/\n    function changeWallet(address _wallet) external onlyOwner {\n        require(_wallet!=address(0), \"Wallet cannot be the zero address\");\n        emit WalletChanged(_wallet);\n        wallet = _wallet;\n    }\n    \n    \/**\n     * @dev Pause the airdrop activity\n     *\/\n    function pause() external onlyOwner() {\n        _pause();\n    }\n\n    \/**\n     * @dev Resume the airdrop activity\n     *\/\n    function unpause() external onlyOwner() {\n        _unpause();\n    }\n\n    \/\/ Fallback function to handle accidental transfers of Ether and revert them.\n    receive() external payable {\n        revert(\"Ether transfers are not accepted by this contract.\");\n    }\n\n}",
                "contractName": "Tiramisu",
                "version": "1.0",
                "compilerVersion": "v0.8.2"
            }
        }
    }
}